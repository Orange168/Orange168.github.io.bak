<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[推送实践]]></title>
      <url>%2F2017%2F12%2F23%2Fjpush-note%2F</url>
      <content type="text"><![CDATA[极光推送介绍极光推送自动集成官方 Android SDK 集成指南集成实践详细步骤 注册极光账号 并配置Android 程序包名 集成依赖 12345678910111213141516171819android &#123; defaultConfig &#123; applicationId &quot;com.xxx.xxx&quot; //JPush上注册的包名. ndk &#123; //选择要添加的对应cpu类型的.so库。 abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;armeabi-v8a&apos; // 还可以添加 &apos;x86&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos; &#125; manifestPlaceholders = [ JPUSH_PKGNAME : applicationId, JPUSH_APPKEY : &quot;你的appkey&quot;, //JPush上注册的包名对应的appkey. JPUSH_CHANNEL : &quot;developer-default&quot;, //暂时填写默认值即可. ] &#125;&#125;dependencies &#123; compile &apos;cn.jiguang.sdk:jpush:3.0.0&apos; // 此处以JPush 3.0.0 版本为例。 compile &apos;cn.jiguang.sdk:jcore:1.0.0&apos; // 此处以JCore 1.0.0 版本为例。&#125; gradle.properties 增加 android.useDeprecatedNdk=true 使用旧版本的ndk集成方式,不添加会报错: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. AndroidManifest.xml 自定义的广播接收器 123456789101112131415161718192021222324&lt;!-- ************************************* --&gt;&lt;!-- The beginning setting of JPush --&gt;&lt;!-- ************************************* --&gt;&lt;!-- User defined. 用户自定义的广播接收器--&gt;&lt;receiver android:name=".component.JPushReceive" android:enabled="true"&gt; &lt;intent-filter&gt; &lt;!--Required 用户注册SDK的intent--&gt; &lt;action android:name="cn.jpush.android.intent.REGISTRATION" /&gt; &lt;!--Required 用户接收SDK消息的intent--&gt; &lt;action android:name="cn.jpush.android.intent.MESSAGE_RECEIVED" /&gt; &lt;!--Required 用户接收SDK通知栏信息的intent--&gt; &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_RECEIVED" /&gt; &lt;!--Required 用户打开自定义通知栏的intent--&gt; &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_OPENED" /&gt; &lt;!-- 接收网络变化 连接/断开 since 1.6.3 --&gt; &lt;action android:name="cn.jpush.android.intent.CONNECTION" /&gt; &lt;category android:name="com.moement" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;!-- ************************************* --&gt;&lt;!-- The end setting of JPush --&gt;&lt;!-- ************************************* --&gt; 自定义广播接收器官方Demo代码 JPushReceive.java 以上步骤已经完成Api集成 测试API集成是否成功 运行App，到控制台发送测试推送 【重点-填坑】如果没有收到推送重启手机， 日志会打印某些jni调用的代码未找到； 进价别名与标签把绑定关系保存到 JPush 服务器端 使用案例： 动态标签 根据角色和地域等相关的信息动态设置标签和别名，从而区分收到推送的客户；相关方法123JPushInterface.setAlias(Context context,String alias, TagAliasCallback CallBack);JPushInterface.setTags(Context ctx,Set&lt;String&gt; tags, TagAliasCallback CallBack);JPushInterface.setAliasAndTags(getApplicationContext(), null, (Set&lt;String&gt;) msg.obj, mTagsCallback); RegistrationID把绑定关系保存到开发者应用服务器中 客户端设置通知栏样式 铃声、震动显示图标替换默认的通知栏样式。 自定义通知栏样式12345678910111213141516171819202122232425262728293031323334/** * 设置通知提示方式 - 基础属性 */private void setStyleBasic() &#123; BasicPushNotificationBuilder builder = new BasicPushNotificationBuilder(PushSetActivity.this); builder.statusBarDrawable = R.drawable.ic_launcher; builder.notificationFlags = Notification.FLAG_AUTO_CANCEL; //设置为点击后自动消失 builder.notificationDefaults = Notification.DEFAULT_SOUND; //设置为铃声（ Notification.DEFAULT_SOUND）或者震动（ Notification.DEFAULT_VIBRATE） JPushInterface.setPushNotificationBuilder(1, builder); Toast.makeText(PushSetActivity.this, &quot;Basic Builder - 1&quot;, Toast.LENGTH_SHORT).show();&#125;/** * 设置通知栏样式 - 定义通知栏Layout */private void setStyleCustom() &#123; CustomPushNotificationBuilder builder = new CustomPushNotificationBuilder(PushSetActivity.this, R.layout.customer_notitfication_layout, R.id.icon, R.id.title, R.id.text); builder.layoutIconDrawable = R.drawable.ic_launcher; builder.developerArg0 = &quot;developerArg2&quot;; JPushInterface.setPushNotificationBuilder(2, builder); Toast.makeText(PushSetActivity.this, &quot;Custom Builder - 2&quot;, Toast.LENGTH_SHORT).show();&#125;private void setAddActionsStyle() &#123; MultiActionsNotificationBuilder builder = new MultiActionsNotificationBuilder(PushSetActivity.this); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;first&quot;, &quot;my_extra1&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;second&quot;, &quot;my_extra2&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;third&quot;, &quot;my_extra3&quot;); JPushInterface.setPushNotificationBuilder(10, builder); Toast.makeText(PushSetActivity.this, &quot;AddActions Builder - 10&quot;, Toast.LENGTH_SHORT).show();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Rx 学习笔记]]></title>
      <url>%2F2017%2F02%2F01%2Frx-learning-note%2F</url>
      <content type="text"><![CDATA[Open Source RxUi Implementation of pure functional concept of talking to Android View layer in a Reactive way ReactiveCache Android-RxJava-samples Rex-weather Rx 相关的开源工具库 RxAnimations Resource Homepage http://reactivex.io/ RxJava 操作符动画效果演示 http://rxmarbles.com/ Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#0 【重点】 Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#1【重点】 Testing asynchronous RxJava code using Mockito RxRecipes: Wrap your way to Rx 主要讲 fromCallable() fromAction() 替换Rx中的接口； Rxify : The Anti Cache-then-Network OR Network-then-Cache Problem 使用RX concat onErrorResumeNext onErrorReturn 处理访问网络失败后返回本地缓存的机制。 Rx 应用 Android animations powered by RxJava RxJS RxJS The Reactive Extensions for JavaScript http://reactivex.io Big list of functions 常用函数的例子 Creating Observables 产生Observable的方法 The introduction to Reactive Programming you’ve been missing 对应的 Demo RxJava Doc for operators RxBindingflatMap //压缩到一个Map first() vs. takeFirst()The difference between the two calls is that first() will throw a NoSuchElementException if none of the sources emits valid data, whereas takeFirst() will simply complete without exception. RxJava操作符笔记 FlatMap最后的发射顺序可能交错，对顺序有要求可以使用concatmap- Scheduler 的 API (一)在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 实战笔记 RxJava-Android-SamplesRetrofitFragment.javaObservable.zip / Observable.just gist code DebounceSearchEmitterFragment.javaRxTextView.textChangeEvents gitst code BufferDemoFragment.java RxView.clickEvents/ .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 1234567891011121314private Subscription _getBufferedSubscription() &#123; return RxView.clickEvents(_tapBtn) .map(new Func1&lt;ViewClickEvent, Integer&gt;() &#123; @Override public Integer call(ViewClickEvent onClickEvent) &#123; Timber.d("--------- GOT A TAP"); _log("GOT A TAP"); return 1; &#125; &#125;) .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123;&#125; ）； PublishSubject 123456789PublishSubject&lt;Float&gt; _resultEmitterSubject = PublishSubject.create(); _subscription = _resultEmitterSubject.asObservable().subscribe(new Action1&lt;Float&gt;() &#123; @Override public void call(Float aFloat) &#123; _result.setText(String.valueOf(aFloat)); &#125; &#125;); _resultEmitterSubject.onNext(num1 + num2); @OnTextChanged PollingFragment.javaCompositeSubscription / interval /doOnSubscribe /repeatWhen /Observable.timer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 _subscriptions.add(// Observable.just(1) .repeatWhen(new RepeatWithDelay(pollCount, pollingInterval)) .subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object o) &#123; _log(String.format(Locale.US, "Executing polled task now time : [xx:%02d]", _getSecondHand())); &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable e) &#123; Timber.d(e, "arrrr. Error"); &#125; &#125;) ); _subscriptions.add(// Observable.interval(INITIAL_DELAY, POLLING_INTERVAL, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long heartBeat) &#123; return _doNetworkCallAndGetStringResult(heartBeat); &#125; &#125;).take(pollCount) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; _log(String.format("Start simple polling - %s", _counter)); &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String taskName) &#123; _log(String.format(Locale.US, "Executing polled task [%s] now time : [xx:%02d]", taskName, _getSecondHand())); &#125; &#125;) );public class RepeatWithDelay implements Func1&lt;Observable&lt;? extends Void&gt;, Observable&lt;?&gt;&gt; &#123; private final int _repeatLimit; private final int _pollingInterval; private int _repeatCount = 1; RepeatWithDelay(int repeatLimit, int pollingInterval) &#123; _pollingInterval = pollingInterval; _repeatLimit = repeatLimit; &#125; // this is a notificationhandler, all we care about is // the emission "type" not emission "content" // only onNext triggers a re-subscription @Override public Observable&lt;?&gt; call(Observable&lt;? extends Void&gt; inputObservable) &#123; // it is critical to use inputObservable in the chain for the result // ignoring it and doing your own thing will break the sequence return inputObservable.flatMap(new Func1&lt;Void, Observable&lt;?&gt;&gt;() &#123; @Override public Observable&lt;?&gt; call(Void blah) &#123; if (_repeatCount &gt;= _repeatLimit) &#123; // terminate the sequence cause we reached the limit _log("Completing sequence"); return Observable.empty(); &#125; // since we don't get an input // we store state in this handler to tell us the point of time we're firing _repeatCount++; return Observable.timer(_repeatCount * _pollingInterval, TimeUnit.MILLISECONDS); &#125; &#125;); &#125;&#125; RxBusDemoFragment.javaConnectableObservable / SerializedSubjectgist代码 123456789101112131415private final Subject&lt;Object, Object&gt; _bus = new SerializedSubject&lt;&gt;(PublishSubject.create());_bus.onNext(object);_bus.hasObservers();ConnectableObservable&lt;Object&gt; tapEventEmitter = _rxBus.toObserverable().publish(); _subscriptions// .add(tapEventEmitter.subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object event) &#123; if (event instanceof RxBusDemoFragment.TapEvent) &#123; _showTapText(); &#125; &#125; &#125;)); stream.buffer(stream.debounce(1, TimeUnit.SECONDS)); _subscriptions.add(tapEventEmitter.connect()); FormValidationCombineLatestFragment.java 1234private Observable&lt;CharSequence&gt; _numberChangeObservable = RxTextView.textChanges(_email_editText).skip(1); _subscription = Observable.combineLatest(_emailChangeObservable, _passwordChangeObservable, _numberChangeObservable, new Fun3...) PseudoCacheMergeFragment.javaObservable.merge();TimingDemoFragment.java 12345Observable.timer(2, TimeUnit.SECONDS)// //.just(1).delay(2, TimeUnit.SECONDS)// //.interval(1, TimeUnit.SECONDS)// //.interval(0, 1, TimeUnit.SECONDS)// //.interval(3, TimeUnit.SECONDS).take(5)// ExponentialBackoffFragment.java 1234567891011121314151617181920 Observable// .error(new RuntimeException("testing")) // always fails .retryWhen(new RetryWithDelay(5, 1000)) //当错误时调用，适用于错误处理 //1-4 指数的递增延迟Observable.range(1, 4)// .delay(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(final Integer integer) &#123; // Rx-y way of doing the Fibonnaci :P return MathObservable// .sumInteger(Observable.range(1, integer)) .flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(Integer targetSecondDelay) &#123; return Observable.just(integer) .delay(targetSecondDelay, TimeUnit.SECONDS); &#125; &#125;); &#125; &#125;)// 123RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Gradle 学习积累]]></title>
      <url>%2F2017%2F01%2F08%2Fgradle-note%2F</url>
      <content type="text"><![CDATA[基础教程 实践博客 Google’s guide on Gradle for Android 美团Android自动化之旅—适配渠道包 Android Gradle实战中遇到的问题与经验 Maven 建立企业内部maven服务器并使用Android Studio发布公共项目。 Gradle Tutorial Gradle 用法总结 构建神器Gradle 翻译gradle for android ==&gt;gradle for android pdf Writing Custom Plugins gradle官方文档，自定义插件拿到Project类，就可以拿到几乎所有工程配置的属性和方法，然后发挥想象控制你的工程。 官网资料 Chapter 23. Dependency Management 【待研究】 Chapter 45. The Java Plugin DependencyHandler Gradle Plugin User Guide Android Studio 官网提供的Gradle实用教程 Android Plugin DSL Reference build.gradle android{….} API 进阶博文 Android Gradle编译过程 比较详细的讲述了Gradle 编译 Apk的过程。 Weapons for Boilerplate Destruction 之Gradle 篇以上project.extensions.create….,可以使用${project.myextension.aNumber}访问到对应的属性 进阶源码阅读 hugo JakeWharton 不必介绍了。项目中使用Gradle plugin 和自定义Task 顺便学习一些Process Annotation. 开源插件 gradle-android-junit-jacoco-plugin可以生成代码单元测试覆盖率报告的 Gradle 插件。 gradle-android-javadoc-plugin可以生成 java doc 的 Gradle 插件。 gradle-android-apk-size-plugin可以将 Apk 大小记录到 CSV 文件的 Gradle 插件。 android-fat-aar Gradle script that allows you to merge and embed dependencies in generted aar file. ProperDroid simplifies the way that config different variant on your project. dexcount-gradle-plugin A Gradle plugin to report the number of method references in your APK on every build. 使用案例 本地引入.aar文件 12345678dependencies &#123; compile(name:'nameOfYourAARFileWithoutExtension', ext:'aar') &#125;repositories&#123; flatDir&#123; dirs 'libs' &#125; &#125; gradleBuildTime.gradle 获取build脚本每个任务（Task）执行的时间。 gradle.properties 自定义 buildConfigField 外部变量 修改output/apk/[自定义].apk 每次构建工程把git版本控制的信息加入VersionName中 123def gitSha = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim()def gitTag = 'git tag'.execute([], project.rootDir).text.trim().split("\n").last()def gitCommits = Integer.parseInt('git rev-list --count HEAD'.execute([], project.rootDir).text.trim()) 动态修改Manifest中的参数 1234567891011121314android &#123; compileSdkVersion 23 buildToolsVersion '23.0.2' defaultConfig &#123; applicationId "com.liulishuo.engzo" minSdkVersion 15 targetSdkVersion 23 manifestPlaceholders = [ // 这里需要换成:tencent+你的AppId "tencentAuthId": "tencent123456", ] &#125;｝ 使用全局变量进行依赖版本及一些常用配置的统一管理 配置 Apk split 使Android Studio每个对应的Cpu 架构都生成单独的apk，减小整个应用的大小。 rootdirOfProject/gradle.properties 配置变量如： VERSION_NAME=1.2.2-SNAPSHOT 然后可以在配置文件所在项目中的所有*.gradle 文件直接引用。 有点类似Java public static的感觉。 Java 指定JDK版本 12345678android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7// targetCompatibility JavaVersion.VERSION_1_8// sourceCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 签名信息(release.keystore)的存放方式 stackoverflow Android — How to add Gradle dependencies using ‘foreach’ 很多开源项目都把依赖统一管理, 这个博文是做得做系统和简洁 问题解决 依赖更新项目依赖的远程包如果有更新，会有提醒或者自动更新吗？ 不会的，需要你手动设置changing标记为true，这样gradle会每24小时检查更新，通过更改resolutionStrategy可以修改检查周期。1234567configurations.all &#123;// check for updates every buildresolutionStrategy.cacheChangingModulesFor 0, 'seconds'&#125;dependencies &#123;compile group: "group", name: "projectA", version: "1.1-SNAPSHOT", changing: true&#125; 之前上传aar同一版本到maven仓库，但依赖却没有更新，该怎么办呢?可以直接删除本地缓存，缓存在~/.gradle/caches目录下，删除缓存后，下次运行就会自动重新下载远程依赖了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android测试资源集合,测试工具,测试开源项目]]></title>
      <url>%2F2016%2F12%2F03%2Fandroid-test%2F</url>
      <content type="text"><![CDATA[测试第三方服务 国内 https://bugly.qq.com/v2/ 腾讯的bugly 免费, 而且相当好用 腾讯优测云 提供真机测试和漏洞分析 Testin MTC 易测云 国外 TestCloud Testdroid Nimbledroid Automated performance analysis website Test bird APP和手游测试 第三方性能采集SDK OneAPM 听云 自动化测试 CircleCI 一个基于Github的自动化测试，单元测试工具，提供一个免费的私有仓库。 Google官方学习资料 Best Practices for Testing 【最新/重点】 Android Testing Support library (ATSL) 【重点】相关视频： Android Testing (Android Dev Summit 2015) youtube 2015年视频 Developer API Testing Concepts 优秀博客 Java 测试 Leveraging product flavors in Android Studio for hermetic testing 与之对应的 codelab学习地址笔记： Just Say No to More End-to-End Tests two JUnit Rules @rule will be launched before @Before. The ActivityTestRule is a rule that provides functional testing of a single Activity. Test coverage report for Android application 使用jacoco-android plugin in a build.gradle进行测试覆盖率报告 Android单元测试在蘑菇街支付金融部门的实践 很详细介绍了单元测试在实践操作中的使用 RxJava Test Unit Testing RxJava Observables and Subscriptions Unit Testing RxJava Observables Unit Testing with RxJava 测试框架 Unit Testing Junit4 Github A programmer-oriented testing framework for Java.http://junit.org/junit4/ Mockito Tasty mocking framework for unit tests in Java JMockit An automated testing toolkit for Java对比： mockito不能mock static method和final class、final method，JMockit可以；对比Mockito和JMockit的文章 PowerMock 一个可以Mock静态类的开源库 Tools for UI Testing: Robotium, Appium, Calabash, Robolectric. UI Testing Espresso Android 官方推荐使用的UI测试库 UIAutomator 可以夸应用进行测试 Robolectric is a unit test framework that de-fangs the Android SDK jar so you can test-drive the development of your Android app. Tests run inside the JVM on your workstation in seconds More RoboSpock Github A testing framework which brings powers of Spock and Groovy to Android app testing http://robospock.org Hamcrest matchersWhat is Hamcrest?Hamcrest is a library of matchers, which can be combined in to create flexible expressions of intent in tests. They’ve also been used for other purposes. 开源库 Collection awesome-android-testing collection of android test info 【重点】 Sample android-gradle-java-template Gradle + Android Studio + Robolectric + Espresso + Mockito + EasyMock/PowerMock + JaCoCo Demo Android-Clean-Testing Android Testing Sample Project robotium-showcase This example shows how to use Robotium with ActvitityTestRule and @Test annotation, it means in Google’s Espresso way. Google Sample android-testing-templates android-testing A collection of samples demonstrating different frameworks and techniques for automated testing Tools 测试工具square/spoon在adb devices 检测到的设备跑测试程序，并提供截屏，文件，数据库操作：最最重要的是生成简单明了的测试报告： Android Studio 2.2 Preview new feature: Espresso Test Recorder 菜单/run/Recorder Expresso Test 选项可以记录你的操作并转化为Espresso 的测试代码 APK Analyzer 菜单/build/Analyzer APK 提供APK大小分析工具，清楚的知道代码体积变换的趋势。 screengrab 当UI Tests 时自动化截屏STF 远程控制，一台电脑控制测试多个测试设openstf.github.io Control and manage Android devices from your browser 开发时的调试工具stethoFacebook开源，很强大的Android网络和数据库调试工具,能像调试WebApp一样调试Android原生应用。借助Stetho在Chrome上调试Android网络&amp;数据库常用配置: 初始化 123456public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); Stetho.initializeWithDefaults(this); &#125;&#125; Chrome浏览器打开chrome://inspect/#devices 进阶增加网络拦截 Dependency 增加依赖环境 12345compile 'com.facebook.stetho:stetho:1.3.1'compile 'com.facebook.stetho:stetho-okhttp3:1.3.1'compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'compile 'com.squareup.okhttp3:okhttp:3.2.0'compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4' 向OkHttpClient增加网络拦截 123OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); augmented-traffic-controlFackbook开源项目模拟移动网络，对App的调试及网络优化有很大的帮助，主要参数有：12345网络带宽（bandwidth）延迟（latency）丢包率（packet loss）错包率（corrupted packets）乱序率（packets ordering） GT（随身调） 腾讯开源的测试套件能Android设备上安装,进行移动调试,确保测试数据的真实有效性开源地址: https://github.com/TencentOpen/GT官网地址 使用GT APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。 12345678910111213141516一. 基本功能测试1. CPU占有率;2 jiffes（CPU时间片）;3. 内存PSS值稳定在36M;4. 网络上行流量和下行流量;5. "数据存档"二. 电量测试再启动电流监控观察，1分钟后平均电流是220mA三. crash- 保存了抓包文件后;- Logcat查看界面，立即把手机缓存的Logcat日志保存下来;四. Net- 系统提供的流量查看也包括局域网socket的流量,而且不能分时段统计;- tcpdump抓包(需要手机root) + Wiresharek 抓包分析;疑问点:1. 激活FPS（帧率）的监测; 应用开发助手 Google Play、应用宝搜索“开发助手”下载， 或Download1234屏幕分辨率、CPU 核数、IP 及 Mac 地址、so 类型、系统版本。频繁切换“严格模式”；多次启停“显示布局边界”；测试被系统回收来回切换“不保留活动”； Purchase UI Tool (付费工具) Robotium Recorder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo Tutorial]]></title>
      <url>%2F2016%2F12%2F03%2Fhexo-tutorial%2F</url>
      <content type="text"><![CDATA[Hexo 相关教程 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hexo安装环境准备 Git / Node.js hexo官方教程两个初始化命令hexo init 类似git init 需要新建目录保存博文信息； 执行命令会在当前目录下生产如下文件：123456├── _config.yml #全局配置文件├── node_modules #Hexo插件（Node.js 插件默认安装目录）├── package.json #Node 工程的依赖和基本信息├── scaffolds #模板├── source #博客正文源文件└── themes 【重点】如果你有配置，会覆盖你原来的配置； npm install #安装package.json 下面的依赖包hexo http://localhost:4000/ 检查是否安装成功hexo 配置hexo-theme-next主题的配置 最强主题基本上所有的配置信息都能满足,优雅,文档齐全 安装 Next主题 基本和教程走一边,就可以得到一个很牛的网站了 三种主题样式的选择： hexo/themes/next/_config.xml 搜索 scheme 注册云存储存储图片防止图片链接失效,和在博客迁移过程中导致的图片获取异常,丢失. 统一管理文章中的图片 七牛 域名绑定 设置域名的指向的地址 在源文件中增加github page 的设置文件 source/CNAME 并增加你的域名,不带www的,例如:’taobao.com’ Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sitesMore info: Deployment1$ hexo deploy 常用的方法命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 一般的发布步骤123hexo clean #删除产生的文件和缓存hexo (g)generate # 生成静太文件hexo (d)deploy # 发布网页 日常维护命令123npm update -g hexo #hexo 更新cd /&#123;you-blog-dir&#125;/theme/next git pull #更新主题代码npm update # 更新插件 问题解决 ERROR Plugin load failed: hexo-server 解决: npm install hexo-server 参考 GitHub Pages 绑定来自阿里云的域名 手把手教你建github技术博客]]></content>
    </entry>

    
  
  
</search>
