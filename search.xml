<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[亿级电商缓存项目学习]]></title>
    <url>%2F2019%2F08%2F12%2F2019-8-12-ecommerce-cache-learning%2F</url>
    <content type="text"><![CDATA[第一章 环境搭建1.1 CentOS1.1.1 网络设置第一步： IP设置 配置虚拟机网络环境为桥接 修改I虚拟机网络设置 vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改为 DEVICE=eth0 TYPE=Ethernet ONBOOT=yes BOOTPROTO=dhcp 重启网络分配IP service network restart 固定IP地址 BOOTPROTO=static IPADDR=192.168.1.9 GATWAY=192.168.1.1 NETMASK= 255.255.255.0 到此，系统可以连接局域和互联网 第二步： hosts设置 修改hosts vi /etc/hosts 192.168.1.9 ec-01 192.168.1.12 ec-02 192.168.1.11 ec-03 192.168.1.13 ec-04 第三步：关闭防火墙 开启防火墙导致，大数据开发中机器本地无法互联 service iptables stop service ip6tables stop chkconfig iptables off chkconfig ip6tables off vi /etc/selinux/config 关闭selinux SELINUX=disable 第四步：关闭window防火墙关闭 1.1.2 配置yumyum clean all yum makechache yum install wget 1.2 软件安装1.2.1 JDKtar安装 $ tar -zxvf jdk-8u5-linux-x64.tar.gz export JAVA_HOME=/usr/local/java/jdk1.8.0_45 export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export PATH=:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH source /etc/profile rpm 方式安装 rpm -ivh jdk-7u65-linux-i586.rpm vi ~/.bashrc export JAVA_HOME=/usr/java/latest export PATH=$PATH:$JAVA_HOME/bin source ~/.bashrc 1.2.2 Perlhttp://www.cpan.org/src/ yum install -y gcc wget https://www.cpan.org/src/5.0/perl-5.30.0.tar.gz tar -xzf perl-5.30.0.tar.gz cd perl-5.30.0 ./Configure -des -Dprefix=/usr/local/perl make && make test && make install 1.2.3 redis安装 wget http://downloads.sourceforge.net/tcl/tcl8.6.9-src.tar.gz &&\ && tar -xzvf tcl8.6.9-src.tar.gz \ && cd ./tcl8.6.9/unix/ \ && ./configure \ && make && make install https://redis.io/download wget http://download.redis.io/releases/redis-5.0.5.tar.gz && \ && tar xzf redis-4.0.10.tar.gz \ && cd redis-4.0.10 \ && make && make test && make install 测试 $ src/redis-server $ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; (1) 生产环境启动方案第一步：修改redis.conf vi redis.conf daemonize yes #让redis以daemon进程运行 pidfile /var/run/redis_6379.pid #设置redis的pid文件位置 port 6379 #设置redis的监听端口号 dir /var/redis/6379 #设置持久化文件的存储位置 第二步：启动 cp src/redis-server /usr/local/bin/ \ && cp src/redis-cli /usr/local/bin/ \ && cp utils/redis_init_script /etc/init.d/redis_6379 \ && mkdir /etc/redis/ -p && mkdir /var/redis/6379 -p \ && cp redis.conf /etc/redis/6379.conf \ && cd /etc/init.d && chmod 777 redis_6379 && ./redis_6379 start 第三步：测试redis是否正常启动 vi /etc/init.d/redis_6379 ps -ef | grep redis 第四步：让redis跟随系统启动自动启动 vi /etc/init.d/redis_6379, 最上面，加入两行注释，保存退出 # chkconfig: 2345 90 10 # description: Redis is a persistent key-value database chkconf 参数概述 ​ 参数一2345 -&gt; 这个服务以什么样的运行级别开始 ​ 第二个参数90 -&gt; 启动的优先等级 ​ 第三个参数10 -&gt; 停止优先级 配置生效 chkconfig redis_6379 on #查看是否生效 chkconfig -list (2) 主从架构搭建第一步：slave基本配置好配置， 步骤同上 （1）生产环境启动方案 第二步：配置slave连接主机IP，搜索masterip 看是如下那种，配置master IP和端口 replicaof slaveof redis.5.0.5 案例 replicaof 192.168.1.1 6379 第三步：强制读写分离 replica-read-only yes 默认开启 第四步：集群安全认证 master 配置访问密码 requirepass foobared slave 配置master的连接口令 masterauth 第五步：网络设置 1、 master 开启网络监听 bind 127.0.0.1 192.168.1.x 注意：只开启127.0.0.1， slave无法连接master 2.、开启端口访问权限 CentOS 7,使用firewall #添加端口权限 firewall-cmd --add-port=6379/tcp #删除端口： firewall-cmd --remove-port=6379/tcp #查看端口 firewall-cmd --query-port=6379/tcp #永久开放端口 firewall-cmd --permanent --add-port=6379/tcp CentOS 7 以下 iptables -A INPUT -p tcp --dport 6379 -j ACCEPT Notice：master and slave must open the 6379 port permission (3) 哨兵集群配置哨兵详细文档： http://doc.redisfans.com/topic/sentinel.html 第一步：新建文件 mkdir /etc/sentinal \ && mkdir -p /var/sentinal/5000 \ && mkdir -p /var/log/sentinal/ \ && touch /var/log/sentinal/5000 \ && vi /etc/sentinal/5000.conf 第二步：哨兵配置模板文件修改，简化版，详细配置查看附录一sentinal.conf # port port 5000 ## bind 127.0.0.1 bind 192.168.1.13 #dir dir /var/sentinal/5000 # sentinel monitor sentinel monitor mymaster 192.168.1.13 6379 2 #超过多少毫秒跟一个redis实例断了连接，哨兵就可能认为这个redis实例挂了 #sentinel down-after-milliseconds sentinel down-after-milliseconds mymaster 60000 #执行故障转移的timeout超时时长 ##sentinel failover-timeout sentinel failover-timeout mymaster 180000 #新的master切换之后 最多可以有多少个从服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。 sentinel parallel-syncs mymaster 1 # sentinel auth-pass sentinel auth-pass mymaster redis-pass #后台运行 daemonize yes logfile /var/log/sentinal/5000 Notice: 所有的sentinal都是相同的配置只需改如下两点： bind &lt;local_ip&gt; 本机的IP地址 sentinel monitor mymaster &lt;master_ip&gt; 第三步：启动所有哨兵 1、 redis-server方式，推荐 redis-server /etc/sentinal/5000.conf --sentinel 2、redis-sentinel 方式 redis-sentinel /etc/sentinal/5000.conf 第四步：检查哨兵状态 1、连接哨兵 redis-cli -h 192.168.1.12 -p 5000 2、连接成功后，基本状态查询 #列出所有被监视的主服务器，以及这些主服务器的当前状态。 192.168.1.12:5000> sentinel master mymaster #列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。 192.168.1.12:5000> SENTINEL slaves mymaster 192.168.1.12:5000> SENTINEL sentinels mymaster 192.168.1.12:5000> SENTINEL get-master-addr-by-name mymaster (4) 测试1、 测试port是否开放 yum install -y nc nc -v host port 2、查看主从架构状态 127.0.0.1:6379> info replication # Replication role:slave master_host:192.168.1.12 master_port:6379 master_link_status:up # 主从连接成功 down为失败 master_last_io_seconds_ago:2 master_sync_in_progress:0 slave_repl_offset:1736 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:f9acbb0bc2a6d662b6a5c4c3edcdec831b14a351 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1736 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:1736 3、测试QPS 在redis源码目录src/redis-benchmark ./redis-benchmark -h 192.168.1.12 -c Number of parallel connections (default 50) -n Total number of requests (default 100000) -d Data size of SET/GET value in bytes (default 2) 1核1G，虚拟机，自己用redis5.0.5搭建的3500.00 qps少了个数量级 ====== PING_INLINE ====== 100000 requests completed in 1.28 seconds 50 parallel clients 3 bytes payload keep alive: 1 99.78%]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG笔记]]></title>
    <url>%2F2019%2F07%2F29%2F2019-7-29-SVG-note%2F</url>
    <content type="text"><![CDATA[SVG 基础知识SVG基本图形和属性图形 矩形 圆形 椭圆 线 折线 多边形 rect.svg &lt;?xml version="1.0" standalone="no"?> &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;rect x="20" y="20" rx="20" ry="20" width="250" height="250" style="fill:blue;stroke:pink;stroke-width:5; fill-opacity:0.1;stroke-opacity:0.9"/> &lt;/svg> polyline.svg &lt;?xml version="1.0" standalone="no"?> &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;polyline points="0,0 0,20 20,20 20,40 40,40 40,60" style="fill:white;stroke:red;stroke-width:2"/> &lt;/svg> polygon.svg &lt;?xml version="1.0" standalone="no"?> &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;polygon points="220,100 300,210 170,250" style="fill:#cccccc; stroke:#000000;stroke-width:1"/> &lt;/svg> 基本属性 fill stroke stroke-width transform 基本操作API 创建图形 createElementNs(ns,tagName) var text = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; var NS = 'http://www.w3.org/2000/svg'; var tspan = document.createElementNS(NS,'tspan'); 添加图形 element.appendChild(childElement)  设置/获取属性 element.setAttribute(name, value ) / elememt.getAttribute(name) 设置  xlink:href  属性  textPath.setAttributeNS(“http://www.w3.org/1999/xlink&quot;,&#39;xlink:href&#39;,path) HTML&lt;html> &lt;head>&lt;/head> &lt;body> &lt;img src="sample.svg"> > &lt;embed src="sample.svg">&lt;/embed> > 外部引用式 &lt;iframe src="sample.svg">&lt;/iframe> > &lt;object data="sample.svg">&lt;/object> > &lt;svg data-src="img/buble.svg"/> &lt;/body> &lt;/html> 容器https://developer.mozilla.org/en-US/docs/Web/SVG/Element/a &lt;a>, &lt;defs>, &lt;g>, &lt;marker>, &lt;mask>, &lt;missing-glyph>, &lt;pattern>, &lt;svg>, &lt;switch>, &lt;symbol> Descriptive elements&lt;desc&gt;, medadata, title 看medata案例就可以， SVG 滤镜Gaussian_blur.svg &lt;?xml version="1.0" standalone="no"?> &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;defs> &lt;filter id="Gaussian_Blur"> &lt;feGaussianBlur in="SourceGraphic" stdDeviation="3" /> &lt;/filter> &lt;/defs> &lt;ellipse cx="200" cy="150" rx="70" ry="40" style="fill:#ff0000;stroke:#000000; stroke-width:2;filter:url(#Gaussian_Blur)"/> &lt;/svg> 注解： filter 定义滤镜 filter:url引用滤镜 stdDeviation 模糊程度 in=”SourceGraphic” 定义整个创建效果 滤镜效果有 feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset feSpecularLighting feTile feTurbulence feDistantLight fePointLight feSpotLight SVG 滤镜效果可以叠加使用 multi-filter.svg &lt;!-- Learn about this code on MDN: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feGaussianBlur --> &lt;svg width="120" height="120" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> &lt;filter id="dropShadow"> &lt;feGaussianBlur in="SourceAlpha" stdDeviation="3" /> &lt;feOffset dx="2" dy="4" /> &lt;feMerge> &lt;feMergeNode /> &lt;feMergeNode in="SourceGraphic" /> &lt;/feMerge> &lt;/filter> &lt;circle cx="60" cy="60" r="50" fill="green" filter="url(#dropShadow)" /> &lt;/svg> SVG中的坐标系统2.1 世界，视野和视窗的概念 世界是⽆无穷⼤大的，SVG画布可以是无穷大的 视野是观察世界的⼀一个矩形区域，可以有viewbox定义视野区域 视窗是浏览器开辟的一个区域， width, height - 控制视窗 preserveAspectRatio 控制视野和视窗之间关系 &lt;svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 400 300" preserveAspectRatio="xMidYMid meet"> &lt;/svg> 动态效果请参照：viewbox.html 2.2 图形分组 标签来创建分组 子元素可以继承组属性 transform  属性定义坐标变换 可以嵌套使用 &lt;svg xmlns="http://www.w3.org/2000/svg" > &lt;g stroke="green" fill="none" transform(0,50)> &lt;rect x="100" y="50" width="100" height="50">&lt;/rect> &lt;rect x="140" y="100" width="20" height="120">&lt;/rect> &lt;/g> &lt;/svg> 注解： g设置的stroke，fill属性， 两个rect都能继承 transform能整体改变 内坐标 2.3 坐标系统概述 如上图：svg使用的是笛卡尔坐标系统 2.4 四个坐标系 用户坐标系（User  Coordinate）: -&gt; 世界的坐标系 自身坐标系（Current  Coordinate） -&gt; 每个图形元素或分组独立与生俱来 前驱坐标系（Previous  Coordinate） -&gt; 父容器的坐标系  参考坐标系（Reference  Coordinate） -&gt; 使用其它坐标系来考究自身的情况时使用 2.5 坐标变换查看ransform.html 嵌套 , 子会继承父g坐标属性 颜色渐变和笔刷颜色HSL 渐变线性渐变linearGradient.svg &lt;?xml version="1.0" standalone="no"?> &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;defs> &lt;linearGradient id="orange_red" x1="0%" y1="0%" x2="100%" y2="0%"> &lt;stop offset="0%" style="stop-color:rgb(255,255,0); stop-opacity:1"/> &lt;stop offset="100%" style="stop-color:rgb(255,0,0); stop-opacity:1"/> &lt;/linearGradient> &lt;/defs> &lt;ellipse cx="200" cy="190" rx="85" ry="55" style="fill:url(#orange_red)"/> &lt;/svg> gradientUnits=”userSpaceOnUse（用的是世界坐标系不是图形当前的坐标系）/objectBoundingBox(默认值)” x1=&quot;0%&quot; y1=&quot;0%图形最上段， x2=&quot;100%&quot; y2=&quot;0%图形最下段 放射性渐变radialGradient.svg &lt;?xml version="1.0" standalone="no"?> &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;defs> &lt;radialGradient id="grey_blue" cx="50%" cy="50%" r="50%" fx="50%" fy="50%"> &lt;stop offset="0%" style="stop-color:rgb(200,200,200); stop-opacity:0"/> &lt;stop offset="100%" style="stop-color:rgb(0,0,255); stop-opacity:1"/> &lt;/radialGradient> &lt;/defs> &lt;ellipse cx="230" cy="200" rx="110" ry="100" style="fill:url(#grey_blue)"/> &lt;/svg> 注解： cx、cy 和 r 属性定义外圈 fx 和 fy 定义内圈，颜色渐变中心点，能产生聚光灯的效果 笔刷 patternpattern.svg &lt;svg xmlns="http://www.w3.org/2000/svg"> &lt;defs> &lt;pattern id="p1" x="0" y="0" width="50" height="50" patternUnits="userSpaceOnUse"> &lt;circle cx="10" cy="10" r="5" fill="red">&lt;/circle> &lt;polygon points="30 10 60 50 0 50" fill="green">&lt;/polygon> &lt;/pattern> &lt;pattern id="p2" x="0" y="0" width="50" height="50"> &lt;circle cx="10" cy="10" r="5" fill="red">&lt;/circle> &lt;polygon points="30 10 60 50 0 50" fill="green">&lt;/polygon> &lt;/pattern> &lt;/defs> &lt;rect x="100" y="100" width="800" height="600" fill="url(#p1)" stroke="blue">&lt;/rect> &lt;rect x="100" y="100" width="800" height="600" fill="url(#p2)" stroke="blue">&lt;/rect> &lt;/svg> objectBoundingBox : (默认)为容器百分比 userSpaceOnUse : width 和 height 以世界坐标系为准，为宽度、高度 patternUnits/patternUnitsContent Path 高级概述 规范：http://www.w3.org/TR/SVG11/paths.html  path.svg 黑色山角型 &lt;?xml version="1.0" standalone="no"?> &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;path d="M250 150 L150 350 L350 350 Z" /> &lt;/svg> Path-命令汇总 M = moveto L = lineto H = horizontal lineto V = vertical lineto C (x1,y1,x2,y2,x,y)+ = curveto 从当前位置绘制三次⻉贝塞尔曲线到指定位置 S = smooth curveto 从当前位置光滑绘制三次⻉贝塞尔曲线到指定位置 Q = quadratic Belzier curve 绘制⼆二次⻉贝塞尔曲线 T = smooth quadratic Belzier curveto 光滑绘制⼆二次⻉贝塞尔曲线 A (rx,ry,xr,laf,sf,x,y) = elliptical Arc Z = closepath A (rx,ry,xr,laf,sf,x,y) -  绘制弧线  xr  -  （xAxis-rotation） 弧线所在椭圆的长轴角度  laf  -  （large-arc-flag） 是否选择大弧长 sf  -  （sweep-flag） 是否选择逆的那一段时针方向弧 基本规律 大写为绝对位置命令，小写为相对位置命令 参考资料 SVG 1.1 Paths 详情 SVG 文本.svg&lt;svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg"> &lt;style> .small { font: italic 13px sans-serif; } .heavy { font: bold 30px sans-serif; } /* Note that the color of the text is set with the * * fill property, the color property is for HTML only */ .Rrrrr { font: italic 40px serif; fill: red; } &lt;/style> &lt;text x="20" y="35" class="small">My&lt;/text> &lt;text x="40" y="35" class="heavy">cat&lt;/text> &lt;text x="55" y="55" class="small">is&lt;/text> &lt;text x="65" y="55" class="Rrrrr">Grumpy!&lt;/text> &lt;/svg> textPath.svg&lt;svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"> &lt;!-- to hide the path, it is usually wrapped in a &lt;defs> element --> &lt;!-- &lt;defs> --> &lt;path id="MyPath" fill="none" stroke="red" d="M10,90 Q90,90 90,45 Q90,10 50,10 Q10,10 10,40 Q10,70 45,70 Q70,70 75,50" /> &lt;!-- &lt;/defs> --> &lt;text> &lt;textPath href="#MyPath"> Quick brown fox jumps over the lazy dog. &lt;/textPath> &lt;/text> &lt;/svg> x/dx/startOffset 都能使文字在path描绘的路径向前移动 text-anchor=”middle”, 一段文字初始化锚点在一段文字中间 dy dx 应用案例 JS脚本控制 setAttributeNS()设置xlink:href 属性textPath.setAttributeNS(&quot;http://www.w3.org/1999/xlink&quot;,&#39;xlink:href&#39;,path) 实战案例查看 path.html 或者是 附录-经典案例-正玄字体 tspan.svg&lt;svg xmlns="http://www.w3.org/2000/svg" > &lt;defs> &lt;pattern id="grid" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"> &lt;path stroke="#f0f0f0" fill="none" d="M0,0H20V20">&lt;/path> &lt;/pattern> &lt;/defs> &lt;rect width="1200" height="1000" fill="url(#grid)">&lt;/rect> &lt;text id="sintext" x="100" y="100" style="font-size: 50px; font-family: 'Arial'; "> &lt;tspan fill="red" dy="-20 20">AB&lt;/tspan> &lt;tspan stroke="green" fill="none" stroke-width="2" dy="-40 40">CDE&lt;/tspan> &lt;!--简单叠加的效果--> &lt;tspan fill="blue" dy="20 20 20 20 20 20">FGHIJKLM&lt;/tspan> &lt;/text> &lt;path d="M100,0V200M0,100H200" stroke="red" /> &lt;/svg> 垂直居中问题 字体位置各种案例展示 代码如下 Example.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>JS Bin&lt;/title> &lt;/head> &lt;body> &lt;select id="ta"> &lt;option value="start">start&lt;/option> &lt;option value="end">end&lt;/option> &lt;option value="middle">center&lt;/option> &lt;/select> &lt;select id="select">&lt;/select> &lt;svg> &lt;path stroke="green" d="M 0 100.5 500 100.5 M 140 0 v 200"/> &lt;text id="text" x="140" y="100" fill="red" font-size="50">慕课网&lt;/text> &lt;rect id="rect" stroke="blue" fill="none">&lt;/rect> &lt;/svg> &lt;/body> &lt;/html> Example.js var values = "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge | text-top | text-bottom".split(' | '); values.forEach(function(value) { var opt = document.createElement('option'); opt.value = opt.textContent = value; select.appendChild(opt); }); select.addEventListener('input', function() { text.setAttribute('dominant-baseline', select.value); var box = text.getBBox(); rect.setAttribute('x', box.x); rect.setAttribute('y', box.y); rect.setAttribute('width', box.width); rect.setAttribute('height', box.height); }); ta.addEventListener('input', function() { text.setAttribute('text-anchor', ta.value); }); 案例2：自定义top，center，bottom对齐方式 https://jsbin.com/vezegib/edit?html,js,console 图形引用、裁切和蒙版&lt;use> xlink:href = "#id" &lt;clipPath> clip-path = "url(#clip-id)" &lt;mask> mask="url(#mask-id)" starsky&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>星空&lt;/title> &lt;/head> &lt;style> html, body { margin: 0; height: 100%; width: 100%; padding: 0; background: #001122; line-height: 0; font-size: 0; } &lt;/style> &lt;body> &lt;svg width="100%" height="100%" viewBox="-400 -300 800 600" preserveAspectRatio="xMidYMid slice"> &lt;defs> &lt;polygon id="star" points="0 -10 2 -2 10 0 2 2 0 10 -2 2 -10 0 -2 -2" fill="white">&lt;/polygon> &lt;/defs> &lt;g id="real" > &lt;g id="start-group"/> &lt;g id="moon-group"> &lt;mask id="moon-mask"> &lt;circle r="70" cx="-250" cy="-120" fill="white">&lt;/circle> &lt;circle r="70" cx="-220" cy="-200" fill="black">&lt;/circle> &lt;/mask> &lt;circle r="70" cx="-250" cy="-120" fill="white" mask="url(#moon-mask)">&lt;/circle> &lt;/g> &lt;g id="light-tower " transform="translate(250,0)"> &lt;defs> &lt;linearGradient id="tower" x1="0" y1="0" x2="1" y2="1"> &lt;stop offset="0" stop-color="#999">&lt;/stop> &lt;stop offset="1" stop-color="#333">&lt;/stop> &lt;/linearGradient> &lt;radialGradient id="light" cx="0.5" cy="0.5" r="0.5"> &lt;stop offset="0" stop-color="rgba(255,255,255,.8">&lt;/stop> &lt;stop offset="1" stop-color="rgba(255,255,255,0">&lt;/stop> &lt;/radialGradient> &lt;clipPath id="light-clip"> &lt;polygon points="0 0 -400 -15 -400 15"> &lt;animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0" to="360" dur="10s" repeatCount="indefinite"/> &lt;/polygon> &lt;circle cx="0" cy="0" r="2"/> &lt;/clipPath> &lt;/defs> &lt;polygon points="0 0 5 50 -5 50" fill="url(#tower)">&lt;/polygon> &lt;ellipse rx="300" ry="100" cx="0" cy="0" fill="url(#light)" clip-path="url(#light-clip)">&lt;/ellipse> &lt;/g> &lt;/g> &lt;g id="reflect" transform="translate(0,50)" mask="url(#fading)"> &lt;defs> &lt;linearGradient id="fade" x1="0" y1="0" x2="0" y2="1"> &lt;stop offset="0" stop-color="rgba(255,255,255,.3)"/> &lt;stop offset="0.5" stop-color="rgba(255,255,255,0)"/> &lt;/linearGradient> &lt;mask id="fading"> &lt;rect x="-400" y="0" width="800" height="300" fill="url(#fade)">&lt;/rect> &lt;/mask> &lt;/defs> &lt;!--use 是不能使用mask的--> &lt;use xlink:href="#real" transform="scale(1,-1) translate(0,-50)" >&lt;/use> &lt;/g> &lt;line x1="-400" y1="50" x2="400" y2="50" stroke="white"/> &lt;/svg> &lt;/body> &lt;script> var NS = 'http://www.w3.org/2000/svg' var XLINK_NS = 'http://www.w3.org/1999/xlink'; var page = document.querySelector('svg'); function use(origin) { var _use = document.createElementNS(NS, 'use'); _use.setAttributeNS(XLINK_NS, 'xlink:href', '#' + origin.id); return _use; } function random(min, max) { return min + (max - min) * Math.random(); } renderStar(); function renderStar() { var starRef = document.getElementById('star'); var starGroup = document.getElementById('start-group'); var starCount = 500; var star; while (starCount--) { star = use(starRef); star.setAttribute('opacity', random(0.1, 0.4)); star.setAttribute('transform', 'translate(' + random(-400, 400) + ',' + random(-300, 50) + ')' + 'scale(' + random(0.1, 0.8) + ')' ); starGroup.appendChild(star); } } &lt;/script> &lt;/html> SVG动画参考资料 Animating SVG Documents 超级强大的SVG SMIL animation动画详解 动画标签概述animate.svg &lt;?xml version="1.0"?> &lt;svg width="120" height="120" viewBox="0 0 120 120" version="1.1" xmlns="http://www.w3.org/2000/svg"> &lt;rect x="10" y="10" width="100" height="100"> &lt;animate attributeType="XML" attributeName="x" from="-100" to="120" dur="10s" repeatCount="indefinite"/> &lt;/rect> &lt;/svg> motion.xml &lt;?xml version="1.0"?> &lt;svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink"> &lt;!-- Draw the outline of the motion path in grey, along with 2 small circles at key points --> &lt;path d="M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110" stroke="lightgrey" stroke-width="2" fill="none" id="theMotionPath"/> &lt;circle cx="10" cy="110" r="3" fill="lightgrey" /> &lt;circle cx="110" cy="10" r="3" fill="lightgrey" /> &lt;!-- Red circle which will be moved along the motion path. --> &lt;circle cx="" cy="" r="5" fill="red"> &lt;!-- Define the motion path animation --> &lt;animateMotion dur="6s" repeatCount="indefinite"> &lt;mpath xlink:href="#theMotionPath"/> &lt;/animateMotion> &lt;/circle> &lt;/svg> &lt;mpath xlink:href=&quot;#theMotionPath&quot;/&gt; 引用上面的路径定义 path 可以在animation内部 sample2.html &lt;!DOCTYPE html> &lt;html lang="en"> &lt;style> html,body, svg{ margin: 0; padding: 0; width: 100%; height: 100%; } &lt;/style> &lt;head> &lt;meta charset="UTF-8"> &lt;title>SVG 动画&lt;/title> &lt;/head> &lt;body> &lt;svg viewBox="-400 -400 800 800" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink"> &lt;rect x="-25" y="-25" height="50" width="50" fill="rgba(0,255,255,0.6)"> &lt;animateMotion path="M 0 0L 100 100A 200 200 0 1 0 0 -100" dur="3s" repeatCount="indefinite" rotate="auto"> &lt;!--&lt;mpath xlink:href="#motion-path"/>--> &lt;/animateMotion> &lt;/rect> &lt;path id="motion-path" d="M 0 0L 100 100A 200 200 0 1 0 0 -100" stroke="gray" fill="none"/> &lt;/svg> &lt;/body> &lt;/html> animateTransform transform.svg &lt;svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg"> &lt;polygon points="60,30 90,90 30,90"> &lt;animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 60 70" to="360 60 70" dur="10s" repeatCount="indefinite"/> &lt;/polygon> &lt;/svg> 参数设置 Attribute Index 参数列表 实战案例动画顺序&lt;svg viewBox="-400 -400 800 800" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink"> &lt;rect x="-25" y="-25" height="80" width="80" fill="rgba(0,255,255,0.6)"> &lt;animate id="first" attributeName="x" attributeType="XML" from="100" to="500" dur="1s" fill="freeze" begin="0;second.end" /> &lt;animate id="second" attributeName="x" attributeType="XML" from="500" to="100" dur="1s" fill="freeze" begin="first.end" /> &lt;animate id="third" attributeName="fill" attributeType="XML" from="red" to="yellow" dur="6s" fill="freeze" /> 附录官方文档学习资料 走进SVG 经典案例metadata.svg &lt;!-- Learn about this code on MDN: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/metadata --> &lt;svg width="400" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> &lt;metadata> &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:connect="http://www.w3.org/1999/08/29-svg-connections-in-RDF#"> &lt;rdf:Description about="#CableA"> &lt;connect:ends rdf:resource="#socket1"/> &lt;connect:ends rdf:resource="#ComputerA"/> &lt;/rdf:Description> &lt;rdf:Description about="#CableB"> &lt;connect:ends rdf:resource="#socket2"/> &lt;connect:ends rdf:resource="#ComputerB"/> &lt;/rdf:Description> &lt;rdf:Description about="#CableN"> &lt;connect:ends rdf:resource="#socket5"/> &lt;connect:ends>Everything&lt;/connect:ends> &lt;/rdf:Description> &lt;rdf:Description about="#Hub"> &lt;connect:ends rdf:resource="#socket1"/> &lt;connect:ends rdf:resource="#socket2"/> &lt;connect:ends rdf:resource="#socket3"/> &lt;connect:ends rdf:resource="#socket4"/> &lt;connect:ends rdf:resource="#socket5"/> &lt;/rdf:Description> &lt;/rdf:RDF> &lt;/metadata> &lt;title>Network&lt;/title> &lt;desc>An example of a computer network based on a hub.&lt;/desc> &lt;style> svg { /* Default styles to be inherited */ fill: white; stroke: black; } text { fill: black; stroke: none; } path { fill: none; } &lt;/style> &lt;!-- Define symbols used in the SVG --> &lt;defs> &lt;!-- hubPlug symbol. Used by hub symbol --> &lt;symbol id="hubPlug"> &lt;desc>A 10BaseT/100baseTX socket&lt;/desc> &lt;path d="M0,10 h5 v-9 h12 v9 h5 v16 h-22 z"/> &lt;/symbol> &lt;!-- hub symbol --> &lt;symbol id="hub"> &lt;desc>A typical 10BaseT/100BaseTX network hub&lt;/desc> &lt;text x="0" y="15">Hub&lt;/text> &lt;g transform="translate(0 20)"> &lt;rect width="253" height="84"/> &lt;rect width="229" height="44" x="12" y="10"/> &lt;circle fill="red" cx="227" cy="71" r="7" /> &lt;!-- five groups each using the defined socket --> &lt;g id="sock1et" transform="translate(25 20)"> &lt;title>Socket 1&lt;/title> &lt;use xlink:href="#hubPlug"/> &lt;/g> &lt;g id="socket2" transform="translate(70 20)"> &lt;title>Socket 2&lt;/title> &lt;use xlink:href="#hubPlug"/> &lt;/g> &lt;g id="socket3" transform="translate(115 20)"> &lt;title>Socket 3&lt;/title> &lt;use xlink:href="#hubPlug"/> &lt;/g> &lt;g id="socket4" transform="translate(160 20)"> &lt;title>Socket 4&lt;/title> &lt;use xlink:href="#hubPlug"/> &lt;/g> &lt;g id="socket5" transform="translate(205 20)"> &lt;title>Socket 5&lt;/title> &lt;use xlink:href="#hubPlug"/> &lt;/g> &lt;/g> &lt;/symbol> &lt;!-- computer symbol --> &lt;symbol id="computer"> &lt;desc>A common desktop PC&lt;/desc> &lt;g id="monitorStand" transform="translate(40 121)"> &lt;title>Monitor stand&lt;/title> &lt;desc>One of those cool swivelling monitor stands that sit under the monitor&lt;/desc> &lt;path d="m0,0 S 10 10 40 12"/> &lt;path d="m80,0 S 70 10 40 12"/> &lt;path d="m0,20 L 10 10 S 40 12 70 10 L 80 20z"/> &lt;/g> &lt;g id="monitor"> &lt;title>Monitor&lt;/title> &lt;desc>A very fancy monitor&lt;/desc> &lt;rect width="160" height="120"/> &lt;rect fill="lightgrey" width="138" height="95" x="11" y="12"/> &lt;/g> &lt;g id="processor" transform="translate(0 142)"> &lt;title>The computer&lt;/title> &lt;desc>A desktop computer - broad flat box style&lt;/desc> &lt;rect width="160" height="60"/> &lt;g id="discDrive" transform="translate(70 8)"> &lt;title>disc drive&lt;/title> &lt;desc>A built-in disc drive&lt;/desc> &lt;rect width="58" height="3" x="12" y="8"/> &lt;rect width="8" height="2" x="12" y="15"/> &lt;/g> &lt;circle cx="135" cy="40" r="5"/> &lt;/g> &lt;/symbol> &lt;/defs> &lt;text x="0" y="15">Network&lt;/text> &lt;!-- Use the hub symbol. --> &lt;g id="Hub" transform="translate(80 45)"> &lt;title>Hub&lt;/title> &lt;use xlink:href="#hub" transform="scale(0.75)"/> &lt;/g> &lt;!-- Use the computer symbol. --> &lt;g id="ComputerA" transform="translate(20 170)"> &lt;title>Computer A&lt;/title> &lt;use xlink:href="#computer" transform="scale(0.5)"/> &lt;/g> &lt;!-- Use the same computer symbol. --> &lt;g id="ComputerB" transform="translate(300 170)"> &lt;title>Computer B&lt;/title> &lt;use xlink:href="#computer" transform="scale(0.5)"/> &lt;/g> &lt;!-- Draw Cable A. --> &lt;g id="CableA" transform="translate(107 88)"> &lt;title>Cable A&lt;/title> &lt;desc>10BaseT twisted pair cable&lt;/desc> &lt;path d="M0,0c100,140 50,140 -8,160"/> &lt;/g> &lt;!-- Draw Cable B. --> &lt;g id="CableB" transform="translate(142 88)"> &lt;title>Cable B&lt;/title> &lt;desc>10BaseT twisted pair cable&lt;/desc> &lt;path d="M0,0c100,180 110,160 159,160"/> &lt;/g> &lt;!-- Draw Cable N. --> &lt;g id="CableN" transform="translate(242 88)"> &lt;title>Cable N&lt;/title> &lt;desc>10BaseT twisted pair cable&lt;/desc> &lt;path d="M0,0c0,-70 20,-50 60,-50"/> &lt;/g> &lt;/svg> 正玄字体&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>正玄字体&lt;/title> &lt;/head> &lt;body> &lt;svg xmlns="http://www.w3.org/2000/svg" x="0" y="0" width="100%" height="100%"> &lt;defs> &lt;pattern id="grid" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"> &lt;path stroke="#f0f0f0" fill="none" d="M0,0H20V20">&lt;/path> &lt;/pattern> &lt;/defs> &lt;rect width="4200" height="2000" fill="url(#grid)">&lt;/rect> &lt;text id="sintext" x="100" y="160" style="font-size: 14px; font-family: 'Arial'; ">ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/text> &lt;path d="M100,0V200M0,100H200" stroke="red" transform="translate(0,60)"/> &lt;text id="sintext2" x="100" y="360" style="font-size: 14px; font-family: 'Arial'; ">&lt;/text> &lt;/svg> &lt;style> body { width: 100vm; height: 100vm; } svg { overflow: visible; } &lt;/style> &lt;script> var n = 26; var x = []; var y = null; var i = n; var s = 100; var w = 0.02; var t = 0; var text = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; var NS = 'http://www.w3.org/2000/svg'; while (i--) { x.push(10); var tspan = document.createElementNS(NS,'tspan'); tspan.textContent = text[n -i -1]; sintext2.appendChild(tspan); var h = Math.round(360 / 26 * i); tspan.setAttribute('fill','hsl(' + h + ',100%,80%') } function arrange(t) { y = []; var ly = 0, cy; for (i = 0; i &lt; n; i++) { cy = -s * Math.sin(w * i * 20 + t); y.push(cy - ly); ly = cy; } console.table(y); } function render() { sintext.setAttribute('dx', x.join(' ')); sintext.setAttribute('dy', y.join(' ')); sintext2.setAttribute('dx', x.join(' ')); sintext2.setAttribute('dy', y.join(' ')); } function frame() { t += 0.02; arrange(t); render(); requestAnimationFrame(frame) } frame() &lt;/script> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记]]></title>
    <url>%2F2019%2F07%2F22%2F2019-7-22-webpack%2F</url>
    <content type="text"><![CDATA[webpack基础webpack简介 代码转换 文件优化 代码分割 模块合并 debug模式自动刷新 代码验证 自动发布 webpack 基础安装到本地 yarn init -y #-D 表示开发依赖 yarn add webpack webpack-cli -D npx webpack]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue笔记]]></title>
    <url>%2F2019%2F07%2F22%2F2019-7-22-vue%2F</url>
    <content type="text"><![CDATA[Javascript JavaScript 教程 JavaScript 完全手册（2018版） 【重点】 33-js-concepts 语言学习 初探Promise Vue学习资料博文 手摸手，带你用vue撸后台 系列一（基础篇） vue .sync修饰符的使用 vuex入门，详细的讲解 vuex里mapState,mapGetters使用详解 import { mapState, mapGetters, mapActions, mapMutations } from 'vuex' computed: { ...mapState({ viewsCount: 'views' }), ...mapGetters({ todosALise: 'getToDo' // getToDo 不是字符串，对应的是getter里面的一个方法名字 然后将这个方法名字重新取一个别名 todosALise }) }, methods: { ...mapMutations({ totalAlise: 'clickTotal' // clickTotal 是mutation 里的方法，totalAlise是重新定义的一个别名方法，本组件直接调用这个方法 }), ...mapActions({ blogAdd: 'blogAdd' // 第一个blogAdd是定义的一个函数别名称，挂载在到this(vue)实例上，后面一个blogAdd 才是actions里面函数方法名称 }) } 官方教程 vue 官方教程 vue 入门教程 style-guide webpack webpack-chain Vue 开源库 examples 基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用 vue-multiselect nprogress 官方开源库 vue-router API指令inject注入 // 父级组件提供 'foo' var Provider = { provide: { foo: 'bar' }, // ... } // 子组件注入 'foo' var Child = { inject: ['foo'], created () { console.log(this.foo) // => "bar" } // ... } 优化 VUE 9个性能优化秘密？（vue-9-perf-secrets） 工具 类似RxJava的工具库 https://lodash.com/docs/4.17.11 Sortable 拖拽排序库 iconfont 阿里巴巴矢量图库使用 动画工具 animate.css]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程并发学习笔记]]></title>
    <url>%2F2019%2F06%2F13%2F2019-4-13-Java-concurrent%2F</url>
    <content type="text"><![CDATA[阶段一：多线基础知识入门思考为什么要学习并发 发挥CPU多处理器的强大能力 更符合现实生活中的多事件同时处理 简化异步事件的处理 更加灵敏的响应用户界面 并发的缺点 安全性 活跃性（饥饿）问题 性能问题（并发不一定快） 线程切换有消耗ccc 学习并发的四个阶段 熟练掌握API，能够完成并发编程 熟读API源码，掌握其原理 理解Java虚拟机的内存模型 【待看】 操作系统对并发的支持 【待看】 进程与线程基础知识 进程是资源分配的基本单位 进程包含多个线程，线程共享进程 线程是CPU调度的基本单位 线程状态 线程中断及中断处理多线程-interrupt()，isInterrupted()，interrupted() setDaemon(true); //主进程结束，子线程while（true）也结束 优雅的中断线程 处理不中断线程，在中断中触发其异常 @Override public void interrupt() { try { socket.close(); } catch (IOException e) { } finally { super.interrupt(); } } 用守护进程, Daemon Thread： 其优先级特别低(低到甚至可以被JVM自动终止)，通常这类线程用于在空闲时做一些资源清理类的工作，比如GC线程 public void execute(Runnable task) { executeThread = new Thread("ThreadService") { @Override public void run() { Thread runner = new Thread(task, "Daemon-thread"); runner.setDaemon(true); runner.start(); try { runner.join(); finished = true; } catch (InterruptedException e) { //e.printStackTrace(); } } }; executeThread.start(); } 线程池中的应用 public static ThreadFactory threadFactory(final String name, final boolean daemon) { return new ThreadFactory() { @Override public Thread newThread(Runnable runnable) { Thread result = new Thread(runnable, name); result.setDaemon(daemon); return result; } }; } 堆和栈 栈java.util.Stak是线程的私有Last In First Out顺序的数据结构，堆所有线程都能访问到 栈内存用来存储局部变量和方法调用 ,堆内存用来存储Java中的对象。 无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 Java中的堆和栈的区别 查看堆和栈的默认值 //堆 其中InitialHeapSize为最开始的堆的大小，MaxHeapSize为堆的最大值。 java -XX:+PrintFlagsFinal -version | grep HeapSize //栈 java -XX:+PrintFlagsFinal -version | grep ThreadStackSize 线程之间的通信Wait，notify Wait解锁 public synchronized int get () { wait(); // wait() synchronized 解锁，多线程能直接访问到wait return 0; } notify. , 会加锁拿到锁，但是会等到synchronize的锁释放成功后才能加锁 notify: 随机叫醒一个处于wait状态的线程 notifyAll: 叫醒所有的处于wait线程，争夺到时间片的线程只有一个 public synchronized void set () { signal = 1; notifyAll(); // notify方法会随机叫醒一个处于wait状态的线程 // notifyAll叫醒所有的处于wait线程，争夺到时间片的线程只有一个 } Message QueueCondition//初始化 Lock lock = new ReentrantLock(); Condition a = lock.newCondition(); Condition b = lock.newCondition(); //使用 public void a() { lock.lock(); while(signal != 0 ) { a.await(); } System.out.println("a"); signal ++; b.signal(); lock.unlock(); } ThreadLocal原理和使用 案例：javaBase/ThreadLocalDemo原理：把初始值放到线程中去，并且每个线程单独一份互不影响 使用场景 实现单个线程单例以及单个线程上下文信息存储，比如交易id等 实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例 承载一些线程相关的数据，避免在方法中来回传递参数 间通信之join加赛 JavaBase/JoinDemo.java CyclicBarrier 开会场景类似，如果出现一个人员没有await或中途异常，导致其他线程一直在等待 Exchanger tb7.Demo Callable、Future和FutureTask tb8.Demo Callable、Future和FutureTask Future设计模式的实现 tb9 com.sample.design_pattern.chapter04_future_design Callable 和Runnable的区别 Runnable的run方法是线程调用的，在run方法是异步执行的 Callable的call方法，不是异步执行的，是由Future的run方法 调用的 Future源码解析 public void run() { if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable&lt;V> c = callable; if (c != null &amp;&amp; state == NEW) { V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s >= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } 多种创建线程的方式案 继承Thread类 实现Runnable接口 匿名内部类 带返回值的线程，实现 implements Callable&lt;T&gt; 有返回值的 定时器，java常用的几种定时器@Scheduled注解、quartz、new Timer().schedule、使用线程控制 【待深入】 线程池的实现 【待深入】 Lambda表达式实现 Spring是需要多线程 RxJava 线程设置-Xss10M 设置 tackssize new thread(stacksize) VM调优总结 -Xms -Xmx -Xmn -Xss Thread.currentThread().setPriority(priority);优先级设置 不要把线程的优先级与运行结果的顺序作为衡量的标准，优先级较高的线程并不一定每一次都先执行完run()方法中的任务，也就是说，线程的优先级与打印顺序无关，不要将这两者的关系相关联，它们的关系具有不确定性和随机性。 关键字 join 兄弟你走，我垫后 ThreadGroup 线程组 给线程指定ThreadGroup ThreadGroup threadGroup = new ThreadGroup("TG1"); Thread t1 = new Thread(threadGroup, "t1") main函数默认创建在main线程组中 中断的处理逻辑体会 不支持线程interrupt的 可以在interrupt中触发停止条件，如读取文件时在interrupt中关闭读取文件的流触发线程内的异常 import java.io.IOException; import java.io.InputStream; import java.net.Socket; public class Test32 extends Thread { public static final int BUF_SIZE = 512; Socket socket; InputStream in; public Test32(Socket socket) throws IOException { this.socket = socket; this.in = socket.getInputStream(); } @Override public void interrupt() { try { //中断是关闭socket是线程产生错误 socket.close(); } catch (IOException e) { } finally { super.interrupt(); } } @Override public void run() { try { byte[] buf = new byte[BUF_SIZE]; while (true) { int count = in.read(buf); if (count &lt; 0) { break; } else if (count > 0) { } } } catch (IOException e) { } } } 向上抛异常，自己不处理 自己处理完，在抛异常上面在处理 线程异常问题及处理 知识点： 银行服务会预留应急服务器，定期重启服务器，重置资源保持服务器的稳定性 1. 钩子函数，捕获异常public class ExitCapture { public static void main(String[] args) { Runtime.getRuntime().addShutdownHook(new Thread(()->{ System.out.println("The application will be exit."); notifyAndRelease(); })); int i = 0 ; while (true) { try { Thread.sleep(1_000L); System.out.println("I am working ..."); } catch (InterruptedException e) { //ignore } i++; // simulate a exception if (i>20) throw new RuntimeException("error"); } } // 1. try to capture the simulate exception and handler that // 2. even this Thread kill by some reason can capture // 3. but kill -9 pid (force kill ) can't not capture private static void notifyAndRelease() { System.out.println("notify to the admin(the monitor.) by email or mq or some other way"); try { Thread.sleep(1_000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("Will release resource(socket,file,connection.)"); try{ Thread.sleep(1_000); }catch (Exception e){ //ignore } System.out.println("Relase and notify Done. "); } } 2. 获取线程运行期间的异常 threadRun.setUncaughtExceptionHandler((threadError, e) -> { System.out.println(e); System.out.println(threadError); }); ThreadFactory设置 ExecutorService exec = Executors.newCachedThreadPool(new ThreadFactory(){ @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setUncaughtExceptionHandler(new MyUnchecckedExceptionhandler()); return thread; } }); exec.execute(new ExceptionThread()); 3. 追踪程序中调用的逻辑顺序 Arrays.asList(Thread.currentThread().getStackTrace()).stream() .filter(e -> !e.isNativeMethod()) .forEach(e -> Optional.of( e.getClassName() + ":" + e.getMethodName() + ":" + e.getLineNumber()) .ifPresent(System.out::println) ); 4. 线程组ThreadGroup//1.创建线程组 ThreadGroup threadGroup = // 这是匿名类写法 new ThreadGroup("group") { // 继承ThreadGroup并重新定义以下方法 // 在线程成员抛出unchecked exception 会执行此方法 @Override public void uncaughtException(Thread t, Throwable e) { //4.处理捕获的线程异常 } }; //2.创建Thread Thread thread = new Thread(threadGroup, new Runnable() { @Override public void run() { System.out.println(1 / 0); } }, "my_thread"); //3.启动线程 thread.start(); 5. 默认的线程异常捕获器// 设置默认的线程异常捕获处理器 Thread.setDefaultUncaughtExceptionHandler(new MyUnchecckedExceptionhandler()); 当线程出现异常时，如果我们没有指定线程的异常处理器，而且线程组也没有设置，那么就会使用默认的线程异常处理器 6. FetureTask来捕获异常6.1 基本用法//1.创建FeatureTask FutureTask&lt;Integer> futureTask = new FutureTask&lt;>(new Callable&lt;Integer>() { @Override public Integer call() throws Exception { return 1/0; } }); //2.创建Thread Thread thread = new Thread(futureTask); //3.启动线程 thread.start(); try { Integer result = futureTask.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { //4.处理捕获的线程异常 } 6.2 线程池使用//1.创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); //2.创建Callable，有返回值的，你也可以创建一个线程实现Callable接口。 // 如果你不需要返回值，这里也可以创建一个Thread即可，在第3步时submit这个thread。 Callable&lt;Integer> callable = new Callable&lt;Integer>() { @Override public Integer call() throws Exception { return 1/0; } }; //3.提交待执行的线程 Future&lt;Integer> future = executorService.submit(callable); try { Integer result = future.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { //4.处理捕获的线程异常 } 7. 重写ThreadPoolExecutor的afterExecute//1.创建线程池 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;>()) { @Override protected void afterExecute(Runnable r, Throwable t) { if (r instanceof Thread) { if (t != null) { //处理捕获的异常 } } else if (r instanceof FutureTask) { FutureTask futureTask = (FutureTask) r; try { futureTask.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { //处理捕获的异常 } } } }; Thread t1 = new Thread(() -> { int c = 1 / 0; }); threadPoolExecutor.execute(t1); Callable&lt;Integer> callable = () -> 2 / 0; threadPoolExecutor.submit(callable); 多线程带来的风险活跃性问题1. 死锁2. 饥饿 高优先级吞噬所有低优先级的CPU时间片 线程被永久堵塞(block)在一个等待进入同步块的状态 wait() 等待的线程永远不被唤醒 如何处饥饿与公平 设置合理的优先级； 设置synchronized 3. 活锁 由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态 性能问题线程安全性问题 出现线程安全性问题的条件： •多线程环境下 •多个线程共享一个资源 对资源进行非原子性操作（同时读OK，同时 读写有问题） synchronized 的原理与使用 内置锁 /** * 普通方法上,内置锁就是当前类的实例 */ public synchronized int getNext() { return value ++; } 互斥锁 三种修饰方式 普通方法，内置锁当前类的实例 静态方法，内置锁是当前的Class字节码对象 代码块，内置锁指定的类 线程锁锁的存放 任何对象都可以作为锁，锁信息存放在对象的头中 Mark World 锁的分类 偏向锁 存在原因： 每次获取锁和释放锁会浪费资源 很多情况下，竞争锁不是有多个线程，而是一个线程在使用 处理方式： 如果是同一个线程，判断是否是偏向锁，是否是上一个线程id，直接访问；更多条件如下： •线程id •Epoch •对象的分代年龄信息 •是否是偏向锁 •锁标志位 其他线程访问会需要重新获取锁； 轻量锁 重量锁（synchronize） 理解自旋锁，死锁与重入锁 锁的重入 synchronize 方法访问 内部访问synchronize方法 自旋锁，没有拿到锁的线程等待或者在等待线程的状态达到某个条件的时候 while(Thread.activeCount() != 1) { // 自旋 } System.out.println("所有的线程执行完毕了..."); 死锁 // a b 并行执行，a 方法获取obj1锁， b方法获取obj2锁，第二步相互制约形成死锁 public void a () { synchronized (obj1) { synchronized (obj2) { System.out.println("a"); } } } public void b () { synchronized (obj2) { synchronized (obj1) { System.out.println("b"); } } } 指令重排序(happen-before) 指令重排序，可以分为编译器重排序和处理器重排序 单例 饿汉式 //不存在线程安全性问题 public class Singleton { // 私有化构造方法 private Singleton () {} private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 懒汉式，用的时候才加载 public class Singleton2 { private Singleton2() {} // volatile 防止虚拟机为了提高性能在不改变执行结果的前提下指令重排序（原来执行在后面的可能放到前面运行） private static volatile Singleton2 instance; /** * 双重检查加锁 * @return */ public static Singleton2 getInstance () { // 自旋 while(true) if(instance == null) { synchronized (Singleton2.class) { if(instance == null) { instance = new Singleton2(); // 指令重排序 // new Singleton2() 汇编中不是一个指令完成，大致过程如下 // 申请一块内存空间 // 1 在1的时候instance就不为空了 // 在这块空间里实例化对象 // 2 // instance的引用指向这块空间地址 // 3 } } } return instance; } } Volatile原理与使用 Volatile称之为轻量级锁，被volatile修饰的变量，在线程之间是可见的。 可见：一个线程修改了这个变量的值，在另外一个线程中能够读到这个修改后的值。 Synchronized除了线程之间互斥意外，还有一个非常大的作用，就是保证可见性 volatile 只保证了线程的之间的可见性，不能保证线程的原子性 volatile内存语义 线程对变量进行修改之后，要立刻回写到主内存。 线程对变量读取的时候，要从主内存中读，而不是缓存。 参考： Java多线程（一）之volatile深入分析 正确使用 Volatile 变量 【重点】 EverNote有笔记 JDK5提供的原子类的操作以及实现原理jar： rt.jar java.util.concurrent.atomic 核心代码逻辑 public final int getAndUpdate(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); // 获取当前值 next = updateFunction.applyAsInt(prev); //获取共享资源值 } while (!compareAndSet(prev, next)); //如果共享资源没有被改变更新，继续get() return prev; } 参考 １．［非阻塞算法简介］（https://www.ibm.com/developerworks/cn/java/j-jtp04186/） Lock接口认识与使用synchronized 和Lock各自优势 Lock 显示地获取和释放锁，繁琐能让代码更灵活 使用Lock可以方便的实现公平性 非阻塞的获取锁 能被中断的获取锁 超时获取锁 AbstractQueuedSynchronizer(AQS)详解ReentrantLock.java //简单案例 MyLock2.java 公平锁 公平是针对获取而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序。 实质是先进先出 FirLock FairSync 顺序执行，高并发性能损耗 NonFairSync 每个线程获取锁的几率都是相同，减少JVM调度时间 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; } return false; } } 读写锁 ReentrantReadWriteLock 多个读锁不互斥，读锁与写锁互斥，多个写锁互斥 protected final boolean tryReleaseShared(int unused) { Thread current = Thread.currentThread(); if (firstReader == current) { // assert firstReaderHoldCount > 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) { readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); } --rh.count; } for (;;) { int c = getState(); int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. return nextc == 0; } } 锁降级 •锁降级是指写锁降级为读锁。 •在写锁没有释放的时候，获取到读锁，再释放写锁 private volatile boolean isUpdate; public void readWrite() { r.lock(); // 为了保证isUpdate能够拿到最新的值 if (isUpdate) { r.unlock(); w.lock(); map.put("xxx", "xxx"); r.lock(); //锁降级 利用读写锁互斥，在写锁竞争写之前先读锁 w.unlock(); } Object obj = map.get("xxx"); System.out.println(obj); r.unlock(); } 锁升级 •把读锁升级为写锁 •在读锁没有释放的时候，获取到写锁，再释放读锁 线程安全性问题简单总结 出现线程安全性问题的条件 •在多线程的环境下 •必须有共享资源 •对共享资源进行非原子性操作 解决线程安全性问题的途径 •synchronized （偏向锁，轻量级锁，重量级锁） •volatile •JDK提供的原子类 使用Lock（共享锁，排它锁） 认识的“*锁” •偏向锁 •轻量级锁 •重量级锁 •重入锁 •自旋锁 •共享锁 •独占锁 •排他锁 •读写锁 •公平锁 •非公平锁 •死锁 •活锁 同步容器与并发容器 同步容器，性能比较差 Vector（线程安全） ArrayList（线程不安全）==&gt; 转化成线程安全Collections.synchronizedCollection(list) Hashtable ==&gt; HashMap 并发容器 CopyOnWriteArrayList ConcurrentHashMap 分区加锁 来实现 CopyOnWriteArrayList 原理和使用 原理：读不加锁， 写new一个List用于写，写完成List头指针指向新的List 使用： 每次写都copy一份，故写数据量大的时候对内存的消耗是非常大的，读操作比较多使用CopyOnWriteArrayList ，如果读很少写操作很多使用同步容器处理这件事性能会更好一点 非阻塞队列-并发容器ConcurrentLinkedQueu原理与使用 并发安全的FIFO链表的队列提示: size() 不是线程安全，导致调用的时候数量不准确容易变 阻塞队列BlockingQueue ArrayBlockingQueue 1)ArrayBlockingQueue:规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的. 2)LinkedBlockingQueue:大小不定的BlockingQueue,若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制,若不带大小参数,所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的 有届链表队列 3)PriorityBlockingQueue:类似于LinkedBlockQueue,但其所含对象的排序不是FIFO,而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序. 无届队列 4)SynchronousQueue:特殊的BlockingQueue,对其的操作必须是放和取交替完成的. 并发容器ConcurrentHashMap线程池线程池概述 什么是线程池 为什么使用线程池 线程池的优势 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。 Executors提供四种线程池 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 创建一个线程池并提交线程任务线程池源码解析参数认识 corePoolSize : 线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。 runnableTaskQueue：任务对列，用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级得无限阻塞队列。 maximumPoolSize：线程池最大大小，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。 ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。 RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。 keepAliveTime ：线程活动保持时间，线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。 TimeUnit：线程活动保持时间的单位，可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。 类中其他属性 // 线程池的控制状态:用来表示线程池的运行状态（整型的高3位）和运行的worker数量（低29位） private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 29位的偏移量 private static final int COUNT_BITS = Integer.SIZE - 3; // 最大容量（2^29 - 1） private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // runState is stored in the high-order bits // 线程运行状态，总共有5个状态，需要3位来表示（所以偏移量的29 = 32 - 3） /** * RUNNING : 接受新任务并且处理已经进入阻塞队列的任务 * SHUTDOWN ： 不接受新任务，但是处理已经进入阻塞队列的任务 * STOP : 不接受新任务，不处理已经进入阻塞队列的任务并且中断正在运行的任务 * TIDYING : 所有的任务都已经终止，workerCount为0， 线程转化为TIDYING状态并且调用terminated钩子函数 * TERMINATED: terminated钩子函数已经运行完成 **/ private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 阻塞队列 private final BlockingQueue&lt;Runnable> workQueue; // 可重入锁 private final ReentrantLock mainLock = new ReentrantLock(); // 存放工作线程集合 private final HashSet&lt;Worker> workers = new HashSet&lt;Worker>(); // 终止条件 private final Condition termination = mainLock.newCondition(); // 最大线程池容量 private int largestPoolSize; // 已完成任务数量 private long completedTaskCount; // 线程工厂 private volatile ThreadFactory threadFactory; // 拒绝执行处理器 private volatile RejectedExecutionHandler handler; // 线程等待运行时间 private volatile long keepAliveTime; // 是否运行核心线程超时 private volatile boolean allowCoreThreadTimeOut; // 核心池的大小 private volatile int corePoolSize; // 最大线程池大小 private volatile int maximumPoolSize; // 默认拒绝执行处理器 private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || // 核心大小不能小于0 maximumPoolSize &lt;= 0 || // 线程池的初始最大容量不能小于0 maximumPoolSize &lt; corePoolSize || // 初始最大容量不能小于核心大小 keepAliveTime &lt; 0) // keepAliveTime不能小于0 throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 初始化相应的域 this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 提交任务/* * 进行下面三步 * * 1. 如果运行的线程小于corePoolSize,则尝试使用用户定义的Runnalbe对象创建一个新的线程 * 调用addWorker函数会原子性的检查runState和workCount，通过返回false来防止在不应 * 该添加线程时添加了线程 * 2. 如果一个任务能够成功入队列，在添加一个线城时仍需要进行双重检查（因为在前一次检查后 * 该线程死亡了），或者当进入到此方法时，线程池已经shutdown了，所以需要再次检查状态， * 若有必要，当停止时还需要回滚入队列操作，或者当线程池没有线程时需要创建一个新线程 * 3. 如果无法入队列，那么需要增加一个新线程，如果此操作失败，那么就意味着线程池已经shut * down或者已经饱和了，所以拒绝任务 */ public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 获取线程池控制状态 int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) { // worker数量小于corePoolSize if (addWorker(command, true)) // 添加worker // 成功则返回 return; // 不成功则再次获取线程池控制状态 c = ctl.get(); } // 线程池处于RUNNING状态，将用户自定义的Runnable对象添加进workQueue队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) { // 再次检查，获取线程池控制状态 int recheck = ctl.get(); // 线程池不处于RUNNING状态，将自定义任务从workQueue队列中移除 if (! isRunning(recheck) &amp;&amp; remove(command)) // 拒绝执行命令 reject(command); else if (workerCountOf(recheck) == 0) // worker数量等于0 // 添加worker addWorker(null, false); } else if (!addWorker(command, false)) // 添加worker失败 // 拒绝执行命令 reject(command); } addWorker 原子性的增加workerCount。 将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中。 启动worker对应的线程，并启动该线程，运行worker的run方法。 回滚worker的创建动作，即将worker从workers集合中删除，并原子性的减少workerCount。 private boolean addWorker(Runnable firstTask, boolean core) { retry: for (;;) { // 外层无限循环 // 获取线程池控制状态 int c = ctl.get(); // 获取状态 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs >= SHUTDOWN &amp;&amp; // 状态大于等于SHUTDOWN，初始的ctl为RUNNING，小于SHUTDOWN ! (rs == SHUTDOWN &amp;&amp; // 状态为SHUTDOWN firstTask == null &amp;&amp; // 第一个任务为null ! workQueue.isEmpty())) // worker队列不为空 // 返回 return false; for (;;) { // worker数量 int wc = workerCountOf(c); if (wc >= CAPACITY || // worker数量大于等于最大容量 wc >= (core ? corePoolSize : maximumPoolSize)) // worker数量大于等于核心线程池大小或者最大线程池大小 return false; if (compareAndIncrementWorkerCount(c)) // 比较并增加worker的数量 // 跳出外层循环 break retry; // 获取线程池控制状态 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) // 此次的状态与上次获取的状态不相同 // 跳过剩余部分，继续循环 continue retry; // else CAS failed due to workerCount change; retry inner loop } } // worker开始标识 boolean workerStarted = false; // worker被添加标识 boolean workerAdded = false; // Worker w = null; try { // 初始化worker w = new Worker(firstTask); // 获取worker对应的线程 final Thread t = w.thread; if (t != null) { // 线程不为null // 线程池锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 线程池的运行状态 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || // 小于SHUTDOWN (rs == SHUTDOWN &amp;&amp; firstTask == null)) { // 等于SHUTDOWN并且firstTask为null if (t.isAlive()) // precheck that t is startable // 线程刚添加进来，还未启动就存活 // 抛出线程状态异常 throw new IllegalThreadStateException(); // 将worker添加到worker集合 workers.add(w); // 获取worker集合的大小 int s = workers.size(); if (s > largestPoolSize) // 队列大小大于largestPoolSize // 重新设置largestPoolSize largestPoolSize = s; // 设置worker已被添加标识 workerAdded = true; } } finally { // 释放锁 mainLock.unlock(); } if (workerAdded) { // worker被添加 // 开始执行worker的run方法 t.start(); // 设置worker已开始标识 workerStarted = true; } } } finally { if (! workerStarted) // worker没有开始 // 添加worker失败 addWorkerFailed(w); } return workerStarted; } 执行任务runWorker函数中会实际执行给定任务（即调用用户重写的run方法），并且当给定任务完成后，会继续从阻塞队列中取任务，直到阻塞队列为空（即任务全部完成）。在执行给定任务时，会调用钩子函数，利用钩子函数可以完成用户自定义的一些逻辑。在runWorker中会调用到getTask函数和processWorkerExit钩子函数 final void runWorker(Worker w) { // 获取当前线程 Thread wt = Thread.currentThread(); // 获取w的firstTask Runnable task = w.firstTask; // 设置w的firstTask为null w.firstTask = null; // 释放锁（设置state为0，允许中断） w.unlock(); // allow interrupts boolean completedAbruptly = true; try { while (task != null || (task = getTask()) != null) { // 任务不为null或者阻塞队列还存在任务 // 获取锁 w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || // 线程池的运行状态至少应该高于STOP (Thread.interrupted() &amp;&amp; // 线程被中断 runStateAtLeast(ctl.get(), STOP))) &amp;&amp; // 再次检查，线程池的运行状态至少应该高于STOP !wt.isInterrupted()) // wt线程（当前线程）没有被中断 wt.interrupt(); // 中断wt线程（当前线程） try { // 在执行之前调用钩子函数 beforeExecute(wt, task); Throwable thrown = null; try { // 运行给定的任务 task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { // 执行完后调用钩子函数 afterExecute(task, thrown); } } finally { task = null; // 增加给worker完成的任务数量 w.completedTasks++; // 释放锁 w.unlock(); } } completedAbruptly = false; } finally { // 处理完成后，调用钩子函数 processWorkerExit(w, completedAbruptly); } } 此函数用于从workerQueue阻塞队列中获取Runnable对象，由于是阻塞队列，所以支持有限时间等待（poll）和无限时间等待（take）。在该函数中还会响应shutDown和、shutDownNow函数的操作，若检测到线程池处于SHUTDOWN或STOP状态，则会返回null，而不再返回阻塞队列中的Runnalbe对象。 private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { // 无限循环，确保操作成功 // 获取线程池控制状态 int c = ctl.get(); // 运行的状态 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs >= SHUTDOWN &amp;&amp; (rs >= STOP || workQueue.isEmpty())) { // 大于等于SHUTDOWN（表示调用了shutDown）并且（大于等于STOP（调用了shutDownNow）或者worker阻塞队列为空） // 减少worker的数量 decrementWorkerCount(); // 返回null，不执行任务 return null; } // 获取worker数量 int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc > corePoolSize; // 是否允许coreThread超时或者workerCount大于核心大小 if ((wc > maximumPoolSize || (timed &amp;&amp; timedOut)) // worker数量大于maximumPoolSize &amp;&amp; (wc > 1 || workQueue.isEmpty())) { // workerCount大于1或者worker阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个wc） if (compareAndDecrementWorkerCount(c)) // 比较并减少workerCount // 返回null，不执行任务，该worker会退出 return null; // 跳过剩余部分，继续循环 continue; } try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : // 等待指定时间 workQueue.take(); // 一直等待，直到有元素 if (r != null) return r; // 等待指定时间后，没有获取元素，则超时 timedOut = true; } catch (InterruptedException retry) { // 抛出了被中断异常，重试，没有超时 timedOut = false; } } } processWorkerExit函数是在worker退出时调用到的钩子函数，而引起worker退出的主要因素如下 阻塞队列已经为空，即没有任务可以运行了。 调用了shutDown或shutDownNow函数 此函数会根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。 private void processWorkerExit(Worker w, boolean completedAbruptly) { if (completedAbruptly) // 如果被中断，则需要减少workCount // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); // 获取可重入锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try { // 将worker完成的任务添加到总的完成任务中 completedTaskCount += w.completedTasks; // 从workers集合中移除该worker workers.remove(w); } finally { // 释放锁 mainLock.unlock(); } // 尝试终止 tryTerminate(); // 获取线程池控制状态 int c = ctl.get(); if (runStateLessThan(c, STOP)) { // 小于STOP的运行状态 if (!completedAbruptly) { int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) // 允许核心超时并且workQueue阻塞队列不为空 min = 1; if (workerCountOf(c) >= min) // workerCount大于等于min // 直接返回 return; // replacement not needed } // 添加worker addWorker(null, false); } } 关闭线程池 public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 检查shutdown权限 checkShutdownAccess(); // 设置线程池控制状态为SHUTDOWN advanceRunState(SHUTDOWN); // 中断空闲worker interruptIdleWorkers(); // 调用shutdown钩子函数 onShutdown(); // hook for ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } // 尝试终止 tryTerminate(); } final void tryTerminate() { for (;;) { // 无限循环，确保操作成功 // 获取线程池控制状态 int c = ctl.get(); if (isRunning(c) || // 线程池的运行状态为RUNNING runStateAtLeast(c, TIDYING) || // 线程池的运行状态最小要大于TIDYING (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) // 线程池的运行状态为SHUTDOWN并且workQueue队列不为null // 不能终止，直接返回 return; if (workerCountOf(c) != 0) { // 线程池正在运行的worker数量不为0 // Eligible to terminate // 仅仅中断一个空闲的worker interruptIdleWorkers(ONLY_ONE); return; } // 获取线程池的锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try { if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) { // 比较并设置线程池控制状态为TIDYING try { // 终止，钩子函数 terminated(); } finally { // 设置线程池控制状态为TERMINATED ctl.set(ctlOf(TERMINATED, 0)); // 释放在termination条件上等待的所有线程 termination.signalAll(); } return; } } finally { // 释放锁 mainLock.unlock(); } // else retry on failed CAS } } private void interruptIdleWorkers(boolean onlyOne) { // 线程池的锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try { for (Worker w : workers) { // 遍历workers队列 // worker对应的线程 Thread t = w.thread; if (!t.isInterrupted() &amp;&amp; w.tryLock()) { // 线程未被中断并且成功获得锁 try { // 中断线程 t.interrupt(); } catch (SecurityException ignore) { } finally { // 释放锁 w.unlock(); } } if (onlyOne) // 若只中断一个，则跳出循环 break; } } finally { // 释放锁 mainLock.unlock(); } } 参考StampedLock 乐观锁（tryOptimisticRead），读写不互斥 悲观锁，读写互斥 怎么保证读写同步 读后发现有写重新读取 class Point { private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { // an exclusively locked method long stamp = sl.writeLock(); try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); } } //下面看看乐观读锁案例 double distanceFromOrigin() { // A read-only method long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁 double currentX = x, currentY = y; //将两个字段读入本地局部变量 if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？ stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁 try { currentX = x; // 将两个字段读入本地局部变量 currentY = y; // 将两个字段读入本地局部变量 } finally { sl.unlockRead(stamp); } } return Math.sqrt(currentX * currentX + currentY * currentY); } //下面是悲观读锁案例 void moveIfAtOrigin(double newX, double newY) { // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try { while (x == 0.0 &amp;&amp; y == 0.0) { //循环，检查当前状态是否符合 long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁 if (ws != 0L) { //这是确认转为写锁是否成功 stamp = ws; //如果成功 替换票据 x = newX; //进行状态改变 y = newY; //进行状态改变 break; } else { //如果不能成功转换为写锁 sl.unlockRead(stamp); //我们显式释放读锁 stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试 } } } finally { sl.unlock(stamp); //释放读锁或写锁 } } } 阶段二：多线程设计模式详细介绍七钟单例模式 饿汉式； 懒汉式； synchronize method synchronize block volatile 解决重排序 Holder方式 【推荐】 public class SingletonObject6 { private SingletonObject6() {} private static class InstanceHolder { // static 只执行一次，并严格保证按照顺序执行 private final static SingletonObject6 instance = new SingletonObject6(); } public static SingletonObject6 getInstance() { return InstanceHolder.instance; } } 枚举 public class SingletonObject7 { private SingletonObject7() {} private enum Singleton { INSTANCE; private final SingletonObject7 instance; Singleton() { instance = new SingletonObject7(); } public SingletonObject7 getInstance() { return instance; } } public static SingletonObject7 getInstance() { return Singleton.INSTANCE.getInstance(); } public static void main(String[] args) { IntStream.rangeClosed(1, 100) .forEach(i -> new Thread(String.valueOf(i)) { @Override public void run() { System.out.println(SingletonObject7.getInstance()); } }.start()); } } WaitSet 所有的对象都会有一个wait set,用来存放调用了该对象wait方法之后进入block状态线程 线程被notify之后，不一定立即得到执行 线程从wait set中被唤醒顺序不一定是FIFO. 线程被唤醒后，必须重新获取锁 volatile 最好的例子缓存不一致问题 内存模型，由于cpu和内存频率不同存在cpu 高速缓存 由于Java优化，检测到线程没有写操作，就不需要去主线程中拿更新变量 解决缓存不一致问题i = 1; //两个线程同步执行 i= i+1; cpu1 -> main memory -> i -> cache i+1 -> cache(2) -> main memory(2) cpu2 -> main memory -> i -> cache i+1 -> cache(2) -> main memory(2) 两种方案 给数据总线（数据总线，地址总线，控制总线）加锁 CPU高速缓存一致性协议（Intel MESI） 核心思想： 当CPU写入数据的时候，如果发现该变量被共享（其他CPU存在该变量的副本），会发出一个信号，通知其他CPU该变量缓存无效； 其他的CPU访问该变量的时候，重新到主内存中获取 指令重排&amp;happens-before规则三个重要概念原子性，可见性，有序性 原子性： 对基本数据类型的变量读取和赋值是保证原子性的，要么成功，要么失败，这些操作不可中断 a = 10; 原子性 b = a; 不满足， 1. read a ; 2. assign b; c++; 不满足 1. read c; 2. add; 3. assign to c; c = c+1; 不满足 1. read c; 2. add; 3. assign to c; 可见性 有序性 volatile 关键字作用 保证重排序循序； 强制对缓存的修改立刻更新到主存； 如果有写操作，其他CPU中的缓存失效； volatile实践 volatile读操作和非volatile一样，写操作开销比读多得多，但是volatile 的总开销仍然要比锁获取低==&gt; 如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。 参考 Java多线程（一）之volatile深入分析 正确使用 Volatile 变量 【重点】 EverNote有笔记 观察者模式design_pattern/ObserverClient.java 一个人通过 共享资源 design_pattern/gate.java 读写锁分离design_pattern/chapter03_readwrite_lock/ReaderWorker.java 不可变类 Immutablechapter 07 作用： 多线不用加锁，提高程效率 简单的不可变操作 返回List用Collections.unmodifiableList(list) 返回对象用clone Future Design Pattern 设计逻辑： 在不堵塞主线程的情况下，主线程做其他的事情，然后在去取结果 chapter08 Future ->代表的是未来的一个凭据 FutureTask ->将你的调用逻辑进行了隔离 FutureService ->桥接 Future和 FutureTask Guarded Suspension design pattern chapter09 实际生活中的例子等我一下，我一会就来 ==&gt; 任务太多，把任务缓存到队列中，后面在处理 我正在厨房做饭 快递员敲门，说你的快递来了，要求开门 The Thread-Specific Storage 线程保险箱， chapter11 ThreadLocal 早期实现原理 Map&lt;Thread,T> storage = new HassMap&lt;>(); 应用在同一线程中做上下文设计模式 @Override public void run() { queryAction.execute(); System.out.println("The name query successful"); httpAction.execute(); System.out.println("The card id query successful"); //Context 为ThreadLocal 实现的单例模式用于run内部数据储存 Context context = ActionContext.getActionContext().getContext(); System.out.println("The Name is " + context.getName() + " and CardId " + context.getCardId()); } Balking pattern 执行到某个状态，终端执行 public synchronized void save() throws IOException { if (!changed) { // 设计模式核心重点，当发现事情已经被其他线程干完，不在往下执行 return; } doSave(); this.changed = false; } Producer and Consumer patternBlockingQueue 实现private final BlockingQueue&lt;Integer> blockingQueue = new ArrayBlockingQueue&lt;>(10); //生产 blockingQueue.put(1); //消费 blockingQueue.take(); Semaphore 实现 final Semaphore notFull = new Semaphore(10); //计数 final Semaphore notEmpty = new Semaphore(0); //计数 final Semaphore mutex = new Semaphore(1); // 锁的效果 // Producer.java try { notFull.acquire(); mutex.acquire(); count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { mutex.release(); notEmpty.release(); } //Cusomer.java try { notEmpty.acquire(); mutex.acquire(); count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { mutex.release(); notFull.release(); } synchronizedpublic synchronized void push () { count ++; notifyAll(); } public synchronized void take () { count --; notifyAll(); } ReentrantLock实现//创建一个锁对象 private Lock lock = new ReentrantLock(); //创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空 private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); //Producer.java lock.lock(); try{ while (count == FULL) { notFull.await(); } count ++; //唤醒消费者 notEmpty.signal(); }finally { lock.unlock(); } //Consumer.java lock.lock(); try { while (count == 0) { notEmpty.await(); } notFull.signal(); } finally { lock.unlock(); } public void put(final Message message) throws InterruptedException { synchronized (queue) { // multi-thread lock while (queue.size() > limit) { // out over limit wait queue.wait(); } queue.addLast(message); // first in last out queue.notifyAll(); } } Count Donw pattern JDK CountDownLatch CountDownLatch latch = new CountDownLatch(1); latch.countDown(); latch.await(); 模仿 public CountDown(int total) { this.total = total; } public void down() { synchronized (this) { this.counter++; this.notifyAll(); } } public void await() throws InterruptedException { synchronized (this) { while (counter != total) { this.wait(); } } } Two-Phase Termination Design Pattern 线程执行完毕，在线程中关闭一次，还需要手动清理一下资源 Work Thread Design Pattern 流水线工人，流水线一直开着，有固定工人组装，运输工人负责运输添加流水线的货物 Active Object （Chapter18）接受异步消息的主动方法 阶段三：并发包详情介绍1. 原子类型详细讲解1.1 Atomic* volatile 修饰的变量 CAS算法， 也就是CPU级别的同步命令 1.2 AtomicReference ABA问题缺点： CAS轻量级锁，带来的一个严重问题，ABA问题， 问题描述，当T2从A回到A状态可以有各种条件的变化，而T1的判断条件可能导致无法感知到T2的多种状态变化而产生问题 T1 T2 A->C A->B->A 解决方案是加版本标签，官方提供的解决类AtomicStampedReference AtomicLong 如果是64位的情况下可能会有高位低位分别传输的问题导致非原子性； public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&lt;V> current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 1.2 Atomic*FieldUpdater使用场景 想要类的属性操作具备原子性 volatile 非private，protected（保证可访问） 类型一致 不想使用锁（包括显式锁或者重量级锁synchronized） 大量需要原子类型修饰的对象，相对比较耗费内存，案例ConcurrentSkipListMap Node{ pre:Node; next:Node; value:Objecct; } 1.3 Unsafe Unsafe是Java中一个底层类，包含了很多基础的操作，比如数组操作、对象操作、内存操作、CAS操作、线程(park)操作、栅栏（Fence）操作，JUC包、一些三方框架都使用Unsafe类来保证并发安全。 Java is a safe programming language and prevents programmer from doing a lot of stupid mistakes, most of which based on memory management. But, there is a way to do such mistakes intentionally, using Unsafe class park/unpark LockSupport 依赖park/unpark 实现 Java 调用C/C++ 代码Hello.java public class Hello { static { System.loadLibrary("hello"); } private native void hi(); public static void main(String[] args) { new Hello().hi(); } } 编译Hello.java javac Hello.java 生成Jni头文件 javah -jni Hello 编写C代码Hello.c #include &lt;jni.h> #include &lt;stdio.h> /* Header for class Hello */ #ifndef _Included_Hello #define _Included_Hello #ifdef __cplusplus extern "C" { #endif /* * Class: Hello * Method: hi * Signature: ()V */ JNIEXPORT void JNICALL Java_Hello_hi (JNIEnv * env, jobject o){ print("Hello Jni\n"); } #ifdef __cplusplus } #endif #endif 编译Cgcc -fPIC -D_REENETRANT -I &quot;$JAVA_HOME/include&quot; -I &quot;$JAVA_HOME/include/linux&quot; -c Hello.c 生成连接库 gcc -shared Hello.o -o libhello.so 运行java Hello 如下异常，需配置LD_LIBRARY_PATH为当前路径 export LD_LIBRARY_PATH=./lib:$LD_LIBRARY_PATH Exception in thread "main" java.lang.UnsatisfiedLinkError: no hello in java.library.path at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867) at java.lang.Runtime.loadLibrary0(Runtime.java:870) at java.lang.System.loadLibrary(System.java:1122) at Hello.&lt;clinit>(Hello.java:3) unsafe常用方法 /** * 绕过初始化 */ Simple simple2 = (Simple) unsafe.allocateInstance(Simple.class); System.out.println(simple2.getValue()); Guard guard = new Guard(); guard.work(); /** * 直接修改guard内存 */ Field field = guard.getClass().getDeclaredField("ACCESS_ALLOWED"); unsafe.putInt(guard, unsafe.objectFieldOffset(field), 42); guard.work(); /** * 定义类cc */ byte[] bytes = loadClassContent(); Class&lt;?> aClass = unsafe.defineClass(null, bytes, 0, bytes.length,null,null); int v = (int) aClass.getMethod("get").invoke(aClass.newInstance(), null); System.out.println("defineClass:" + v); /** * 获取类的size */ System.out.println(sizeOf(new Simple())); 2. Java并发包工具2.1 CountDownLatch 并行转窜行，等到最后结果，离散平行任务增加逻辑层次关系 有一个任务执行的时候发现可以交给其他线程执行； 2.2 CyclicBarrierAPI CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() { @Override public void run() { //当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了 } }); barrier.getNumberWaiting(); //获取当前等待数量 barrier.getParties(); barrier.reset(); // 当getNumberWaiting !=0 的时候, reset会导致正在等待的线程报BrokenBarrierException 异常 即reset == initial == finish； 小结CountDownLatch VS CyclicBarrier CountDownLatch 不能reset，而CyclicBarrier是可以循环使用的； latch 工作线程互不关系， barrier工作线程必须等到 2.3 Semaphore Semaphore Api 官方demo class Pool { private static final int MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); public Object getItem() throws InterruptedException { available.acquire(); return getNextAvailableItem(); } public void putItem(Object x) { if (markAsUnused(x)) available.release(); } // Not a particularly efficient data structure; just for demo protected Object[] items = ... whatever kinds of items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() { for (int i = 0; i &lt; MAX_AVAILABLE; ++i) { if (!used[i]) { used[i] = true; return items[i]; } } return null; // not reached } protected synchronized boolean markAsUnused(Object item) { for (int i = 0; i &lt; MAX_AVAILABLE; ++i) { if (item == items[i]) { if (used[i]) { used[i] = false; return true; } else return false; } } return false; } } acquireUninterruptibly 不处理中断 acquire(int permits) 同时获取多个中断 release(int permits) 同时释放多个中断 drainPermits() Acquires and returns all permits that are immediately available. 2.4 ReentrantLock ReentrantLock API getOwner() 尝试拿到这个锁，那不到的时候尝试中断 ConditionObject 具体实现类 维护一个单向列表，await向等待队列插入Node，叫醒向等待队列头部移除一个节点，放人同步队列中竞争CPU资源 同步队列 等待队列 2.5 Exchanger Exchanger API 注意： exchanger的值指向的是同一个堆内存，如果修改两边都会变动，如操作某些List =&gt; 代码ExchangerExample。 官网Demo class FillAndEmpty { Exchanger&lt;DataBuffer> exchanger = new Exchanger&lt;DataBuffer>(); DataBuffer initialEmptyBuffer = ... a made-up type DataBuffer initialFullBuffer = ... class FillingLoop implements Runnable { public void run() { DataBuffer currentBuffer = initialEmptyBuffer; try { while (currentBuffer != null) { addToBuffer(currentBuffer); if (currentBuffer.isFull()) currentBuffer = exchanger.exchange(currentBuffer); } } catch (InterruptedException ex) { ... handle ... } } } class EmptyingLoop implements Runnable { public void run() { DataBuffer currentBuffer = initialFullBuffer; try { while (currentBuffer != null) { takeFromBuffer(currentBuffer); if (currentBuffer.isEmpty()) currentBuffer = exchanger.exchange(currentBuffer); } } catch (InterruptedException ex) { ... handle ...} } } void start() { new Thread(new FillingLoop()).start(); new Thread(new EmptyingLoop()).start(); } } 博文：【死磕Java并发】—–J.U.C之并发工具类：Exchanger 2.6 ReadWriteLock2.7 Condition2.8 StampedLock 读的时候也能写 最简单案例 private static void read() { long stamped = -1; try { stamped = lock.readLock(); } finally { lock.unlockRead(stamped); } } private static void write() { long stamped = -1; try { stamped = lock.writeLock(); } finally { lock.unlockWrite(stamped); } } 官网demo class Point { private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { // an exclusively locked method long stamp = sl.writeLock(); try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); } } double distanceFromOrigin() { // A read-only method long stamp = sl.tryOptimisticRead(); double currentX = x, currentY = y; if (!sl.validate(stamp)) { stamp = sl.readLock(); try { currentX = x; currentY = y; } finally { sl.unlockRead(stamp); } } return Math.sqrt(currentX * currentX + currentY * currentY); } void moveIfAtOrigin(double newX, double newY) { // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try { while (x == 0.0 &amp;&amp; y == 0.0) { long ws = sl.tryConvertToWriteLock(stamp); if (ws != 0L) { stamp = ws; x = newX; y = newY; break; } else { sl.unlockRead(stamp); stamp = sl.writeLock(); } } } finally { sl.unlock(stamp); } } } 2.9 Forkjoin 任务分解框架 RecursiveTask 有返回值 RecursiveAction 无返回值 3.0 Phaser Phaser API 通过 phaser.register() 可以动态添加； 可以循环使用 arriveAndAwaitAdvance Arrives at this phaser and awaits others. arriveAndDeregister 动态的–；我退出你 们不用等我了 /** * Arrives at this phaser and deregisters from it without waiting * for others to arrive. Deregistration reduces the number of * parties required to advance in future phases. If this phaser * has a parent, and deregistration causes this phaser to have * zero parties, this phaser is also deregistered from its parent. * * &lt;p>It is a usage error for an unregistered party to invoke this * method. However, this error may result in an {@code * IllegalStateException} only upon some subsequent operation on * this phaser, if ever. * * @return the arrival phase number, or a negative value if terminated * @throws IllegalStateException if not terminated and the number * of registered or unarrived parties would become negative */ public int arriveAndDeregister() { return doArrive(ONE_DEREGISTER); } arrive /** * Arrives at this phaser, without waiting for others to arrive. * * &lt;p>It is a usage error for an unregistered party to invoke this * method. However, this error may result in an {@code * IllegalStateException} only upon some subsequent operation on * this phaser, if ever. * * @return the arrival phase number, or a negative value if terminated * @throws IllegalStateException if not terminated and the number * of unarrived parties would become negative */ public int arrive() { return doArrive(ONE_ARRIVAL); } bulkRegister 注册多个 状态判断 getRegisteredParties getArrivedParties getUnarrivedParties 控制 //根据条件控制是否终止Phaser final Phaser phaser = new Phaser(2){ @Override protected boolean onAdvance(int phase, int registeredParties) { System.out.println("phase:" + phase + "\tregisteredParties :" + registeredParties); //return super.onAdvance(phase, registeredParties); return true/*终止*/, false /*不终止*/; } }; 强制终止 phaser.forceTermination(); awaitAdvance(phase phase) 案例 终止等待的两个条件 current phase is not equal to the given phase value this phaser is terminated. demo: F:\Source\javaBase\src\main\java\com\sample\current\phaser\PhaserExample6.java 带有等待的中断 awaitAdvanceInterruptibly phaser.awaitAdvanceInterruptibly(0,3,TimeUnit.SECONDS); 带有超时时间 附录 1. CountDownLatch、CyclicBarrier和Semaphore 3. Executors框架ThreadPoolExecutor 3.1 shutdown分析shutdown /** * shutdown * * -- condition --- * 20 threads * 10 threads work * 10 idle * * shutdown invoked * -- result -- * 1. 10 waiting to finished the work. * 2. 10 interrupted the idle works. * 3. 20 idle threads will exist. */ shutdownNow /** * shutdownNow * -- condition --- * 10 threads queue elements 10 * 10 running * 10 stored in the blocking queue. *-- result -- * 1. return list&lt;Runnable> remain 10 un handle runnable in the queue. * 2. interrupt all of threads in the pool. */ 调用shutdown后一些状态变化 executorService.isShutdown(); // ture executorService.isTerminated(); // false 还有任务在执行 ((ThreadPoolExecutor) executorService).isTerminating(); // true 3.2 Executors.newWorkStealingPool using all available processors 线程工作模式为“Work-Stealing Algorithm” ，当任务队列完成后不是进入等待状态，而是主动窃取别的线程任务来做； 任务处理完自动停止线程池； 3.3 Schedule 的实现 Timer 存在问题是当任务执行超时时，影响下一个任务执行时间 crontab (linux), 每隔一分钟执行run.sh 脚本 run.sh #!/bin/sh echo `date "+%Y-%m-%d %H:%M:%S"` crontab -e edit user’s crontab #每一分钟执行一次 * * * * * sh //root/document/scripts/run.sh >> /root/document/scripts/run.log crontab 简单说明 vi /etc/crontab SHELL=/bin/bash org.quartz-scheduler&lt;/groupId> &lt;artifactId>quartz&lt;/artifactId> &lt;version>2.2.1&lt;/version> &lt;/dependency> 最简单demo JobDetail jobDetail = JobBuilder.newJob(SimpleJob.class) .withIdentity("job1", "group1") .build(); Trigger trigger = TriggerBuilder.newTrigger() .withIdentity("trigger", "group1") .withSchedule(CronScheduleBuilder.cronSchedule("0/5 * * * * ?")) .build(); Scheduler scheduler = new StdSchedulerFactory().getScheduler(); scheduler.start(); scheduler.scheduleJob(jobDetail, trigger); SimpleJob.java public class SimpleJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { SimpleDateFormat dt = new SimpleDateFormat("yyyy-mm-dd hh:mm:ss"); System.out.println("======" + dt.format(new Date()) + "======"); } } ScheduledExecutorService 如果执行任务时长超过周期，那么周期按照任务时长算 3.4 异常处理 方案一：增加守护线程并设置异常捕获类setUncaughtExceptionHandler，缺点当获取不到详细的线程状态 方案二：通过自定义Runnable捕捉异常,模板如下： public abstract class MyTask implements Runnable { protected final String name ; public MyTask(String name) { this.name = name; } @Override public void run() { try { this.doInit(); this.doExecute(); this.done(); } catch (Throwable e) { this.error(e); } } protected abstract void error(Throwable e); protected abstract void done(); protected abstract void doExecute(); protected abstract void doInit(); } 3.5 拒绝策略（RejectedExecutionHandler）3.6 API详解 F:\Source\javaBase\src\main\java\com\sample\current\executor\ExecutorServiceExampleApi.java Core Thread Timeout 设置核心线程超时时间，超时关闭核心线程池 executorServices.setKeepAliveTime(10, TimeUnit.SECONDS); executorServices.allowCoreThreadTimeOut(true); 带返回值的方法 &lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks) throws InterruptedException; //代超时时间 &lt;T> List&lt;Future&lt;T>> invokeAll(Collection&lt;? extends Callable&lt;T>> tasks, long timeout, TimeUnit unit) throws InterruptedException; /** * return {@code false} * if all core threads have already been started. */ boolean prestartCoreThread(); prestartAllCoreThreads 预启动所有的coreThread before/after 在每个任务启动开始和结束时调用 @Override protected void beforeExecute(Thread t, Runnable r) { System.out.println("--before--"); System.out.println("init the " + ((MyRunnable) r).getData()); } @Override protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); System.out.println("--after--"); if (null == t) { System.out.println("successful " + ((MyRunnable) r).getData()); }else { t.printStackTrace(); } } 3.7 Future&amp;Callable future.get() interrupt 是谁？ 中断的是调用的线程，但是中断后runnable还能继续工作 future timeout 是否会继续执行？ future.get(5, TimeUnit.SECONDS); future中断Runnable后会继续执行，如果需要终止任务需要额外处理 如kill -9 applicationId 3.8 CompletionService解决一个问题,如下，多线程futureList.get的时候不知道随先完成谁后完成（谁先谁后），导致执行快的等执行慢的。 List&lt;Future&lt;Integer>> futureList = executorService.invokeAll(callableList); System.out.println(futureList.get(0).get()); System.out.println(futureList.get(1).get()); completionService.take()// 阻塞，知道有任务完成可以获取结果 completionService.poll()//poll直接返回，不阻塞。但是没有完成的任务则返回null completionService.poll(5,TimeUnit.SECONDS) //阻塞等待指定时间，如果有完成结果返回，没有的直接返回null 获取最先完成的任务 while ((future = completionService.take()) != null) { System.out.println(future.get()); } 3.9 CompletableFuture入门体验Java Doc Api ExecutorService + future 当任务执行完成的时候通知调动者 解决future的缺点： 多个future不知道谁先执行完 future需要主动去拿而且future.get() 会阻塞 future获取的结果在放入线程池需要new callback，达不到极连 解决案例：F:\Source\javaBase\src\main\java\com\sample\current\executor\CompletableFutureExample.java 知识点： CompletableFuture 默认的线程是守护线程当调用者退出，默认直接退出； 多个CompletableFuture的组合实战经验1. 任务超时无法shutdown 当有runnable访问某个资源，网络请求，某个db特别慢任务过重的时候，shutdown/shutdownNow 无法使用 //新建线程池时，使用守护线程的方式 new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setDaemon(true); return thread; } } 2. ExecutorService中的陷阱 线程池中执行完一段时间（20s），shutdown线程，然后记录下未完成的任务 答案： F:\Source\javaBase\src\main\java\com\sample\current\executor\ComplexExample.java 使用CompletionService + shutdownNow 返回未完成值的方式, 容易犯的问题： ExecutorCompletionService 把runable重新封装，shutdownNow 返回私有类无法使用 shutdownNow 没有包括中断的任务 小结 4. 并发集合常用的并发集合类 ConcurrentHashMap ConcurrentSkipListMap ConcurrentLinkedQueue ConcurrentLinkedDeque CopyOnWriteArraySet CopyOnWriteArrayList ArrayBlockingQueue PriorityBlockingQueue LinkedBlockingQueue SynchronousQueue DelayQueue LinkedTransferQueue 1. LinkedList 实现LinkedList Binary search treee 1. 单向LinkedList Stack B+ tree 2. 单项有序 ==> Queue 由树的平衡性 Red Black tree 3. 双向 Binary Tree ==> AVL 4. 双向有序 2-3-4 Tree Spary's Tree 无序 F:\Source\javaBase\src\main\java\com\sample\current\collections\LinkedList.java 有序 F:\Source\javaBase\src\main\java\com\sample\current\collections\PriorityLinkedList.java 2. SkipList跳表数据结构实现 F:\Source\javaBase\src\main\java\com\sample\current\collections\SimpleSkipList.java 跳表的实现 跳表的技术特点 一种随机的数据结构 最底层包含整个跳表的所有元素 典型的空间换时间的算法 由于对比效率高，查找删除快 3. ArrayBlockingQueue插入队列方法(主要区分是队列满时应该怎么反应，异常，等待，返回值) 方法名称 参数描述 返回值 异常信息 add 插入对象 ture代表插入成功，如果队列已满，抛出异常 IllegalStateException(“Queue full”)异常——AbstractQueue offer 插入对象 true代表插入成功，队列已满直接返回false 无 offer 插入对象，等待时间 true代表插入成功，队列已满等待一段时间后仍没有空间则返回false 无 put 插入对象 true代表插入成功，如果队列已满则阻塞线程等待队列为空的时候插入 获取队列内容 方法名称 参数描述 返回值 异常信息 remove 无 返回队首数据并移除，队列已空则抛出异常信息 NoSuchElementException()异常——AbstractQueue poll 无 列不为空时返回队首值并移除；队列为空时返回null。非阻塞立即返回。 poll 等待时间 设定等待的时间，如果在指定时间内队列还未孔则返回null，不为空则返回队首值 take 无 队列不为空返回队首值并移除；当队列为空时会阻塞等待，一直等到队列不为空时再返回队首值。 参考： ArrayBlockingQueue原理详解 JDK 新特性LongAddr Atomctic 的不同之处 竞争多个资源（拆分为Cell数组） 动态扩容 缺点： LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差java 提供的方法 add()：增加指定的数值； increament()：增加1； decrement()：减少1； intValue()/floatValue()/doubleValue()：得到最终计数后的结果 sum()：求和，得到最终计数结果 sumThenReset()：求和得到最终计数结果，并重置value。 阶段四: 并发深入探讨一 . 死锁 Jconsole -&gt; 线程-&gt; 有检测死锁的工具 1 死锁的分类 1 顺序死锁，A调用leftRight()，B调用rightLeft() （厕所内有坑，厕所外有纸，相互缺少） public class LeftRightDeadlock { private final Object left = new Object(); private final Object right = new Object(); public void leftRight() { // 得到left锁 synchronized (left) { // 得到right锁 synchronized (right) { doSomething(); } } } public void rightLeft() { // 得到right锁 synchronized (right) { // 得到left锁 synchronized (left) { doSomethingElse(); } } } } ` 2 动态死锁，进来锁定自己的账户，相互等待。 // 转账 public static void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException { // 锁定汇账账户 synchronized (fromAccount) { // 锁定来账账户 synchronized (toAccount) { // 判余额是否大于0 if (fromAccount.getBalance().compareTo(amount) &lt; 0) { throw new InsufficientFundsException(); } else { // 汇账账户减钱 fromAccount.debit(amount); // 来账账户增钱 toAccount.credit(amount); } } } } 如果两个线程同时调用transferMoney() 线程A从X账户向Y账户转账 线程B从账户Y向账户X转账，产生死锁。 3 协作对象之间 public class CooperatingDeadlock { // Warning: deadlock-prone! class Taxi { @GuardedBy("this") private Point location, destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) { this.dispatcher = dispatcher; } public synchronized Point getLocation() { return location; } // setLocation 需要Taxi内置锁 public synchronized void setLocation(Point location) { this.location = location; if (location.equals(destination)) // 调用notifyAvailable()需要Dispatcher内置锁 dispatcher.notifyAvailable(this); } public synchronized Point getDestination() { return destination; } public synchronized void setDestination(Point destination) { this.destination = destination; } } class Dispatcher { @GuardedBy("this") private final Set&lt;Taxi> taxis; @GuardedBy("this") private final Set&lt;Taxi> availableTaxis; public Dispatcher() { taxis = new HashSet&lt;Taxi>(); availableTaxis = new HashSet&lt;Taxi>(); } public synchronized void notifyAvailable(Taxi taxi) { availableTaxis.add(taxi); } // 调用getImage()需要Dispatcher内置锁 public synchronized Image getImage() { Image image = new Image(); for (Taxi t : taxis) // 调用getLocation()需要Taxi内置锁 image.drawMarker(t.getLocation()); return image; } } class Image { public void drawMarker(Point p) { } } } Dispatcher的getImage() 及Taxi的setLocation有相互锁的可能性 2 避免死锁 固定加锁的顺序(针对锁顺序死锁) 开放调用(针对对象之间协作造成的死锁) 使用定时锁–&gt;tryLock() 2.1 固定锁顺序避免死锁 用HashCode 固定顺序 public class InduceLockOrder { // 额外的锁、避免两个对象hash值相等的情况(即使很少) private static final Object tieLock = new Object(); public void transferMoney(final Account fromAcct, final Account toAcct, final DollarAmount amount) throws InsufficientFundsException { class Helper { public void transfer() throws InsufficientFundsException { if (fromAcct.getBalance().compareTo(amount) &lt; 0) throw new InsufficientFundsException(); else { fromAcct.debit(amount); toAcct.credit(amount); } } } // 得到锁的hash值 int fromHash = System.identityHashCode(fromAcct); int toHash = System.identityHashCode(toAcct); // 根据hash值来上锁 if (fromHash &lt; toHash) { synchronized (fromAcct) { synchronized (toAcct) { new Helper().transfer(); } } } else if (fromHash > toHash) {// 根据hash值来上锁 synchronized (toAcct) { synchronized (fromAcct) { new Helper().transfer(); } } } else {// 额外的锁、避免两个对象hash值相等的情况(即使很少) synchronized (tieLock) { synchronized (fromAcct) { synchronized (toAcct) { new Helper().transfer(); } } } } } } 2.2 开放调用避免死锁 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用！ 用局部代码块锁代替整个方法的锁 class CooperatingNoDeadlock { @ThreadSafe class Taxi { @GuardedBy("this") private Point location, destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) { this.dispatcher = dispatcher; } public synchronized Point getLocation() { return location; } public synchronized void setLocation(Point location) { boolean reachedDestination; // 加Taxi内置锁 synchronized (this) { this.location = location; reachedDestination = location.equals(destination); } // 执行同步代码块后完毕，释放锁 if (reachedDestination) // 加Dispatcher内置锁 dispatcher.notifyAvailable(this); } public synchronized Point getDestination() { return destination; } public synchronized void setDestination(Point destination) { this.destination = destination; } } @ThreadSafe class Dispatcher { @GuardedBy("this") private final Set&lt;Taxi> taxis; @GuardedBy("this") private final Set&lt;Taxi> availableTaxis; public Dispatcher() { taxis = new HashSet&lt;Taxi>(); availableTaxis = new HashSet&lt;Taxi>(); } public synchronized void notifyAvailable(Taxi taxi) { availableTaxis.add(taxi); } public Image getImage() { Set&lt;Taxi> copy; // Dispatcher内置锁 synchronized (this) { copy = new HashSet&lt;Taxi>(taxis); } // 执行同步代码块后完毕，释放锁 Image image = new Image(); for (Taxi t : copy) // 加Taix内置锁 image.drawMarker(t.getLocation()); return image; } } class Image { public void drawMarker(Point p) { } } } 2.3 使用定时锁深度问题Java的多路复用 常用4种IO模型（同步/异步/阻塞/非阻塞的概念） 实战问题定位 数据+ 工具+ 经验 操作系统–&gt; JVM 虚拟机(java提供的工具)–&gt; 数据 jstack 使用 建议线程名字给的有意义，在排查问题时很有必要。 jps -v 列出所有Java进程，拿到pid=1523 jstack 1523 &gt; 1523.log 将dump文件输出到日志 上传到http://heaphero.io/index.jsp 或使用MAT分析 Best practice 尽量不要在线程中做大量耗时的网络操作，如查询数据库（可以的话在一开始就将数据从从 DB 中查出准备好）【能在初始化做的耗时完成】 尽可能的减少多线程竞争锁。可以将数据分段，各个线程分别读取。 多利用 CAS+自旋 的方式更新数据，减少锁的使用。【待实践】 private AtomicReference&lt;Thread> atomicReference = new AtomicReference&lt;>(); private void lock() { while (atomicReference.compareAndSet(null, currentThread())) ; } private void unlock() { atomicReference.compareAndSet(currentThread(), null); } 应用中加上 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp 参数，在内存溢出时至少可以拿到内存日志。 线程池监控。如线程池大小、队列大小、最大线程数等数据，可提前做好预估。 ThreadPoolExecutor tpe = ((ThreadPoolExecutor) es); while (true) { System.out.println(); int queueSize = tpe.getQueue().size(); System.out.println("当前排队线程数：" + queueSize); int activeCount = tpe.getActiveCount(); System.out.println("当前活动线程数：" + activeCount); long completedTaskCount = tpe.getCompletedTaskCount(); System.out.println("执行完成线程数：" + completedTaskCount); long taskCount = tpe.getTaskCount(); System.out.println("总线程数：" + taskCount); Thread.sleep(3000); } JVM 监控，可以看到堆内存的涨幅趋势，GC 曲线等数据，也可以提前做好准备。 Linux 系统监控 查看（Linux菜鸟私房菜笔记）之 性能监控 【待实践总结】 jstat JVM监控命令(在Java基础笔记看到使用说明之监控) jvisualvm 同上 简易web服务器 http 响应头和请求头对照表 HTTP content-type 对照表 HTTP状态码 附录一推荐书籍 《Java 并发编程实战》 《Java并发编程的艺术》方腾飞 《深入理解Java虚拟机》 周志明 网站 java并发编程网 博客 Java 理论与实践 专业名词 指令重排序，在不影响程序运行结果的前提下重新排序代码 附录二常用的消息队列]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>‘多线程’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 学习笔记]]></title>
    <url>%2F2019%2F06%2F05%2F2019-6-5-nginx%2F</url>
    <content type="text"><![CDATA[第一章 Nginx 简介 nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server nginx 是一个高性能的HTTP和反向代理web服务器 1.0 Basic HTTP server features Serving static and index files, autoindexing; open file descriptor cache; Accelerated reverse proxying with caching; load balancing and fault tolerance; Accelerated support with caching of FastCGI, uwsgi, SCGI, and memcached servers; load balancing and fault tolerance; Modular architecture. Filters include gzipping, byte ranges, chunked responses, XSLT, SSI, and image transformation filter. Multiple SSI inclusions within a single page can be processed in parallel if they are handled by proxied or FastCGI/uwsgi/SCGI servers; SSL and TLS SNI support; Support for HTTP/2 with weighted and dependency-based prioritization. 2.0 Other HTTP server features Name-based and IP-based virtual servers; Keep-alive and pipelined connections support; Access log formats, buffered log writing, fast log rotation, and syslog logging; 3xx-5xx error codes redirection; The rewrite module: URI changing using regular expressions; Executing different functions depending on the client address; Access control based on client IP address, by password (HTTP Basic authentication) and by theresult of subrequest; Validation of HTTP referer; The PUT, DELETE, MKCOL, COPY, and MOVE methods; FLV and MP4 streaming; Response rate limiting; Limiting the number of simultaneous connections or requests coming from one address; IP-based geolocation; A/B testing; Request mirroring; Embedded Perl; njs scripting language. 3.0 TCP/UDP proxy server features Generic proxying of TCP and UDP; SSL and TLS SNI support for TCP; Load balancing and fault tolerance; Access control based on client address; Executing different functions depending on the client address; Limiting the number of simultaneous connections coming from one address; Access log formats, buffered log writing, fast log rotation, and syslog logging; IP-based geolocation; A/B testing; njs scripting language. 4.0 Nginx 优点 IO 多路复用epoll 什么是IO多路复用： 多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，其中复用指复用同一个线程。 轻量级，功能模块化，代码模块化 CPU亲和（afflinity） 什么是CPU亲和： 是一种CPU核心和Nginx工作进程绑定的方式，把没一个Worker进程固定在一个cpu上执行，减少切换cpu的cache miss, 获取更好的性能。 sendFile 第二章 基础篇Nginx快速搭建官网： http://nginx.org/ Mainline version 开发版本 Stable version 稳定版本 Legacy version 历史版本 Pre-Built Packages有对应系统的安装方式 linux_package vim /etc/yum.repos.d/nginx.repos Nginx 基本命令使用Ø -h：显示帮助信息 Ø -v：显示Tengine版本 Ø -m：显示所有静态编译的模块 Ø -l：显示所有可配置的指令 Ø -V：显示版本、编译安装时的选项、所有静态编译的模块 Ø -t：检查Tengine配置文件语法 Ø -s [stop | quit | reopen | reload]：关闭 | 退出 | 重新打开 | 重载Tengine windows下nginx的安装及使用 start nginx nginx -s stop(快速停止nginx) 或 nginx -s quit(完整有序的停止nginx) nginx.exe -t # 测试conf nginx.exe -s reload #重新加载conf taskkill /IM nginx.exe /F # kill 所有后台nginx实例 Nginx 常用命令 sudo nginx #打开 nginx nginx -s reload|reopen|stop|quit #重新加载配置|重启|停止|退出 nginx nginx -t #测试配置是否有语法错误 nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives] -?,-h : 打开帮助信息 -v : 显示版本信息并退出 -V : 显示版本和配置选项信息，然后退出 -t : 检测配置文件是否有语法错误，然后退出 -q : 在检测配置文件期间屏蔽非错误信息 -s signal : stop（停止）, quit（退出）, reopen（重启）, reload -p prefix : 设置前缀路径（默认是：/usr/local/Cellar/nginx/1.2.6/） -c filename : 设置配置文件（默认是：/usr/local/etc/nginx/nginx.conf） -g directives : 设置配置文件外的全局指令 nginx -t 能查看配置文件所在目录 nginx: the configuration file /usr/local/tengine/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/tengine/conf/nginx.conf test is successful 阿里云后台配置文件路径：/usr/local/tengine/conf/nginx.conf Nginx的目录和配置语法Building nginx from Sourceshttps://nginx.org/en/docs/configure.html Core functionalityhttps://nginx.org/en/docs/ngx_core_module.html 日志目录 tengine -&gt; /usr/local/tengine/logs 查看nginx的配置 nginx -V 配置模块化不同功能的配置文件尽量单独编写，使配置文件解耦 http { #导入servers/目录下所有conf文件 include servers/*.conf; } 错误处理 自定义错误页 location /bbs { root /vhosts/bbs; error_page 404 404/404.html; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } Nginx 日志 log_fromat简单的访问控制基于来源IP实现访问控制server{ location / { # 网段的写法：192.168.1.0/24 deny 192.168.1.222; # 从上到下进行匹配，类似iptables allow all; } location /bbs { if ( $remote_addr = 192.168.1.146 ) { return 404; } } 基于用户名/密码实现访问控制location /bbs { auth_basic "Please Login"; auth_basic_user_file /usr/local/tengine/conf/.htpasswd; } 设置账户密码 yum -y install httpd-tools cd /usr/local/tengine/conf htpasswd -c -m .htpasswd keyso //用户名keyso，密码123456 nginx -t nginx -s reload htpasswd -c：自动创建账号文件（仅在添加第一个用户时使用该选项） -m：使用MD5加密用户密码 -s：使用SHA加密用户密码 -D：删除指定用户 禁止访问某一类资源location ~ \.(txt|doc)$ { if (-f $request_filename){ root html; break; } deny all; } Nginx 变量HTTP请求变量 - arg_PARAMETER, http_HEADER, sent_http_HEADER 内置变量 - Nginx内置变量 Embedded Variables 自定义变量server { set $foo hello; location /test/ { default_type application/json; return 200 &#39;{&quot;status&quot;:&quot;${foo}/$foo&quot;}&#39;; } } 定义范围：server{} 内 放到外面报错nginx: [emerg] &quot;set&quot; directive is not allowed here 初始化：在加载conf的时候，故没有set变量直接引用无法启动 server { listen 8080; location /foo { set $a hello; echo_exec /bar; #内部跳转a值不变 } location /bar { #可以看出定义在location范围之外，赋值是在location内 echo &quot;a = [$a]&quot;; } } 测试 [root@localhost html]# curl localhost/foo #内部跳转a值不变 a = [hello] [root@localhost html]# curl &#39;http://localhost/bar&#39; #外部跳转没有赋值 a = [] 内建变量参考 深度学习之 Nginx 变量 全局变量参考 附录二 Nginx全局变量解析 Nginx 模块讲解 分为 官方模块，第三方模块 官方模块参数： Modules reference 常用的模块用法ngx_http_stub_status_module 提供访问的基本状态信息 编译选项： –with-http_stub_status_module 用法 location /status { stub_status on; allow 192.168.101.120; deny all; access_log off; } ngx_http_random_index_module 随机Index.html 用法 location / { root /usr/src/nginx/; random_index on; } 在/usr/src/nginx/ 下新建1.html,2.html,3.html ，访问/ 会随机访问以上三个文件 ngx_http_sub_module 指定字符串的替换 编译选项： --with-http_sub_module location / { sub_filter &#39;&lt;a href=&quot;http://127.0.0.1:8080/&#39; &#39;&lt;a href=&quot;https://$host/&#39;; sub_filter &#39;&lt;img src=&quot;http://127.0.0.1:8080/&#39; &#39;&lt;img src=&quot;https://$host/&#39;; sub_filter_once on; ## 默认为全部替换，开启替换一次 } Nginx 请求限制链接频率限制 :ngx_http_limit_conn_module this module is used to limit the number of connections per the defined key, in particular, the number of connections from a single IP address. Not all connections are counted. A connection is counted only if it has a request being processed by the server and the whole request header has already been read. Directives Syntax: **limit_conn** *zone* *number*; Default: — Context: http, server, location Example Configuration limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server { ... limit_conn perip 10; #每个IP allow 10 connections limit_conn perserver 100;#每个服务 allow 10 connections } 注意：HTTP/2 复用的连接是分开计数的，原文： In HTTP/2 and SPDY, each concurrent request is considered a separate connection. 请求频率限制 ：ngx_http_limit_req_module this module (0.7.21) is used to limit the request processing rate per a defined key, in particular, the processing rate of requests coming from a single IP address. The limitation is done using the “leaky bucket” method. Example Configuration limit_req_zone $binary_remote_addr zone=perip:10m rate=1r/s; limit_req_zone $server_name zone=perserver:10m rate=10r/s; #(r/m) server { ... limit_req zone=perip burst=5 nodelay; limit_req zone=perserver burst=10; } － burst 下一个周期继续响应5个reqest超过1r/s，当超过5个request的时候看 [nodelay | delay=number] 怎么处理 Directives Syntax: `limit_req zone=name [burst=number] [nodelay delay=number];` Default: — Context: http, server, location Nginx 访问控制auth_mod.conf 基于IP ngx_http_access_module Syntax: `allow address CIDR unix: all;` Default: — Context: http, server, location, limit_except CIDR 网段 Sample Configuration location / { deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; } 过个IP用ngx_http_geo_module定义 access_module存在的局限性，及当client通过代理访问是remote_addr是不同的 解决方案一 存在问题是，http_x_forwarded_for是协议要求，厂商可以不实现且可以修改 解决方案二 HTP自定义变量 基于用户信任登录 ngx_http_auth_basic_module Sample Configuration location / { auth_basic "Auth access test ! input your password!"; auth_basic_user_file conf/htpasswd; } auth_basic_user_file # comment 用户名:密码:描述 name1:password1 name2:password2:comment name3:password3 加密密码：htpasswd yum install httpd-tools -y htpasswd -c ./auth_conf jeson # -c 指定生成文件 jeson 用户名 局限性 用户信息依赖文件方式 操作管理机械，效率低下 解决方案： Nginx结合LUA实现高效验证 Nginx和LDAP打通，利用nginx-auth-ldap模块 第三章 场景实践Nginx作为静态资源WEB服务1, 静态资源服务场景-CDN2 配置语法tcp_nopush原理：多个包集中发送，适合大文件开启 Syntax: tcp_nopush on | off; Default: tcp_nopush off; Context: http, server, location 作用： sendfile开启的情况下，提高网络包的传输效率 tcp_nodelay Syntax: tcp_nodelay on | off; Default: on Context: http, server, location 作用： keepalive连接下，提高网络包的传输实时性； 3. 压缩 ngx_http_gzip_module Sample_confuration gzip on; gzip_min_length 1000; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain application/xml; 压缩 Syntax: gzip on | off; Default: off; Context: http, server, location, if in location 压缩比 Syntax: gzip_comp_level level; Default: 1; Context: http, server, location 压缩版本 Syntax: gzip_http_version 1.0 | 1.1; Default: gzip_http_version 1.1; # 主流 Context: http, server, location 4 浏览器缓存原理客户端浏览器缓存原理 etag lastmodified 缓存原理流程图 Expires 配置语法 Syntax: expires [modified] time; expires epoch | max | off; Default: expires off; Context: http, server, location, if in location Sample 以.html/htm结尾的文件过期时间为24小时 location ~ .*\.(htm|html)$ { expires 24h; root /opt/app/code; } 5 跨域访问 浏览器禁止跨域的原因不安全容易出现CSRF攻击！ CSRF攻击是攻击者利用用户的身份操作用户帐户的一种攻击方式，通常使用Anti CSRF Token来防御CSRF攻击，同时要注意Token的保密性和随机性。 location / { add_header 'Access-Control-Allow-Origin' '*'; # * 允许所有站点跨域访问 add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' '*'; # GET,POST,PUT,DELETE,OPTIONS; * 指所有 proxy_pass http://localhost:8088; # proxy_redirect off ; index index.php index.html index.htm; } 配置Nginx 允许多个域名跨域访问 异常 No'Access-Control-Allow-Origin' header is present on the requested resourse.Origin 'http//localhost:8088' is therefore not allowed access. 解决 map $http_origin $corsHost { default 0; "~http://www.haibakeji.com" http://www.haibakeji.com; "~http://m.haibakeji.com" http://m.haibakeji.com; "~http://wap.haibakeji.com" http://wap.haibakeji.com; } server { listen 80; server_name www.haibakeji.com; root /nginx; location / { add_header Access-Control-Allow-Origin $corsHost; } } 6 防盗链接 ngx_http_referer_module 原因： 1. 防止资源被盗用，2. 防止非法抓取资源导致网站卡顿； http_refer Syntax: valid_referers none | blocked | server_names | string ...; Context: server, location 请求头为指定值时， 内嵌变量$invalid_referer被设置为空字符串， 否则这个变量会被置成“1”。查找匹配时不区分大小写。 blocked：“Referer” 请求头存在，但是它的值被防火墙或者代理服务器删除；这些值都不以“http://” 或者 “https://”字符串作为开头； none：缺少“Referer”请求头； server_names：“Referer” 请求头包含某个虚拟主机名； 正则表达式：必须以“~”符号作为开头。 需要注意的是表达式会从“http://”或者“https://”之后的文本开始匹配。 Sample location ~ .*.(jpg|gif|png)$ { # 允许那些referers信息进行访问 # ndne 允许没有带referer信息的过来 # blocked 允许没有带协议信息，如http的 # ~/google\./ #所有 ~/google\./过来的 valid_referers none blocked 116.62.103.228 ~/google\./; if ($invalid_referer){ return 403; } } 利用nginx“ngx_http_referer_module”模块设置防盗链 Nginx作为代理服务 ngx_http_proxy_module nginx 支持的代理类型 代理分为正向代理和反向代理 fx_proxy.conf 模板设置 server{ listen 80; server_name locahost jeson.t.imooc.io; location / { proxy_pass http://127.0.0.1:8080; proxy_redirect default; #访问日志配置， 传递真的地址给proxy，而不是当前nginx proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_connect_timeout 30; #30s proxy_send_timeout 60; proxy_read_timeout 60; proxy_buffer_size 32k; proxy_buffering on; proxy_buffers 4 128k; proxy_busy_buffers_size 256k; proxy_max_temp_file_size 256k; #config时指定 --http-proxy-temp-path= #当出现一下异常是启用下一个 upstream proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; } } 文件形式导入 location { include proxy_params; } proxy_params; proxy_redirect default; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_connect_timeout 30; #30s proxy_send_timeout 60; proxy_read_timeout 60; proxy_buffer_size 32k; proxy_buffering on; proxy_buffers 4 128k; proxy_busy_buffers_size 256k; proxy_max_temp_file_size 256k; #config时指定 --http-proxy-temp-path= 转发路径规则真实请求路径http://localhost/online/wxapi/test/loginSwitch 第一种：proxy_pass 结尾有/ location /online/wxapi/ { proxy_pass http://localhost:8080/; #转发不代 location 路径 } 代理结果：http://localhost:8080/test/loginSwitch 第二种：proxy_pass 结尾没有/ location /online/wxapi/ { proxy_pass http://localhost:8080;#转发代 location 路径 } 代理结果：http://localhost:8080/online/wxapi/test/loginSwitch 第三种：proxy_pass 结尾有/web location /online/wxapi/ { proxy_pass http://localhost:8080/web;#转发location路径,直接拼接，不带`/`分割符 } 代理结果：http://localhost:8080/webtest/loginSwitch 第二种：proxy_pass 结尾没有/web/ location /online/wxapi/ { proxy_pass http://localhost:8080/web/;#转发代 location 路径 } 代理结果：http://localhost:8080/web/test/loginSwitch 实战location ^~ /static/ { #不传 static # curl http://localhost:3000/static/index.html # proxy_pass 转发为 http://www.test.com/index.html proxy_pass http://www.test.com/; #传 static # curl http://localhost:3000/static/index.html # proxy_pass 转发为 http://www.test.com/static/index.html proxy_pass http://www.test.com; } location /forum { #http://node1.qiuyue.com/forum -> http://192.168.1.144/bbs proxy_pass http://192.168.1.144/bbs; index index.html index.html; } #jpg、png或者gif结尾的请求反代 location ~* \.(jpg|png|gif)$ { proxy_pass http://192.168.1.144; } Nginx作为负载均衡服务 ngx_http_upstream_module 按区域可分为GSLB，SLB Example Configuration upstream backend { ip_hash; #调度方式 hash server backend1.example.com weight=5; server backend2.example.com:8080 max_fails=3 fail_timeout=30s;; server unix:/tmp/backend3 backup; server backup1.example.com:8080 backup; server backup2.example.com:8080 backup; } server { location / { proxy_pass http://backend; } } 调度算法 ip_hash 有代理问题 upstream imooc { hash $request_url; #可以提取URL指定位置进行hash } Nginx作为缓存服务proxy_cache_path /opt/app/cache levels=1:2 keys_zone=imooc_cache:10m max_size=10g inactive=7d max_size=10g use_temp_path=off; proxy_cache_path keys_zone = 1m # 1m可以存储8000个 inactive = 60m# 60分钟内不访问就把他清除掉 use_temp_path = off; #关闭零时文件存储，开启同时和 cache_path 使用可能会产生性能损耗 location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_cache imooc_cache; proxy_cache_valid 200 304 12h; #头部为返回为200 304 12小时过期 proxy_cache_valid any 10m; #其他的10m过期 proxy_cache_key $host$uri$is_args$args; add_header Nginx-Cache "&upstream_cache_status"; #查看缓存使用状态 Miss 未使用， HIT使用 #当出现一下异常是启用下一个 upstream proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; } 清理指定缓存ngx_cache_purge 安装ngx_cache_purge module块 cd /tmp wget http://labs.frickle.com/files/ngx_cache_purge-2.3.tar.gz tar -xf ngx_cache_purge-2.3.tar.gz dso_tool --add-module=/tmp/ngx_cache_purge-2.3 nginx.conf 配置 dso { load ngx_cache_purge_module.so; } location ~ /purge(/.*) { allow 192.168.1.0/24; deny all; proxy_cache_purge mycache $host$1$is_args$args; access_log off; } 清理缓存 如果要清理http://node1.qiuyue.com/bbs/index.html的缓存，则访问http://node1.qiuyue.com/purge/bbs/index.html即 让部分页面不缓存Systax: proxy_on_cache string ... Context: http,server,location Sample server { #检测url是否已不缓存的页面 if($request_url ~ ^/(url3|login|register|password\/reset)){ set $cookie_nocache 1; #设置变量的值 } location / { proxy_no_cache $cookie_nocache $arg_nocache $arg_comment; proxy_no_cache $http_pragma $http_authorization; } } 大文件分片请求http_slice_module Systax: slice size; Context: http,server,location 分析优势： 每个子请求收到的数据都会形成一个独立的文件，一个请求断了，其他请求不收影响 劣势： 当文件很大或者slice很小的时候，可能会导致文件描述符耗尽等情况 –with-http_slice_module http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; proxy_cache_path /tmp/nginx/cache levels=1:2 keys_zone=cache:100m; server { listen 8087; server_name localhost; location / { slice 1m; proxy_cache cache; proxy_cache_key $uri$is_args$args$slice_range; proxy_set_header Range $slice_range; proxy_cache_valid 200 206 1h; #proxy_set_header Range $http_range; proxy_pass http://127.0.0.1:8080; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 该模块用在 proxy_cache 大文件的场景，将大文件切片缓存 编译时对 configure 加上 –with-http_slice_module 参数 $slice_range 一定要加到 proxy_cache_key 中，并使用 proxy_set_header 将其作为 Range 头传递给后端 要根据文件大小合理设置 slice 大小 参考：Nginx 切片模块、断点续传 Nginx动静分离nginx分离JSP给Tomcat， jpg,png直接用静态资源 第四章 深度学习篇Nginx简单的语法Nginx 变量 Nginx 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰; 一个请求在其处理过程中，即使经历多个不同的 location 配置块，它使用的还是同一套 Nginx 变量的副本,Nginx 变量值容器的生命期是与当前正在处理的请求绑定的，而与 location无关。 Nginx 内建变变量 Embedded Variables ， 有由 Nginx 核心和各个 Nginx 模块提供的“预定义变量”，或者说“内建变量”（builtin variables）。常用的内键变量请查看附录二，Nginx全局变量解析 $arg_XXX 变量群，大部分arg_xxx变量是只读的，尝试修改会报一些奇特的异常$arg_name 案例 location /test { echo "name: $arg_name"; echo "class: $arg_class"; } 请求/test接口 $ curl 'http://localhost:8080/test' name: class: $ curl 'http://localhost:8080/test?name=Tom&class=3' name: Tom class: 3 $ curl 'http://localhost:8080/test?name=hello%20world&class=9' name: hello%20world class: 9 $arg_name 不仅可以匹配 name 参数，也可以匹配 NAME 参数，抑或是 Name，等等 $ curl 'http://localhost:8080/test?NAME=Marry' name: Marry class: $ curl 'http://localhost:8080/test?Name=Jimmy' name: Jimmy class: 对hello%20world进行解码,使用第三方 ngx_set_misc 模块提供 location /test { set_unescape_uri $name $arg_name; set_unescape_uri $class $arg_class; echo "name: $name"; echo "class: $class"; } 测试效果 $ curl 'http://localhost:8080/test?name=hello%20world&class=9' name: hello world class: 9 类 $arg_XXX 的内建变量群，比如用来取 cookie 值的 $cookie_XXX 变量群，用来取请求头的 $http_XXX 变量群，以及用来取响应头的 $sent_http_XXX 变量群，参考 ngx_http_core 模块的官方文档。 Perl兼容正则表达式 .：匹配除换行符\n以外的任意单个字符 ?：匹配之前的字符0次或1次 +：匹配之前的字符至少1次 *：匹配之前的字符任意次 \d：匹配数字 ^：匹配字符串的开始 $：匹配字符串的结尾 {m}：重复m次 {m,}：重复至少m次 {m,n}：重复至少m次，最多n次 [a]：匹配单个字符a [a-z]：匹配a-z小写字母中的任意一个 [^ ]：匹配任何不包括在指定字符集内的任意字符 |：匹配 | 之前或之后的部分 ()：分组，组成一组用于匹配的实体，通常配合 | 使用。小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容 深入学习参考 正则表达式30分钟入门教程 #localhost:8080/abc/qwe/asd location ~/abc/(.*)/(.*) { set $para1 $1; # qwe set $para2 $2;# asd } $1|$2|$3 ...是nginx在匹配正则时生成的变量，用于捕获一个正则表达式括号中匹配的字符串（从左到右依次存储在$1|$2|$3 ...中），新值覆盖旧值。 if(条件) {…} if(b), b是空或者任务以0开头的字符串，条件为false 比较内容，用= 或!= 检测文件或目录 -f和!-f用来判断文件是否存在 -d和!-d用来判断目录是否存在 -e和!-e用来判断文件和目录是否存在 -x和!-x用来判断文件是否可执行 if(!-f $request_filename){ #如果文件不存在重定向到百度 rewrite ^/(.*)$ http://www.baidu.com/$1 redirect; } 正则表达式匹配： ==:等值比较; ~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写； ~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写； !~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写； !~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写； 实战案例浏览器实现分离 # 禁止使用curl命令下载文件 if ($http_user_agent ~ curl) { return 403; } # 浏览器实现分离 if ($http_user_agent ~ Firefox){ rewrite ^/(.*)$ /firefox/$1 break; } if ($http_user_agent ~ MSIE){ rewrite ^/(.*)$ /msie/$1 break; } if ($http_user_agent ~ Edge){ rewrite ^/(.*)$ /edge/$1 break; } if ($http_user_agent ~ Chrome){ rewrite ^/(.*)$ /chrome/$1 break; } 浏览器分离的效果 例如： 用chrome访问 http://192.168.1.222/index.html 会访问 /usr/local/tengine/html/chrome/index.html # echo "Firefox html" > /usr/local/tengine/html/firefox/index.html # echo "MSIE html" > /usr/local/tengine/html/msie/index.html # echo "Edge html" > /usr/local/tengine/html/edge/index.html # echo "Chrome html" > /usr/local/tengine/html/chrome/index.html 网站更新，原服务跳转到停服提示，公司内部IP可以访问 set $my_ip ''; if ( $remote_addr = 222.222.222.222){set $my_ip 1;} #注意这里的$remote_addr如何用了负载均衡的话,这里应该是$http_x_forwarded_for if ( $remote_addr = 192.168.1.170 ){ set $my_ip 1;} if ( $remote_addr = 192.168.1.169 ){ set $my_ip 1;} if ( $my_ip != 1) {rewrite ^/design/(.*)\.php$ /tingfu.html?$1&;} #将*.php转到tingfu.html 只允许指定IP访问，其他IP跳转到指定页面 set $test ''; if ( $request_uri ~* /img/test.php ) { set $test P; } if ( $http_x_forwarded_for !~* ^222\.222\.222\.222.* ) { set $test "${test}C"; } if ( $test = PC ) { #当条件符合 访问test.php并且 ip不是222.222.222.222的 转发到55555.php rewrite ^(.*)$ /img/55555.php permanent; } Location使用详解 参考 nginx location指令详解 基本语法： location [=|~|~\*|^~|@] pattern{……}** 没有修饰符 表示：必须以指定模式开始 =表示：必须与指定的模式精确匹配 ~ 表示：指定的正则表达式要区分大小写 ~ \.(txt|css)$ 匹配所有以txt和css结尾的请求 区分大小写 ~* 表示：指定的正则表达式不区分大小写 ^~ 类似于无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配，那么就停止搜索其他模式了。 @ ：定义命名location区段，这些区段客户段不能访问，只可以由内部产生的请求来访问，如try_files或error_page等 优先级 “=” &gt; “^~” &gt; “~” 或“~*” &gt; “/ ” location块中未设置root时，会取外层（server块）的root，但server.root明显不是先生成字符串然后赋值给location.root，而是直接把模板串交给location.root。 Rewrite规则 CentOS 7.4 Tengine安装配置详解（四） 配置语法 Syntax: rewrite regex replacement [falg]; Context: server, location , if 四种flag标志位 last：执行该rewrite规则后，停止处理后续的rewrite指令集，对于重写后的URL会重新匹配location break：执行该rewrite规则后，停止处理后续的rewrite指令集，不再进行location匹配 redirect：重写完成之后会返回客户端302状态响应码（临时重定向），地址栏会显示跳转后的地址 permanent：重写完成之后会返回客户端301（永久重定向），地址栏会显示跳转后的地址 Sample01 default location /aaa.html { rewrite "^/aaa.html$" /bbb.html; # 先走rewrite 才 location rewrite "^/bbb.html$" /ddd.html; } location /bbb.html { rewrite "^/bbb.html$" /ccc.html; } 创建测试内容： # echo "aaa html" > /usr/local/tengine/html/aaa.html # echo "bbb html" > /usr/local/tengine/html/bbb.html # echo "ccc html" > /usr/local/tengine/html/ccc.html # echo "ddd html" > /usr/local/tengine/html/ddd.html 测试结果 curl http://localhost/aaa.html –&gt; ddd.html Sample02 last location /aaa.html { rewrite "^/aaa.html$" /bbb.html last; # 不会往下rewrite ,走下面的location匹配 rewrite "^/bbb.html$" /ddd.html; } location /bbb.html { rewrite "^/bbb.html$" /ccc.html; } 测试： curl http://localhost/aaa.html ==&gt; ccc.html 解析： aaa.html –&gt; bbb.html –&gt; 由于flag为last，所以不会将bbb.html –&gt; ddd.html –&gt; 重新匹配bbb.html –&gt; ccc.html Sample03 break location /aaa.html { rewrite "^/aaa.html$" /bbb.html break; # 不向下rewrite 及location rewrite "^/bbb.html$" /ddd.html; } location /bbb.html { rewrite "^/bbb.html$" /ccc.html; } 测试： curl http://localhost/aaa.html –&gt; bbb.html 解析：aaa.html –&gt; bbb.html –&gt; 由于flag为break，所以不再进行location匹配 Sample04 首先执行server段内的rewrite指令 rewrite "^/aaa.html$" /bbb.html; location /ccc.html { rewrite "^/ccc.html$" /eee.html; } location /bbb.html { rewrite "^/bbb.html$" /ccc.html; rewrite "^/ccc.html$" /ddd.html; } curl http://localhost/aaa.html –&gt; ddd.html Sample 05 先把server段的rewrite弄完，然后才location rewrite "^/aaa.html$" /bbb.html; rewrite "^/ccc.html$" /ddd.html; location /bbb.html { rewrite "^/bbb.html$" /ccc.html; } location /ddd.html { rewrite "^/ddd.html$" /eee.html; } 测试： curl http://localhost/aaa.html –&gt; ccc.html 实战案例浏览器分离 #http://192.168.1.222/index.html -> /usr/local/tengine/html/msie/index.html if ($http_user_agent ~ MSIE){ rewrite ^/(.*)$ /msie/$1 break; } #http://192.168.1.222/index.html -> /usr/local/tengine/html/edge/index.html if ($http_user_agent ~ Edge){ rewrite ^/(.*)$ /edge/$1 break; } 自动跳转到, http://blog.qiuyue.com时自动跳转到http://www.qiuyue.com/blog server { listen 80; server_name blog.qiuyue.com; rewrite ^/(.*)$ http://www.qiuyue.com/blog/$1 permanent; location / { root html/blog; index index.html index.html; } } server { listen 80; server_name www.qiuyue.com; location / { root html/www; index index.html index.html; } } http://www.qiuyue.com/bbs时自动跳转到http://bbs.qiuyue.com server { listen 80; server_name www.qiuyue.com; rewrite ^/bbs/(.*)$ http://bbs.qiuyue.com/$1 permanent; location / { root html/www; index index.html index.html; } } 优雅的Rewrite规则书写自己写的 server { listen 80; server_name www.nginx.org nginx.org; if($htpp_host = nginx.org){ rewrite (.*) http://www.nginx.org$1; } } 官方推荐写法 server { listen 80; server_name nginx.org; rewrite ^ http://www.nginx.org$request_url?; #只用一行，并且书写美观 } server { listen 80; server_name www.nginx.org; } Nginx 高级模块secure_link_module模块 ngx_http_secure_link_module 注意作用： 制定并允许检查请求的连接的真实性以及保护资源免遭未经授权的访问； 限制连接生效周期； 配置enabled with the --with-http_secure_link_module 语法 Syntax: secure_link expression; Context: http, server, location Syntax: secure_link_md5 expression; Context: http, server, location Samplelocation /s/ { secure_link $arg_md5,$arg_expires; secure_link_md5 "$secure_link_expires$uri$remote_addr secret"; if ($secure_link = "") { return 403; } if ($secure_link = "0") { return 410; } } md5url.sh 生成安全连接 #!/bin/sh # #Auth:zhilinchn@126.com servername="zhilinchn.com" download_file="/dowload/file.img" time_num=$(date -d "2019-10-16 00:00:00" +%s) secret_num="secret" #记得和服务端 secret对应 res=$(echo -n "${time_num}${download_file} ${secret_num}" | openssl md5 -binary | openssl base64 | tr +/ -_ | tr -d =) echo "http://${servername}${download_file}?md5=${res}&expires=${time_num}" source md5url.sh 进行访问 http://zhilinchn.com/dowload/file.img?md5=FFhZt0XJo7ed_X973FsRgA&expires=1571155200 geoip_module 模块 ngx_http_geoip_module 基于IP地址MaxMind GeoIP 二进制文件，读取IP所在地域信息。 yum install nginx-module-geoip 使用场景 区别国内国外作HTTP访问规则 区别国内城市地域HTTP访问规则 ngx-fancyindex 实现索引目录 实现索引目录（适用于下载站）tengine 下载ngx-fancyindex yum -y install git \ cd /tmp \ git clone https://github.com/aperezdc/ngx-fancyindex.git ngx-fancyindex 使用Tengine的dso_tool工具编译第三方模块： dso_tool -h #help dso_tool --add-module=/tmp/ngx-fancyindex ls /usr/local/tengine/modules | grep fancyindex --> ngx_http_fancyindex_module.so 添加events 配置 dso { load ngx_http_fancyindex_module.so; } server 设置 location /software { root /download; fancyindex on; # 启用fancy目录索引功能 fancyindex_exact_size off; # 不显示文件的精确大小，而是四舍五入，单位是KB、MB和GB fancyindex_localtime on; # 默认为off，显示的是GMT时间，改为on，显示的是服务器时间 } 重载后测试 访问到测试 检测模块是否加载成功 nginx -m –&gt; ngx_http_fancyindex_module (shared, 3.1) 基于Nginx的HTTPS服务自建CA服务器创建私有CA 安装相关软件包,生成私钥 yum -y install openssl openssh-clients #创建保存证书信息的数据库文件 touch /etc/pki/CA/index.txt #保存证书序列号的文件 echo 01 > /etc/pki/CA/serial #生成私钥cakey.pem (umask 077; openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048) 备注： genrsa：用于生成RSA密钥对的OpenSSL子命令 (man genrsa) -out cakey.pem 指定私钥保存位置 2048 密钥长度 生成CA证书cacert.pem cd /etc/pki/CA openssl req -new -x509 -key private/cakey.pem -days 7300 -out cacert.pem 输入信息 Country Name (2 letter code) [XX]:cn State or Province Name (full name) []:guangdong Locality Name (eg, city) [Default City]:shenzhen Organization Name (eg, company) [Default Company Ltd]:TX Organizational Unit Name (eg, section) []:DEV Common Name (eg, your name or your server's hostname) []:ca.vhosts.com #证书颁发者 Email Address []:zhilinchn@126.com 备注： req子命令常用选项（man req）-new：生成新证书签署请求-x509：专用于CA生成自签证书-key cakey.pem：生成CA证书请求时用到的私钥 -days 7300：证书的有效期限为20年-out cacert.pem：证书的保存路径 参考 【Nginx】Nginx配置SSL证书 Nginx 与Lua开发Nginx与Lua特性与优势 Lua 是一个简洁、轻量、可扩展的脚本语言。Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数。Lua由标准C编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择 Nginx+ Lua的优势充分结合Nginx的并发处理epoll优势和Lua的轻量级实现简单的功能提高高并发场景。 统计用户IP； 统计用户的访问次数； 安全功能 Lua 基础语法 安装lua解析器 yum install lua run Hello World terminal input lua print(&quot;Hello World!&quot;) script：test.lua , chmod a+x text.lua ./test.lua #!/usr/bin/lua print("Hello World!") 注释 -- 单行注释 --[[ 多行注释 多行注释 --]] lua的数据类型布尔类型只有nil和false， 数字，空字符串（’\0‘）都是true 变量 a = 5 -- 全局变量 local b = 5 -- 局部变量 function joke() c = 5 -- 全局变量 local d = 6 -- 局部变量 end joke() print(c,d) --> 5 nil do local a = 6 -- 局部变量 b = 6 -- 对局部变量重新赋值 print(a,b); --> 6 6 end print(a,b) --> 5 6 while循环 sum = 0 num = 1 while num &lt;=100 do sum = sum + num -- 不支持 num++ num = num +1 end print("sum=",sum) for循环 sum=0 for i=1,100 do sum = sum +i end if-else 判断语句 if age == 40 and sex == "Male" then print("大于40男人") -- ~= 不等于 elseif age > 60 and sex ~= "Female" then print("非女人而且大于60") else -- 从屏幕终端读取 local age = io.read() -- .. 字符拼接 print("Your age is "..age) end Nginx + lua 环境 LuaJIT ngx_devel_kit 和lua-nginx-module 重新编译 参考 http://www.imooc.com/article/19597 容器化，参考附录二 Nginx 调用lua模块指令 Nginx lua API 比较全的API总结 ngx_lua 模块 location /hello { default_type 'text/plain'; content_by_lua 'ngx.say("hello, lua")'; } location /myip { default_type 'text/plain'; content_by_lua 'ngx.req.get_headers()["x_forward_for"] ngx.say("IP",clientIP)' } location / { default_type 'text/plain'; content_by_lua_file0 /opt/app/lua/dep.lua; #调用lua脚本 } 实战-灰度发布Nginx + Lua + Memcache基于IP实现灰度发布 dep.lua -- 取到用户IP clientIP = ngx.req.get_headers()["X-Real-IP"] if clientIP == nil then clientIP = ngx.req.get_headers()["x_forwarded_for"] end if clientIP == nill then clientIP == ngx.var.remote_addr end local memcached = require "resty.memcached" local memc, err = memcached:new() if not memc then ngx.say("failed to instantiate memc:",err) return end local ok,err = memc:connect("127.0.0.1",11211) if not ok then ngx.say("failed to connect:",err) return end local res, flags, err = memc:get(clientIP) ngx.say("value key:",res,clientIP) if err then ngx.say("failed to get clientIP ", err) return end if res == "1" then 第五章 Nginx架构篇常见问题 多个server_name 的优先级 多个Location优先级 try_files使用 alias 和root区别 获取用户真实IP Nginx常见的错误 性能优化Apache ab 压测试工具安装 sudo yum install httpd-tools 使用 # -n 发送100次 -c 并发10 ab -n 100 -c 10 [http[s]://]hostname[:port]/path #-p post 方式 -T 数据格式 #post_wecaht.txt = {"send_type":"email", "to":"yanyongwen@xiaoniu66.com", "content":"parallel test"} ab -n 100 -c 10 -p post_wechat.txt -T application/json [http[s]://]hostname[:port]/path #-H headers ab -n 1000 -c 200 -p post.txt -H 'X-Custom-Header':'xxxx' -H 'OS-TYPE':'linux' -T application/json http://localhost:9090/hardware # -k 是否开启长连接 结果分析 Server Software: Microsoft-HTTPAPI/2.0 Server Hostname: 192.168.0.10 Server Port: 80 Document Path: / Document Length: 315 bytes HTTP响应数据的正文长度 Concurrency Level: 800 Time taken for tests: 0.914 seconds 所有这些请求处理完成所花费的时间 Complete requests: 800 完成请求数 Failed requests: 0 失败请求数 Write errors: 0 Non-2xx responses: 800 # 有多少个非200的请求 Total transferred: 393600 bytes 网络总传输量 HTML transferred: 252000 bytes HTML内容传输量 Requests per second: 875.22 [#/sec] (mean) 吞吐量-每秒请求数 Time per request: 914.052 [ms] (mean) 服务器收到请求，响应页面要花费的时间 Time per request: 1.143 [ms] (mean, across all concurrent requests) 并发的每个请求平均消耗时间 Transfer rate: 420.52 [Kbytes/sec] received 平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题 网络上消耗的时间的分解： Connection Times (ms) min mean[+/-sd] median max Connect: 0 1 0.5 1 3 Processing: 245 534 125.2 570 682 Waiting: 11 386 189.1 409 669 Total: 246 535 125.0 571 684 整个场景中所有请求的响应情况。在场景中每个请求都有一个响应时间 其中 50％ 的用户响应时间小于 571 毫秒 80 ％ 的用户响应时间小于 652 毫秒 最大的响应时间小于 684 毫秒 系统和Nginx性能优化文件句柄设置CPU亲和性设置Nginx通用配置优化Nginx安全恶意行为控制手段攻击手段之暴力破解文件上传漏洞SQL注入Nginx + lua 防火墙功能复杂访问攻击中CC攻击方式1. 调试1.1 查看nginx的状态信息 需要编译时安装http_stub_status_module 及config –with-http_stub_status_module location /status { stub_status on; allow 192.168.101.120; deny all; access_log off; } 访问http://192.168.1.222/status 状态说明 Active connections：当前活动的客户端连接数 accepts：已经接收过的客户端连接总数 handled：已经处理过的客户端连接总数 requests：客户端的请求总数 request_time：请求时间 Reading：正在读取的客户端请求数 Writing：正在处理请求或发送响应报文的连接数 Waiting：等待发出请求的空闲连接数 注意：可以配合 基于用户名/密码实现访问控制进行密码校验 1.2 装载echo模块, 用于打印日志 下载echo-nginx-module： yum -y install git \ cd /tmp \ git clone https://github.com/openresty/echo-nginx-module.git 使用Tengine的dso_tool工具编译第三方模块： dso_tool --add-module=/tmp/echo-nginx-module ls /usr/local/tengine/modules | grep echo --> ngx_http_echo_module.so nginx 配置 events{ dso { load ngx_http_echo_module.so; } } server{ location /echo { default_type "text/plain"; # 不指定default_type，会提示下载文件，而非直接输出在浏览器中 echo "host --> $host"; # 请求主机头字段，否则为服务器名称 echo "server_name --> $server_name"; # 服务器名称 echo "server_addr --> $server_addr"; # 服务器IP地址 echo "remote_addr --> $remote_addr"; # 客户端IP地址 echo "uri --> $uri"; # 不带请求参数的当前URI，$uri不包含主机名 echo "document_uri --> $document_uri"; # 与$uri含义相同 echo "request_uri --> $request_uri"; # 带请求参数的原始URI，不包含主机名 echo "request_filename --> $request_filename"; # 当前请求的文件路径 echo "document_root --> $document_root"; # 当前请求在root指令中指定的值 } } 测试 nginx -m –&gt; ngx_http_echo_module (shared, 3.1) 访问的 http://www.qiuyue.com/echo Curl 使用查看一个完整的http请求 curl -v https://coding.imooc.com > /dev/null 测试正则表达式官网： https://www.pcre.org/ 安装 wget https://ftp.pcre.org/pub/pcre/pcre-8.13.tar.gz tar -xzvf pcre-8.13.tar.gz cd pcre-8.13 ./configure --enable-utf8 make && make intall 使用 pcre pcretest # 正则测试 Expresso 巨好用的正则工具 下载地址： http://www.ultrapico.com/ExpressoDownload.htm 使用返回值调试location /test/ { default_type application/json; return 200 '{"status":"success"}'; } 查看日志tail -f /usr/local/tengine/logs/access.log 第六章 新特性Nginx 平滑升级实现和原理HTTP2.0协议特性gRPC附录一参考资料 CentOS 7.4 Tengine安装配置详解（一） nginx正则相关变量$1,$2,$3使用注意 正则表达式30分钟入门教程 Nginx 变量漫谈（一） Nginx入门到实践－Nginx中间件 神级进阶博文Nginx 变量漫谈 Nginx 配置指令的执行顺序 官方文档https://nginx.org/en/docs/ ngx_http_core_module 参数官网文档 包含在http上下文内的所有参数解析 ngx_http_core_module ngx_http_log_module（日志模块）http://nginx.org/en/docs/http/ngx_http_log_module.html Embedded Variables （nginx 内置变量）Embedded Variables 附录二TengineTengine github documentation Nginx.conf 标准模板(Tengine) user tengine; # 运行worker进程的用户 worker_processes auto; # worker进程的个数，命令ps aux | grep nginx可查看启动的worker进程数量 worker_cpu_affinity auto; # 将worker进程绑定在哪些CPU上，减少由于上下文切换导致的CPU消耗 worker_rlimit_nofile 65535; # worker进程能够打开的最大文件数限制 error_log logs/error.log error; # 指定Tengine错误日志的存放路径和级别 pid logs/nginx.pid; # 指定Tengine进程的pid文件路径 google_perftools_profiles /tmp/tcmalloc; # tcmalloc保存路径，命令lsof -n | grep tcmalloc验证运行状态 events { accept_mutex on; # 让多个worker进程轮流地、序列化地响应新请求 multi_accept on; # 在Tengine接收到一个新连接通知后，调用accept()来接收尽可能多的连接 worker_connections 65535; # 单个worker进程所能响应的最大并发连接数 # 此处没有指定use epoll;指令，让Tengine自动选择合适的事件处理模型 } http { server_tokens off; # 隐藏Tengine版本号 include mime.types; # MIME是网络资源的媒体类型，使用include指令导入mime.types文件 default_type application/octet-stream; # 指定默认类型 # 自定义访问日志格式，名称为main，指定要保存的日志内容 # ==================================================== # $remote_addr与$http_x_forwarded_for含义相同：客户端的IP地址 # $remote_user：记录客户端用户名称 # $time_local：通用日志格式下的本地服务器时间 # $request：记录请求的URL与HTTP协议 # $status：响应状态码，成功是200 # $body_bytes_sent：发送给客户端HTTP响应的主体内容的字节数大小，不包括响应首部的大小 # $http_referer：记录从哪个页面链接访问过来的 # $http_user_agent：记录客户端浏览器相关信息 # ==================================================== log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log off; # 关闭访问日志，提高磁盘的I/O性能 sendfile on; # 开启高效文件传输模式，调用sendfile()进行数据复制，sendfile()复制数据是在内核级别完成的，所以会比一般的read()、write()更高效，sendfile()可以在磁盘和TCP socket之间互相拷贝数据 tcp_nopush on; # 开启后服务器的响应头部信息产生独立的数据包发送，即一个响应头信息一个包。在一个数据包里发送所有头文件，而不是一个接一个的发送，用于防止网络阻塞，必须先开启sendfile模式 keepalive_timeout 65; # 客户端keep-alive连接超时时长，服务器将在这个超时时长过后关闭连接，单位秒 charset UTF-8; # 定义头文件默认字符集 gzip on; # 采用gzip压缩形式发送数据，将页面压缩后传输更节省带宽 gzip_disable "msie6"; # IE6的浏览器禁用gzip功能 gzip_proxied any; # 指定对客户端请求的所有资源启用压缩功能 gzip_min_length 1k; # 指定对数据启用压缩的最少字节数，如果请求小于1K的文件，不要压缩，压缩小数据会降低处理此请求的所有进程速度 gzip_comp_level 6; # 指定数据的压缩等级，这个等级可以是1~9之间的任意数值，1压缩比最小但处理速度最快，9处理最慢但压缩比最大，CPU消耗也越大 gzip_buffers 16 8k; # 指定压缩响应的缓冲区的数量和大小 gzip_vary on; # 允许把"Vary: Accept-Encoding"插入响应首部 gzip_http_version 1.1; # 指定识别HTTP协议版本，默认是1.1 gzip_types text/plain text/css text/xml text/javascript application/json application/x-javascript application/xml application/xml+rss; # 指定需要压缩的资源类型 reset_timedout_connection on; # 关闭不响应的客户端连接，释放客户端所占的内存空间 client_body_buffer_size 8k; # 指定用于读取客户端请求主体的缓冲区大小 client_header_buffer_size 1k; # 指定用于读取客户端请求首部的缓冲区大小 large_client_header_buffers 4 8k; # 指定用于读取客户端请求中较大首部的缓冲区的最大数量和大小 client_max_body_size 1m; # 指定用于客户端请求主体的最大大小 client_header_timeout 30s; # 指定用于读取客户端请求报文首部的超时时长，单位秒 client_body_timeout 30s; # 指定用于读取客户端请求报文主体的超时时长，单位秒 send_timeout 30s; # 指定用于向客户端发送响应报文的超时时长，单位秒 } Nginx + Lua 环境容器化脚本Dockerfile FROM centos:latest MAINTAINER becivells RUN yum -y update && yum -y upgrade RUN yum -y install gcc gcc-c+ openssl openssl-devel pcre-devel zlib-devel make wget ENV TENGINE_VERSION tengine-2.2.3 RUN cd /tmp/ && wget http://tengine.taobao.org/download/${TENGINE_VERSION}.tar.gz &&\ tar -zxvf ${TENGINE_VERSION}.tar.gz -C /tmp/ && chmod -R 777 /tmp/${TENGINE_VERSION} #mkdir RUN mkdir -p /var/tmp/nginx/client/ &&\ mkdir -p /var/tmp/nginx/proxy/ &&\ mkdir -p /var/tmp/nginx/fcgi/ &&\ mkdir -p /var/tmp/nginx/uwsgi/ &&\ mkdir -p /var/tmp/nginx/scgi/ #./configure #LuaJIT RUN cd /tmp/ && wget http://luajit.org/download/LuaJIT-2.0.4.tar.gz && \ tar xzvf LuaJIT-2.0.4.tar.gz && \ cd LuaJIT-2.0.4 && \ make install PREFIX=/usr/local/LuaJIT ENV LUAJIT_LIB=/usr/local/LuaJIT/lib ENV LUAJIT_INC=/usr/local/LuaJIT/include/luajit-2.0 RUN cd /tmp/ && wget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz && \ tar -xzvf v0.3.0.tar.gz && \ wget https://github.com/openresty/lua-nginx-module/archive/v0.10.8.tar.gz && \ tar -xzvf v0.10.8.tar.gz RUN cd /tmp/${TENGINE_VERSION} && ./configure \ --prefix=/opt/${TENGINE_VERSION}/ \ #--sbin-path=/usr/sbin/nginx \ #--modules-path=/usr/lib64/nginx/modules \ #--conf-path=/etc/nginx/nginx.conf \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --pid-path=/var/run/nginx/nginx.pid \ --lock-path=/var/lock/nginx.lock \ --http-client-body-temp-path=/var/tmp/nginx/client/ \ --http-proxy-temp-path=/var/tmp/nginx/proxy/ \ --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \ --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \ --with-file-aio \ --with-http_addition_module \ --with-http_auth_request_module \ --with-http_dav_module \ --with-http_flv_module \ --with-http_gunzip_module \ --with-http_gzip_static_module \ --with-http_mp4_module \ --with-http_random_index_module \ --with-http_realip_module \ --with-http_secure_link_module \ --with-http_slice_module \ --with-http_ssl_module \ --with-http_stub_status_module \ --with-http_sub_module \ --with-mail \ --with-mail_ssl_module \ --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong \ --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' \ --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie' \ --add-module=/tmp/lua-nginx-module-0.10.8 \ --add-module=/tmp/ngx_devel_kit-0.3.0 \ --with-pcre &&\ cd /tmp/${TENGINE_VERSION} && make -j 4 && make install && \ rm -rf /tmp/* && yum clean all && \ ln -s /opt/${TENGINE_VERSION}/ /opt/tengine && \ echo "/usr/local/LuaJIT/lib" >> /etc/ld.so.conf && \ ldconfig EXPOSE 80 CMD ["/opt/tengine/sbin/nginx", "-g", "daemon off;"] 使用方式 #构建容器 docker build -t centos:tengine . #指定81端口运行 docker run --rm -p 81:80 centos:tengine #进入centos:tengine terminal 终端 docker exec -it /bin/bash 测试 location /hello { default_type 'text/plain'; content_by_lua 'ngx.say("hello, lua")'; } Nginx全局变量解析$content_length：http请求头中的Content-length字段 $content_type：http请求头中的Content-Type字段 $document_root：当前请求在root指令中指定的值 $host：请求主机头字段，如果请求中没有Host行，则为服务器名称 $http_user_agent：客户端agent信息 $http_cookie：客户端cookie信息 $limit_rate：限制连接速率 $request_method：客户端请求方法，通常为GET或POST $remote_addr：客户端IP地址 $remote_port：客户端端口 $remote_user：已经经过Auth Basic Module验证的用户名 $request_filename：当前请求的文件路径，由root或alias指令与URL请求生成 $scheme：请求使用的协议，比如http或者是https $server_protocol：请求使用的协议版本，通常是HTTP/1.0或HTTP/1.1 $server_addr：服务器地址，在完成一次系统调用后可以确定这个值 $server_name：服务器名称 $server_port：请求到达服务器的端口号 $request_uri：包含请求参数的原始URL，不包含主机名，如：/foo/bar.php?arg=baz $uri：不带请求参数的当前URL，$uri不包含主机名，如：/foo/bar.html $document_uri：与$uri相同 使用过程中的问题列表window conf 文件加载无效原因是 nginx 在后台启动多个实例导致无法更新到当前使用的实例(在任务列表中可以找到多个nginx实例) 解决：关闭所有nginx.exe, 重新启动 taskkill /IM nginx.exe /F 增加别名缓存错误提示： could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 解决方案： http{ server_names_hash_bucket_size 64; #必须是32的倍数 } 413 request entity too largeNginx设置上传文件大小限制 location ^~ /api/media/ { proxy_pass http://media_server_pool/media/; client_max_body_size 2000m; }]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习笔记]]></title>
    <url>%2F2019%2F04%2F14%2F2019-4-17-database%2F</url>
    <content type="text"><![CDATA[实战备份项目腕带信息上传-- 创建视图 create view v_watch_recoder_msg as select r.id ,r.err as code, m.msg as msg, r.imei, an.name, r.time as upload_time from t_watch_recoder r,t_code_msg m, T_RUNAN_IMEI an where m.code = r.ERR and m.type='status' and r.imei = an.imei ORDER BY r.time DESC create view v_alert_record_msg as select t.id, t.type,msg.msg, t.imei,t.time from t_alert_record t, t_code_msg msg where msg.type='alert' and msg.code = t.type order by t.time desc]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记]]></title>
    <url>%2F2019%2F04%2F14%2F2019-4-14-Docker-note%2F</url>
    <content type="text"><![CDATA[Containerdocker build --tag=friendlyhello . #or add version docker build -tag= friendlyhello:v0.0.1 . docker image ls docker run -p 4000:80 friendlyhello Docker for Linux network set Set proxy server, replace host:port with values for your servers ENV http_proxy host:port ENV https_proxy host:port docker dns set /etc/docker/daemon.json { "dns": ["your_dns_address", "8.8.8.8"] } sudo service docker restart On Windows, explicitly stop the container CTRL+C can’t stop image use docker container ls docker container stop &lt;Container NAME or ID&gt; 容器的基本操作启动交互式容器 docker run -i -t IMAGE /bin/bash -i --interactive #true|false 默认是false Keep STDIN open even if not attached -t --tty=true|false 默认是false # 告诉容器创建一个伪tty终端 案例： docker安装ubuntu镜像 docker search ubuntu docker pull ubuntu docker images #运行镜像并指定名称和端口映射，返回容器id docker run -it -d --name ubuntu_test -p 8088:80 ubuntu #查看所有启动的容器 docker ps #根据上面id（前2个）查看容器信息 docker inspect 98 #进入镜像(或者把容器id改为容器名，也可以进入) #新建进程执行 docker exec -it 98 /bin/bash # 退出容器 exit #停止容器 docker stop id #删除容器 docker rm #制作docker镜像 docker commit 98 ubuntu_test1:1.0 #打包镜像并查看 docker save -o ubuntu_test1.tar ubuntu_test1:1.0 #交互的方式重新启动容器 docker start -i 守护式容器#使真正运行的容器后台运行 Ctrl+P Ctrl+Q # 后台启动容器 docker run -d #查看容器日志 docker logs #查看容器的进程 docker top #为运行中的容器启动新进程 docker exec # 停止一个运行中的容器 stop 等待容器正常停止，直接kill掉进程 docker stop/kill #使用Docker帮助文档 man docker-run man docker-logs man docker-top 完整的操作案例 #自定义容器名称 docker run --name dc -d ubuntu /bin/sh -c "while true;do echo hello world; sleep 1;done" #查看container信息 docker ps #进入后台运行的容器 docker attach id docker logs ` -f follow -t 时间 docker logs -tf --tail 10 container_name docker top container_name 设置容器的端口映射 docker run -p 80 --name web -it ubuntu /bin/bash #容器初始化之前需求 apt-get update 更新一下 apt-get install -y nginx apt-get install -y vim mkdir -p /var/www/html vim index.html whereis nginx vim /etc/nginx/sites-enabled/default root 改为 /var/www/html 位置 #查看niginx运行情况 ps -ef # 非docker环境下 docker port web # 80/tcp -> 0.0.0.0:32768 localhost：32768 直接访问 `每次重启容器的IP和端口号会变` 停止并且删除容器 docker container stop wildfly docker container rm wildfly 其他方式docker container rm -f wildfly 常用命令 #停止指定容器 docker container stop `docker container ps | grep wildfly | awk '{print $1}'` #删除所有运行的container docker container stop $(docker container ps -q) #删除所有container docker container rm $(docker container ps -aq) 镜像镜像信息查看命令docker info 能查看docker镜像存储位置 一般为/var/lib/dockerdocker system df 查看镜像、容器、数据卷所占用的空间docker image history jboss/wildfly 查看镜像更详细的信息 镜像的查看于删除docker images -a #all -f #filter --no-trunc #不使用阶段的形式 -q #只显示镜像的唯一id #列出仓库名为centos的所有镜像 docker images centos #查看镜像信息 docker inspect ubuntu:14.0 docker inspect #删除镜像 docker rmi -f --no-prune #Do not delete untagged parents #删除多个 docker rmi ubuntu:14.0 ubuntu:precise #删除ubuntu中的所有镜像 docker rmi $(docker images ubuntu -q) 官网案例 Share Image官网： https://hub.docker.com/ docker build -t friendlyhello . # Create image using this directory's Dockerfile docker run -p 4000:80 friendlyhello # Run "friendlyname" mapping port 4000 to 80 docker run -d -p 4000:80 friendlyhello # Same thing, but in detached mode docker run -it --rm ubuntu /bin/bash #退出后删除容器 docker container ls # List all running containers docker container ls -a # List all containers, even those not running docker container stop # Gracefully stop the specified container docker container kill # Force shutdown of the specified container docker container rm # Remove specified container from this machine docker container rm $(docker container ls -a -q) # Remove all containers docker image ls -a # List all images on this machine docker image rm # Remove specified image from this machine docker image rm $(docker image ls -a -q) # Remove all images from this machine docker login # Log in this CLI session using your Docker credentials docker tag username/repository:tag # Tag for upload to registry docker push username/repository:tag # Upload tagged image to registry docker run username/repository:tag # Run image from a registry 镜像的获取和推送Ubuntu 14.04、Debian 7 Wheezy docker search #镜像的拉取 docker pull #使用国内镜像 www.daocloud.io --registry-mirror # 1. 修改 /etc/default/docker # or 2. 添加 DOCKER_OPTS = "--registry-mirror=http://mirror-addr" sudo service docker restart #查看是否生效 docker info 镜像加速器 参考文档 常用国内镜像 Docker 官方提供的中国 registry mirror https://registry.docker-cn.com Docker 国内镜像库加速 阿里云加速器(需登录账号获取) 七牛云加速器 https://reg-mirror.qiniu.com/ Ubuntu 16.04+、Debian 8+、CentOS 7 修改/etc/docker/daemon.json { "registry-mirrors": ["https://yourcode.mirror.aliyuncs.com"] # "registry-mirrors": ["https://registry.docker-cn.com"] } 重启 $ sudo systemctl daemon-reload $ sudo systemctl restart docker 构建镜像与仓库 commit 在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像，尽量减少使用commit因为每次叠加，慎用 docker commit docker diff &lt;container_id&gt; 比较上一次修改了哪些文件 #Commit构建镜像 docker commit [OPTIONS] CONTAINER [REPOSITORY:[TAG]] -a, --author="Jobhn Hannibal Smith hannibal@a-team.com" -m, --message="" Commit message -p, --pause=true Pause container during comit # commit 指令会暂停容器，-p则不停止 案例commit 方式 docker run -it -p 80 --name comit_test ubuntu /bin/bash apt-get update apt-get install nginx exit docker ps -l docker commit -a 'Dockerlinz press' -m 'nigix' commit_test dockerlinz/commit_test1 docker images docker run -d --name nginx_web1 dockerlinz/commit_test1 nginx -g "daemon off;" #nginx 后台运行 # 发现没有映射端口 docker run -d --name nginx_web1 -p 80 dockerlinz/commit_test1 nginx -g "daemon off;" curl localhost:port DockerFile构建镜像DockerFile demo #First Dockerfile FROM ubuntu:14:04 MAINTAINER dormancypress "dormancypress@outlook.com" RUN apt-get update RUN apt-get install -y nginx EXPOSE 80 docker build docke docker build [OPTIONS] PATH | URL --force-rm --no-cache --pull -q # 不显示过程 --rm -t #TAG docker build -t="dockerlinz/df_test" docker run -d --name nginx_web1 -p 80 dockerlinz/df_test nginx -g "daemon off;" DockerFile指令vim ARG [=] # docker build --build-arg = #COPY [--chown=:] ... COPY package.json /usr/src/app/ COPY hom* /mydir/ #和copy类似带解压功能 ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / # MAINTAINER 包含镜像所有者和联系信息 MAINTAINER dormancypress "dormancypress@gmail.com" #ENV 设置环境变量 ENV ENV = =...\ = #USER 指定当前用户 USER [:] CMD的三种模式 #1. CMD ["exe","param1","param2"] （exec模式） #2. CMD ls -a (shell模式) CMD [ "sh", "-c", "echo $HOME" ] #3. CMD ["param1","param2"] (ENTRYPOINT 指令的默认参数) ENTRYPOINT 可以使用docker run --entrypoint覆盖 #1. ENTRYPOINT ["exe","param1","param2"] （exec模式） #2. ENTRYPOINT ls -a (shell模式) DockerFile 构建过程run image -&gt; exec cmd -&gt;commit-&gt; exec cmd -&gt; commit #调试具体步骤 构建DockerFile的时候可以运行中间层镜像，可以调试具体步骤 # 默认缓存，不缓存 docker build --no-cache # 局部缓存刷新，修改日期后下面的操作刷新缓存 ENV REFRESH_DATA 2019-1-30 # 显示一个镜像的构建过程 docker history Servicesdocker stack ls # List stacks or apps docker stack deploy -c # Run the specified Compose file docker service ls # List running services associated with an app docker service ps # List tasks associated with an app docker inspect # Inspect task or container docker container ls -q # List container IDs #docker stack ls docker stack rm # Tear down an application docker swarm leave --force # Take down a single node swarm from the manager #更新端口 docker service update --publish-rm 8080:5000 --publish-add 8088:5000 web #更新image docker service update --image xiaopeng163/python-flask-demo:2.0 web this node is not a swarm manager. Use “docker swarm init” or “docker swarm join” to connect this node to swarm and try again用：docker swarm init 解决 Remote API连接三种方式 unix:///var/run/docker.sock tcp://host:port fd://socketfd nc -U /var/run/docker.sock docker 守护进程配置和操作# 查看运行状态 ps -ef | grep docker sudo status docker # sudo service docker stop/start/restart # 与运行相关： docker -d [OPTIONS] -D #调试模式 -e,--exec-driver="native" #docker 运行的驱动 -l,--log-level="info" #日志级别 -g,--graph="/var/lib/docker" #目录 -p,--pidfile="/var/rundocker.pid" Docker服务器链接相关 -G,--group="docker" #用户组 -H,--host=[] --tls=false --tlscacert="/home/sven/.docker/ca.pem" --tlscert="/home/sven/.docker/cert.pem" --tlskey="/home/sven/.docker/key.pem" --tlsverify=false /etc/defalt/docker Swarmshttps://docs.docker.com/get-started/part4/ 常用命令docker stack deploy --compose-file=docker-compose.yml docker stack ls docker stack rm #初始化当前节点为manager docker swarm init --advertise-addr 192.168.99.100:2377 #获取加入manager的token docker swarm join-token manager #加入manager的集群 docker swarm join --token SWMTKN-1-2abs9211jijp6pmxc7b20v4vc6apbznnxgh48th36lxttud5ue-andtd5ira0z17ht6psxg9xo8j 192.168.208.137:2377 #强行退出swarm docker swarm leave --force docker node ls # 列出当前节点 docker-machinedocker-machine create --driver virtualbox myvm1 docker-machine create --driver virtualbox myvm2 docker-machine ls myvm1 - virtualbox Running tcp://192.168.99.100:2376 v17.06.2-ce myvm2 - virtualbox Running tcp://192.168.99.101:2376 v17.06.2-ce docker-machine ssh myvm1 "docker swarm init --advertise-addr 192.168.99.100:2377" docker-machine ssh myvm2 "docker swarm join \ --token \ :2377" docker-machine ssh myvm1 "docker node ls" Configuration docker-machinedocker-machine env myvm1 export DOCKER_TLS_VERIFY="1" export DOCKER_HOST="tcp://192.168.99.100:2376" export DOCKER_CERT_PATH="/Users/sam/.docker/machine/machines/myvm1" export DOCKER_MACHINE_NAME="myvm1" # Run this command to configure your shell: eval $(docker-machine env myvm1) eval $(docker-machine env -u) Deploy the app on the swarm managerdocker stack deploy -c docker-compose.yml getstartedlab docker stack rm getstartedlab swarm 连接数据库connection-url 连接 swarm: datasources: data-sources: ExampleDS: driver-name: mysql connection-url: jdbc:mysql://db:3306/employees user-name: mysql password: mysql jaeger: service-name: jaeger reporter-log-spans: true sampler-type: const sampler-parameter: 1 agent-host: jaeger opentracing: servlet: skipPattern: /metrics 通过镜像连接 version: '3.3' services: db: container_name: db image: mysql:8 environment: MYSQL_DATABASE: employees MYSQL_USER: mysql MYSQL_PASSWORD: mysql MYSQL_ROOT_PASSWORD: supersecret ports: - 3306:3306 web: image: arungupta/docker-javaee:dockerconeu17 ports: - 8080:8080 - 9990:9990 depends_on: - db 总结docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux) docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1 # Win10 docker-machine env myvm1 # View basic information about your node docker-machine ssh myvm1 "docker node ls" # List the nodes in your swarm docker-machine ssh myvm1 "docker node inspect " # Inspect a node docker-machine ssh myvm1 "docker swarm join-token -q worker" # View join token docker-machine ssh myvm1 # Open an SSH session with the VM; type "exit" to end docker node ls # View nodes in swarm (while logged on to manager) docker-machine ssh myvm2 "docker swarm leave" # Make the worker leave the swarm docker-machine ssh myvm1 "docker swarm leave -f" # Make master leave, kill swarm docker-machine ls # list VMs, asterisk shows which VM this shell is talking to docker-machine start myvm1 # Start a VM that is currently not running docker-machine env myvm1 # show environment variables and command for myvm1 eval $(docker-machine env myvm1) # Mac command to connect shell to myvm1 & "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression # Windows command to connect shell to myvm1 docker stack deploy -c # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file docker-machine scp docker-compose.yml myvm1:~ # Copy file to node's home dir (only required if you use ssh to connect to manager and deploy the app) docker-machine ssh myvm1 "docker stack deploy -c " # Deploy an app using ssh (you must have first copied the Compose file to myvm1) eval $(docker-machine env -u) # Disconnect shell from VMs, use native docker docker-machine stop $(docker-machine ls -q) # Stop all running VMs docker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images Stacksdocker stack deploy -c docker-compose.yml getstartedlab docker stack ps getstartedlab help deploy Deploy a new stack or update an existing stack ls List stacks ps List the tasks in the stack rm Remove one or more stacks services List the services in the stack 不支持 stack deploy 的compose关键字 build cgroup_parent container_name devices tmpfs external_links links network_mode restart security_opt sysctls userns_mode redis sample version: "3" services: web: # replace username/repo:tag with your name and image details image: dockerlinz/get-started:part2 deploy: replicas: 5 restart_policy: condition: on-failure resources: limits: cpus: "0.1" memory: 50M ports: - "80:80" networks: - webnet visualizer: image: dockersamples/visualizer:stable ports: - "8080:8080" volumes: - "/var/run/docker.sock:/var/run/docker.sock" deploy: placement: constraints: [node.role == manager] networks: - webnet redis: image: redis ports: - "6379:6379" volumes: - "/home/docker/data:/data" deploy: placement: constraints: [node.role == manager] command: redis-server --appendonly yes networks: - webnet networks: webnet: deploy 详解 deploy: replicas: 5 restart_policy: condition: on-failure resources: limits: cpus: "0.1" memory: 50M placement: constraints: - node.role == manager - node.id==2ivku8v2gvtg4 - node.hostname!=node-2 - node.labels.security==high - engine.labels.operatingsystem == ubuntu 14.04 preferences: - spread: node.labels.zone update_config: parallelism: 2 delay: 10s order: stop-first 参考： constraints and preferences. 总结：docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux) docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1 # Win10 docker-machine env myvm1 # View basic information about your node docker-machine ssh myvm1 "docker node ls" # List the nodes in your swarm docker-machine ssh myvm1 "docker node inspect " # Inspect a node docker-machine ssh myvm1 "docker swarm join-token -q worker" # View join token docker-machine ssh myvm1 # Open an SSH session with the VM; type "exit" to end docker node ls # View nodes in swarm (while logged on to manager) docker-machine ssh myvm2 "docker swarm leave" # Make the worker leave the swarm docker-machine ssh myvm1 "docker swarm leave -f" # Make master leave, kill swarm docker-machine ls # list VMs, asterisk shows which VM this shell is talking to docker-machine start myvm1 # Start a VM that is currently not running docker-machine env myvm1 # show environment variables and command for myvm1 eval $(docker-machine env myvm1) # Mac command to connect shell to myvm1 & "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression # Windows command to connect shell to myvm1 docker stack deploy -c # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file docker-machine scp docker-compose.yml myvm1:~ # Copy file to node's home dir (only required if you use ssh to connect to manager and deploy the app) docker-machine ssh myvm1 "docker stack deploy -c " # Deploy an app using ssh (you must have first copied the Compose file to myvm1) eval $(docker-machine env -u) # Disconnect shell from VMs, use native docker docker-machine start $(docker-machine ls -q) # Stop all running VMs docker-machine stop $(docker-machine ls -q) # Stop all running VMs docker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images 监控 monitoringDocker CLi#容器使用资源情况，如cpu，men，i/o docker stats 显示指定的内容，: docker container stats --format "{{.Container}}: {{.CPUPerc}}" 55198043b6aa: 0.10% 5b5dd33b675d: 0.11% 6e98a9597e6a: 0.10% 类似： docker container stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" Docker Remote APIcurl --unix-socket /var/run/docker.sock http://localhost/containers//stats Docker eventshttps://docs.docker.com/engine/reference/commandline/events/docker events [OPTIONS] 启动Docker events 后Terminal进入等待状态， 当有docker 事件的时候打印事件详情 Prometheus Prometheus configuration file Prometheus 官网 Docker metrics for Prometheus cAdvisor cAdvisor docker container run \ --volume=/:/rootfs:ro \ --volume=/var/run:/var/run:rw \ --volume=/sys:/sys:ro \ --volume=/var/lib/docker/:/var/lib/docker:ro \ --publish=8080:8080 \ --detach=true \ --name=cadvisor \ google/cadvisor:latest How to setup Docker monitoring How to setup Docker monitoring. 项目文件： docker-monitoring cadvisor InfluxDB Grafana Metrics Dashboard 案例一 docker-compose.yml docker-compose up -d version: '2' #https://www.brianchristner.io/how-to-setup-docker-monitoring/ services: influxdbData: image: busybox volumes: - ./data/influxdb:/data # 对应的命令行 # sudo docker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --name influxsrv tutum/influxdb influxdb: image: tutum/influxdb:0.9 restart: always environment: - PRE_CREATE_DB=cadvisor ports: - "8083:8083" - "8086:8086" expose: - "8090" - "8099" volumes_from: - "influxdbData" # 对应的命令行 # sudo docker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw # --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro # --publish=8080:8080 # --detach=true # --link influxsrv:influxsrv --name=cadvisor google/cadvisor:latest # -storage_driver_db=influxdb # -storage_driver_host=influxsrv:8086 cadvisor: image: google/cadvisor:v0.29.0 links: - influxdb:influxsrv command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086 restart: always ports: - "8081:8080" volumes: - /:/rootfs:ro - /var/run:/var/run:rw - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:ro # sudo docker run -d -p 3000:3000 -e INFLUXDB_HOST=localhost -e INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=root -e INFLUXDB_PASS=root # --link influxsrv:influxsrv --name grafana grafana/grafana grafana: image: grafana/grafana restart: always links: - influxdb:influxsrv ports: - "3001:3000" environment: - HTTP_USER=admin - HTTP_PASS=admin - INFLUXDB_HOST=influxsrv - INFLUXDB_PORT=8086 - INFLUXDB_NAME=cadvisor - INFLUXDB_USER=root - INFLUXDB_PASS=root InfluxDB操作 UI操作界面：http://47.107.130.109:8083 注意：外网需打开InfluxDB打开防火墙的端口，如上，8083,80868083用于WEB访问 8086用于数据库操作 #Quaery CREATE DATABASE "cadvisor" #连接设置-> 点击设置icon 设置username，password OPITION（可选）：开启 cAdvisor外网访问端口 http://47.107.130.109:8081 docker run -p 8081:3000 grafana/grafan grafana 配置，详情参考：docker：快速构建容器监控系统cAdvisor+InfluxDB+Grafanahttp://47.107.130.109:3001 导入久工程设置，JSONdashboard -&gt; 设置-&gt;JSON Model -&gt; docker-monitoring-0.9.json 案例二 更多图表显示 dashboards 官网插件 Monitor Java ApplicationsDocker Network基本知识Networking in Compose Docker网络模式 自动创建 bridge（创建容器默认连接到此网络，也就是在不使用–network参数时）、 none 、host 自定义模式：bridge、overlay、macvlan。 host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。 None：该模式关闭了容器的网络功能。 Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 官方对选择网络模式的总结 User-defined bridge networks are best when you need multiple containers to communicate on the same Docker host. 【同docker host】 Host networks are best when the network stack should not be isolated from the Docker host, but you want other aspects of the container to be isolated. 【与docker host是否隔离】 Overlay networks are best when you need containers running on different Docker hosts to communicate, or when multiple applications work together using swarm services. 【集群适用多docker host】 Macvlan networks are best when you are migrating from a VM setup or need your containers to look like physical hosts on your network, each with a unique MAC address. 【模拟真实网络】 Third-party network plugins allow you to integrate Docker with specialized network stacks. 【指定不同网络类型】 配置文件 容器中主机名和DNS配置信息都是通过三个系统配置文件来维护的：/etc/resolv.conf、/etc/hostname和/etc/hosts。 常用命令#使container_nginx 连接到app_net 网络 docker network connect app_net container_nginx 网络问题检测工具箱 netshoot 2个docker-compose组网建立网络组 docker network create app_net 每个服务都增加 networks: - custom_net 如下： docker-compose-demo1.yml ersion: "3" services: app: build: . networks: - custom_net db: image: postgres networks: - custom_net networks: custom_net: external: name: app_net 两个compose公用external网络,如上设置网络 external_links compose 实现容器单向连接 nginx-net.yml #必须先于 nginx-net-external-links.yml version: "3" services: nginx2: image: nginx container_name: nginx2 network_mode: bridge nginx-net-enternal.yml version: "3" services: nginx1: image: nginx external_links: - nginx2 container_name: nginx1 network_mode: bridge 测试 docker exec -it nginx1 ping nginx2 #可以ping通 docker exec -it nginx2 ping nginx1 #不可以ping通 Docker0 的概述 网桥: 属于OSI 七层模型中的数据链路层 Linxu 虚拟网桥的特点： 可以设置IP地址，Linux就可以通过路由表或者IP表规则在网络层定位网桥地址 相当于一个隐藏的虚拟网卡 Docker0的默认地址划分： IP: 172.17.42.1 子网掩码： 255.255.0.0 MAC：02:42:ac:11:00:00 到 02:42:ac:11:ff:ff 共提供了65534个地址 自义定网桥 有空搜索关键字研究，配置失败，配置 #安装工具 sudo apt-get -f install bridge-utils #增加虚拟网桥 sudo brctl addbr br0 # 每次修改，需要重启docker才能生效 sudo ifconfig br0 192.168.100.1 netmask 255.255.255.0 #验证是否成功 br0 ifconfig 自定义默认网桥 docker0 #新的网桥 sudo brctl addbr bridge0 sudo ip addr add 192.168.208.1/16 dev bridge0 sudo ip link set dev bridge0 up #查看配置 ip addr show bridge0 在 Docker 配置文件/etc/docker/daemon.json { "bridge": "bridge0", } 再次启动docker服务 # 重启 systemctl daemon-reload systemctl restart docker Docker 容器的互联–icc=true 允许所有容器互联 –icc=true 运行容器互相连接 Dockerfille FROM ubuntu:14.04 RUN apt-get install -y ping RUN apt-get update RUN apt-get install -y nginx RUN apt-get install -y curl EXPOSE 80 CMD /bin/bash 编译及运行 docker build -t dormancypress/cct . docker run -it --name cct1 dormancypress/cct #进入cct1，启动nginx nginx docker run -it --name cct2 dormancypress/cct nginx #查看相互的ip,尝试在不同的container中，ping docker attach cct1 #nginx访问 curl 重启镜像ip会改变 【待验证】 –linkdocker run --link=[container_name]:[alias] [image] [cmd] 实践案例 启动cct3并连接到cct1 docker run -it --name cct3 --link=cct1:webtest dormancypress/cct #测试是否正常连接 ping webtest –icc=true 拒绝所有容器互联 拒绝所有容器间的访问 允许特定容器访间的连接Docker容器与外部网络的连接 ip_forward 是否允许流量转发 1 允许，查看 sudo sysctl net.ipv4.conf.all.forwarding iptables Linux包过滤防火墙系统 talbe chain rule （accept, reject, drop） 实战，filter表包含连接：（INPUT, OUTPUT, FORWARD） sudo iptables -t filter -L -n # -I 规则 -s 指定地址 -d 目的地址 ==> 阻止10.211.55.3访问172.17.0.1 sudo iptables -I DOCKER -s 10.211.55.3 -d 172.17.0.1 -p TCP --dport 80 j DROP 注解：iptable 命令详解 Docker容器的跨主机访问 网桥实现sudo apt-get install bridge-utils 静态配置IP，防止IP重启后变动 vim /etc/network/interfaces auto lo iface lo inet loopback # The primary network interface auto br0 # 指定网关 iface br0 inet static address 192.168.0.42 network 192.168.0.0 netmask 255.255.255.0 # broadcast 192.168.0.255 gateway 192.168.0.1 bridge_ports eth0 #指定本地的物理网卡 配置docker默认选项 （旧办版本有效）vim /etc/default/docker # --fixed-cidr 限制IP地址使用范围 DOCKER_OPTS= -b=br0 --fixed-cidr='10.211.55.04/26' 重启生效 reboot 总结 有点： 配置简单，不依赖第三方软件 缺点： 与主机在同网段，需要小心划分IP地址 需要网段的控制权限，生产环境不易实现 不容易管理，兼容性不佳 Open vSwitch（ovs）原理解析 Open vSwitch 是一个高质量的、多层虚拟交换机 原理图 原理解析： GRE：通用路由协议封装。 隧道技术（Tunneling）一种使用互联网基础设施在网络传输数据的方式，支持不同协议的数据，并每个帧头有路由寻址信息。即隧道技术是提供是点对点再封装的技术； 实战 建立ovs连接 添加gre连接 配置docker容器虚拟网桥 为虚拟网桥添加ovs接口 添加不同的Docker网段路由 配置安装 #安装工具 sudo apt-get install openvswitch-switch sudo apt-get install bridge-utils #查看版本 sudo ovs-vsctl show #创建网桥 sudo ovs-vsctl add-br obr0 #添加GRE接口 sudo ovs-vsctl add-port obr0 gre0 #interface remote_ip 指定远程服务器地址（为另一台虚拟机地址）192.168.208.132 sudo ovs-vsctl set interface gre0 type=gre options:remote_ip=192.168.59.104 #查看新建状态，确认修改成功 sudo ovs-vsctl show #新建网桥 sudo brctl addbr br0 #配置网桥 sudo ifconfig br0 192.168.1.1 netmask 255.255.255.0 #添加osv网桥连接 sudo brctl addif br0 obr0 #查看当前网桥的连接状态 sudo brctl show #修改Docker默认的网桥 "bridge":"br0" vim /etc/docker/daemon.json sudo systemctl daemon-reload sudo systemctl restart docker 验证是否安装成功 docker run -it ubuntu /bin/bash if #ping 另一台主机是否成功 ping 192.168.59.104 同步骤1，但是该网桥sudo ifconfig br0 192.168.2.1 netmask 255.255.255.0 配置好后两个镜像还是不能ping通，添加路由表 查看路由边信息 192.168.208.132 Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default 192.168.208.2 0.0.0.0 UG 100 0 0 ens33 link-local * 255.255.0.0 U 1000 0 0 ens33 172.17.0.0 * 255.255.0.0 U 0 0 0 docker0 192.168.208.0 * 255.255.255.0 U 100 0 0 ens33 添加路由 #添加192.168.2.0/2路由信息，在192.168.59.104能找到指定设备eth0 sudo ip route add 192.168.2.0/24 via 192.168.59.104 dev eth0 参考 Open vSwitch2.3.0版本安装部署及基本操作 笔记 Weave实战`Weave 的安装 sudo curl -L git.io/weave -o /usr/local/bin/weave #下载 sudo chmod a+x /usr/local/bin/weave #赋予执行权限 weave version #查看weave版本 weave status #查看weave状态 运行 # docker1 主机 weave launcn 192.168.208.134 # 192.168.208.134 需要连接主机地址 # 后台运行一个镜像 docker run -it dockerlinz/cct #为镜像分配IP地址 weave attach 192.168.1.2/24 #docker2 主机同上配置 测试 docker exec -it /bin/bash ping ip 常用命令weave --help #查看帮助 weave ps #查看weave路由状态：weave ps weave connect OTHER_HOST #可以把一台主机连接到weave网络 weave attach #动态添加网络对于不是通过weave启动的容器，可以通过weave attach 10.0.1.1/24 $ContainerId来添加网络（weave detach删除网络） weave expose #不使用docker的原生网络容器和宿主机之间是无法互通的 , weave expose ip/24这个命令会把宿主机加入到weave 网络中, 宿主机就可以和容器之间自由通信了 weave launch -password #安全性：可以通过weave launch -password wEaVe设置一个密码用于weave peers之间加密通信 Weave Network Plugin Weave Network Plugin OverlayDocker容器跨主机通信–overlay网络 参考： 自定义默认网桥 docker0 操作案例Ingress Network / lvs #查看路由列表 iptables -nL -t nat yum install bridge-utils -y # 查看网关 brctl show docker network ls 参考Designing Scalable, Portable Docker Container Networks docker-compose官方配置文档 官网 docker-compose.yml 文件参考 docker-compose.yml 配置文件编写详解 基本操作# one-off docker-compose run # 启动并在后台运行 docker-compose up -d # 停止container docker-compose stop # bring everything down, remove the container docker-compose down # remove the data docker-compose down --volumes 常用参数详解epends_on example: version: "3.7" services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres depends_on 只是service的启动顺序, 而不是等待db,redis 准备好之后在启动，这就会有一个问题就是，web 启动后db,redis 没有准备好，导致web启动失败，官网解决方案 depends_on: - "db" command: ["./wait-for-it.sh", "db:5432", "--", "python", "app.py"] wait-for-it.sh 使用脚本进行重连 #!/bin/sh # wait-for-postgres.sh set -e host="$1" shift cmd="$@" until PGPASSWORD=$POSTGRES_PASSWORD psql -h "$host" -U "postgres" -c '\q'; do >&2 echo "Postgres is unavailable - sleeping" sleep 1 done >&2 echo "Postgres is up - executing command" exec $cmd 用docker-compose 配置环境docker-compose-pull-images.yml version: '3' services: ubuntu: image: ubuntu:latest busybox: image: busybox:latest openjdk: image: openjdk:latest wildfly: image: jboss/wildfly:latest javaee7-hol: image: arungupta/javaee7-hol:latest docker-javaee: image: arungupta/docker-javaee:dockerconeu17 mysql: image: mysql:8 hadoop: image: tailtarget/hadoop:2.7.2 jenkins: image: jenkins/jenkins:lts prometheus: image: prom/prometheus:latest node-exporter: image: prom/node-exporter cadvisor: image: google/cadvisor:latest grafana: image: grafana/grafana debian: image: debian:stable-slim alpine: image: alpine:3.6 openjdk-slim: image: openjdk:9-jdk-slim Pulls images for services defined in a Compose file, but does not start the containers. #add sudo for linux docker-compose -f docker-compose-pull-images.yml pull --parallel yml文件更新 docker stack deploy wordpress --compose-file=docker-compose.yml 实战案例FastFDS fastdfs 官网 docker-compose 和Dockerfile 生成fastdfs 学习案例 moocu/fastdfs source Network in composeNetworking in Compose 同一个compose app 相互连通 version: "3" services: linux: image: ubuntu db: image: postgres ports: - "8001:5432" compose 用linux 和 db 作为主机地址,docker exec -it linux ping db 可以ping通 compose内部使用默认端口而不是映射端口， 如当linux 使用db数据库是使用端口5432可以直接访问，而不是外部映射端口8001 Docker 安全docker Secret官方文档详细介绍： Manage sensitive data with Docker secrets #新建一个名称为my-pw 值为 password 的secret docker secret create my-pw password #不产生文件 printf | docker secret create my_secret - #查看secret docker secret ls #查看运行中的容器，是否存在secret文件 docker container exec $(docker ps --filter name=redis -q) ls -l /run/secrets #查看secret内容 docker container exec $(docker ps --filter name=redis -q) cat /run/secrets/my_secret_data #删除 docker service update --secret-rm my_secret_data redis #Add or update a secret on a service docker service update --secret-add secret yml文件中使用 services: db: image: mysql:latest environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret MYSQL_DATABASE: wordpress secrets: - my_secret web： image: wordpress ports: - 8080:80 secrets: - my-pw environment: WORDPRESS_DB_HOST: mysql WORDPRESS_DB_PASSWORD_FILE: /run/secrets/my-pw docker run 使用 docker service create --name client --secret my-pw busybox sh -c "while true: do sleep 3600;done" 进阶学习storageVolumes compose file reference Use volumes 一下Volumes最常用的操作 container sharing volumes sudo docker run -it -v /usr/lib:/usr/lib/dbdata --name dbcontainer-192.168.1.184 ubuntu:14.04 sudo docker run -it --volumes-from dbcontainer-192.168.1.184 --name mastercontainer-192.168.1.180 ubuntu:14.04 plugindocker inspect docker inspect获取详细参数的两种方法 Kubernetes Ubuntu 18.04 离线安装Kubernetes v1.11.1 常用工具 portainer 是一个开源、轻量级Docker管理用户界面官方网站：https://portainer.io/官方文档：https://portainer.readthedocs.io/演示网址：http://demo.portainer.io 账号admin 密码 tryportainer安装命令 # 下载镜像 docker pull portainer/portainer:latest docker run -d -p 9000:9000 \ --restart=always \ -v /var/run/docker.sock:/var/run/docker.sock \ --name prtainer \ portainer/portainer Docker 传参直接用 docker inspect &lt;container-id&gt; 查看Dockerfile ENTRYPOINT java -Xmx256M -jar /app.jar CMD ["echo", "hello"] docker inspect 实际启动的命令及参数 "Path": "/bin/sh", "Args": [ "-c", "java -Xmx256M -jar /app.jar", "echo", "hello" ] ENTRYPOINT / CMD有ENTRYPOINT 优先 $取参Dockerfile FROM ubuntu ENTRYPOINT echo hello $0 $2 运行 #编译 docker build -t test . #运行 docker run test 111 2222 333 #输出 hello 111 333 Dockerfile2 ENTRYPOINT echo hello $0 $@ #运行 docker run test 111 2222 333 #输出 hello 111 2222 333 环境变量方式Dockerfile FROM ubuntu ENTRYPOINT echo hello $0 ${OPT} 编译 tag=test， 运行docker run -e OPT=&quot;-Xmx5G -Xms2G&quot; test aa bb,输出 hello aa -Xmx5G -Xms2G Alpine Linux alpine linux 是一个基于安全的轻量级 Linux 发行版，基于 musl libc 和 busybox。alpine linux 由于简单安全，非常适合 docker 的 linux 发行版，并且被 docker 官方所推荐用来取代 ubuntu。它不但非常小，仅有 5m 左右，而且经过优化可以在 RAM 中运行 官方说明文档 软件管理 package managementPackage management 官方详细说明 包含详细的命令案例 命令列表 add Add new packages to the running system del Delete packages from the running system fix Attempt to repair or upgrade an installed package update Update the index of available packages info Prints information about installed or available packages search Search for packages or descriptions with wildcard patterns upgrade Upgrade the currently installed packages cache Maintenance operations for locally cached package repository version Compare version differences between installed and available packages index create a repository index from a list of packages fetch download (but not install) packages audit List changes to the file system from pristine package install state verify Verify a package signature dot Create a graphviz graph description for a given package policy Display the repository that updates a given package, plus repositories that also offer the package stats Display statistics, including number of packages installed and available, number of directories and files, etc. manifest Display checksums for files contained in a given package 软件仓库官方软件仓库 https://pkgs.alpinelinux.org/packages 可以搜索安装 社区最新稳定软件列表 能找到官方仓库没有的软件 参考 alpine linux 环境中安装 docker 案例本地打包Image，解压分析到其他服务器docker image save helloworld > helloworld.tar docker image load -i helloworld.tar JenkinsRunning Docker in Jenkins https://container-solutions.com/running-docker-in-jenkins-in-docker/ Dockerfile #不加latest自动选择最新的：FROM jenkins:latest FROM jenkins USER root #清除了基础镜像设置的源，切换成阿里云的jessie源 RUN echo '' > /etc/apt/sources.list.d/jessie-backports.list \ && echo "deb http://mirrors.aliyun.com/debian jessie main contrib non-free" > /etc/apt/sources.list \ && echo "deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free" >> /etc/apt/sources.list \ && echo "deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free" >> /etc/apt/sources.list RUN apt-get update \ && apt-get install -y sudo \ #解决docker 命令找不到libltdl7库的问题 && apt-get install -y libltdl7 \ && rm -rf /var/lib/apt/lists/* #增加sudo 权限 RUN echo "jenkins ALL=NOPASSWD: ALL" >> /etc/sudoers #不用sudo运行docker ARG dockerGid=999 RUN echo "docker:x:${dockerGid}:jenkins" >> /etc/group USER jenkins COPY plugins.txt /usr/share/jenkins/plugins.txt RUN /usr/local/bin/plugins.sh /usr/share/jenkins/plugins.txt plugins.txt $ cat plugins.txt scm-api:latest git-client:latest git:latest greenballs:latest shell $ docker build -t myjenk . ... Successfully built 471fc0d22bff $ docker run -d -v /var/run/docker.sock:/var/run/docker.sock \ -v $(which docker):/usr/bin/docker -p 8080:8080 myjenk docker exec -it 471fc0d22bff /bin/bash # in jenkins jenkins@e8a57cd15581:/$ cat /var/jenkins_home/secrets/initialAdminPassword 增加时区和时间 -v /etc/timezone:/etc/timezone -v /etc/localtime:/etc/localtime 挂载本地的设置，不用每次都需重新设置 -v /var/docker_data/jenkins/jenkins_home:/var/jenkins_home -v /var/docker_data/jenkins/settings:/var/settings Jenkins Operation Open the Jenkins home page in a browser and click the “create new jobs” link. Enter the item name (e.g. “docker-test”), select “Freestyle project” and click OK. On the configuration page, click “Add build step” then “Execute shell”. In the command box enter “sudo docker run hello-world” Click “Save”. Click “Build Now”. 可能出现的问题 - 找不到某些library docker: error while loading shared libraries: libltdl.so.7: cannot open shared object file: No such file or directory Build step 'Execute shell' marked build as failure 原因Jenkins容器内没有这个库，解决，增加对应库的映射-v /usr/lib/x86_64-linux-gnu/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 docker run -d -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker -v /usr/lib/x86_64-linux-gnu/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 -p 8086:8080 myjenk Tengine 容器化Tengine + TCMalloc其中libunwind-1.2和 gperftools-2.7 由于网络问题缓存在本地 E:\software\2.coder\env\ Dockderfile #Dockerfile for tnegine FROM centos:latest MAINTAINER zhilin "zhilinchn@126.ocm" ENV NGINX_VERSION 2.3.0 WORKDIR /usr/src/ ADD https://github.com/alibaba/tengine/archive/${NGINX_VERSION}.tar.gz tengine.tar.gz # 安装依赖程序包 RUN yum -y update && yum -y upgrade &&\ yum -y install gcc gcc-c++ openssl-devel \ pcre-devel \ zlib-devel \ make \ wget \ ibxml2-devel \ gd-devel \ GeoIP-devel \ google-perftools-devel \ libatomic_ops-devel \ cmake #由于网络的原因 libunwind，gperftools 本地先下好 ADD ./libunwind-1.2 /usr/src/libunwind-1.2 ADD ./gperftools-2.7 /usr/src/gperftools-2.7 #使用TCMalloc优化Tengine性能 RUN cd /usr/src/libunwind-1.2 &&\ ./configure && \ make && make install && \ cd /usr/src/gperftools-2.7 && \ ./configure --enable-libunwind --enable-frame-pointers --enable-emergency-malloc && \ make && make install && \ mkdir -pv /tmp/tcmalloc && \ chmod -R 0777 /tmp/tcmalloc RUN cd /usr/src/ && \ tar -zxvf tengine.tar.gz && \ cd tengine-${NGINX_VERSION} && \ ./configure \ --prefix=/usr/local/tengine \ --with-threads \ --with-file-aio \ #--with-force-exit \ --with-mail \ --with-pcre-jit \ --with-libatomic \ --http-log-path=/usr/local/tengine/logs/access.log \ --with-google_perftools_module && \ make && make install EXPOSE 80 CMD ["/usr/local/tengine/sbin/nginx", "-g", "daemon off;"] Docker +centos+ luaDockerfile docker + tengine + lua插件 集成 FROM centos:latest MAINTAINER becivells RUN yum -y update && yum -y upgrade RUN yum -y install gcc gcc-c+ openssl openssl-devel pcre-devel zlib-devel make wget ENV TENGINE_VERSION tengine-2.2.3 RUN cd /tmp/ && wget http://tengine.taobao.org/download/${TENGINE_VERSION}.tar.gz &&\ tar -zxvf ${TENGINE_VERSION}.tar.gz -C /tmp/ && chmod -R 777 /tmp/${TENGINE_VERSION} #mkdir RUN mkdir -p /var/tmp/nginx/client/ &&\ mkdir -p /var/tmp/nginx/proxy/ &&\ mkdir -p /var/tmp/nginx/fcgi/ &&\ mkdir -p /var/tmp/nginx/uwsgi/ &&\ mkdir -p /var/tmp/nginx/scgi/ #./configure #LuaJIT RUN cd /tmp/ && wget http://luajit.org/download/LuaJIT-2.0.4.tar.gz && \ tar xzvf LuaJIT-2.0.4.tar.gz && \ cd LuaJIT-2.0.4 && \ make install PREFIX=/usr/local/LuaJIT ENV LUAJIT_LIB=/usr/local/LuaJIT/lib ENV LUAJIT_INC=/usr/local/LuaJIT/include/luajit-2.0 RUN cd /tmp/ && wget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz && \ tar -xzvf v0.3.0.tar.gz && \ wget https://github.com/openresty/lua-nginx-module/archive/v0.10.8.tar.gz && \ tar -xzvf v0.10.8.tar.gz RUN cd /tmp/${TENGINE_VERSION} && ./configure \ --prefix=/opt/${TENGINE_VERSION}/ \ #--sbin-path=/usr/sbin/nginx \ #--modules-path=/usr/lib64/nginx/modules \ #--conf-path=/etc/nginx/nginx.conf \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --pid-path=/var/run/nginx/nginx.pid \ --lock-path=/var/lock/nginx.lock \ --http-client-body-temp-path=/var/tmp/nginx/client/ \ --http-proxy-temp-path=/var/tmp/nginx/proxy/ \ --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \ --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \ --with-file-aio \ --with-http_addition_module \ --with-http_auth_request_module \ --with-http_dav_module \ --with-http_flv_module \ --with-http_gunzip_module \ --with-http_gzip_static_module \ --with-http_mp4_module \ --with-http_random_index_module \ --with-http_realip_module \ --with-http_secure_link_module \ --with-http_slice_module \ --with-http_ssl_module \ --with-http_stub_status_module \ --with-http_sub_module \ --with-mail \ --with-mail_ssl_module \ --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong \ --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' \ --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie' \ --add-module=/tmp/lua-nginx-module-0.10.8 \ --add-module=/tmp/ngx_devel_kit-0.3.0 \ --with-pcre &&\ cd /tmp/${TENGINE_VERSION} && make -j 4 && make install && \ rm -rf /tmp/* && yum clean all && \ ln -s /opt/${TENGINE_VERSION}/ /opt/tengine && \ echo "/usr/local/LuaJIT/lib" >> /etc/ld.so.conf && \ ldconfig EXPOSE 80 CMD ["/opt/tengine/sbin/nginx", "-g", "daemon off;"] Tengine + Alpinehttps://github.com/Axizdkr/tengine Dockerfile FROM alpine:3.9 ENV TENGINE_VERSION 2.3.0 # nginx: https://git.io/vSIyj RUN rm -rf /var/cache/apk/* && \ rm -rf /tmp/* ENV CONFIG "\ --prefix=/etc/nginx \ --sbin-path=/usr/sbin/nginx \ --modules-path=/usr/lib/nginx/modules \ --conf-path=/etc/nginx/nginx.conf \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --pid-path=/var/run/nginx.pid \ --lock-path=/var/run/nginx.lock \ --http-client-body-temp-path=/var/cache/nginx/client_temp \ --http-proxy-temp-path=/var/cache/nginx/proxy_temp \ --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \ --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \ --http-scgi-temp-path=/var/cache/nginx/scgi_temp \ --user=nginx \ --group=nginx \ --with-http_ssl_module \ --with-http_realip_module \ --with-http_addition_module \ --with-http_sub_module \ --with-http_dav_module \ --with-http_flv_module \ --with-http_mp4_module \ --with-http_gunzip_module \ --with-http_gzip_static_module \ --with-http_random_index_module \ --with-http_secure_link_module \ --with-http_stub_status_module \ --with-http_auth_request_module \ --with-http_xslt_module=dynamic \ --with-http_image_filter_module=dynamic \ --with-http_geoip_module=dynamic \ --with-threads \ --with-stream \ --with-stream_ssl_module \ --with-stream_ssl_preread_module \ --with-stream_realip_module \ --with-stream_geoip_module=dynamic \ --with-http_slice_module \ --with-mail \ --with-mail_ssl_module \ --with-compat \ --with-file-aio \ --with-http_v2_module \ --add-module=modules/ngx_http_upstream_check_module \ " RUN addgroup -S nginx \ && adduser -D -S -h /var/cache/nginx -s /sbin/nologin -G nginx nginx \ && apk add --no-cache --virtual .build-deps \ gcc \ libc-dev \ make \ openssl-dev \ pcre-dev \ zlib-dev \ linux-headers \ curl \ libxslt-dev \ gd-dev \ geoip-dev \ && curl -L "http://tengine.taobao.org/download/tengine-$TENGINE_VERSION.tar.gz" -o tengine.tar.gz \ && mkdir -p /usr/src \ && tar -zxC /usr/src -f tengine.tar.gz \ && rm tengine.tar.gz \ && cd /usr/src/tengine-$TENGINE_VERSION \ && ./configure $CONFIG --with-debug \ && make -j$(getconf _NPROCESSORS_ONLN) \ && mv objs/nginx objs/nginx-debug \ && mv objs/ngx_http_xslt_filter_module.so objs/ngx_http_xslt_filter_module-debug.so \ && mv objs/ngx_http_image_filter_module.so objs/ngx_http_image_filter_module-debug.so \ && mv objs/ngx_http_geoip_module.so objs/ngx_http_geoip_module-debug.so \ && mv objs/ngx_stream_geoip_module.so objs/ngx_stream_geoip_module-debug.so \ && ./configure $CONFIG \ && make -j$(getconf _NPROCESSORS_ONLN) \ && make install \ && rm -rf /etc/nginx/html/ \ && mkdir /etc/nginx/conf.d/ \ && mkdir -p /usr/share/nginx/html/ \ && install -m644 html/index.html /usr/share/nginx/html/ \ && install -m644 html/50x.html /usr/share/nginx/html/ \ && install -m755 objs/nginx-debug /usr/sbin/nginx-debug \ && install -m755 objs/ngx_http_xslt_filter_module-debug.so /usr/lib/nginx/modules/ngx_http_xslt_filter_module-debug.so \ && install -m755 objs/ngx_http_image_filter_module-debug.so /usr/lib/nginx/modules/ngx_http_image_filter_module-debug.so \ && install -m755 objs/ngx_http_geoip_module-debug.so /usr/lib/nginx/modules/ngx_http_geoip_module-debug.so \ && install -m755 objs/ngx_stream_geoip_module-debug.so /usr/lib/nginx/modules/ngx_stream_geoip_module-debug.so \ && ln -s ../../usr/lib/nginx/modules /etc/nginx/modules \ && strip /usr/sbin/nginx* \ && strip /usr/lib/nginx/modules/*.so \ && rm -rf /usr/src/tengine-$NGINX_VERSION \ \ # Bring in gettext so we can get `envsubst`, then throw # the rest away. To do this, we need to install `gettext` # then move `envsubst` out of the way so `gettext` can # be deleted completely, then move `envsubst` back. && apk add --no-cache --virtual .gettext gettext \ && mv /usr/bin/envsubst /tmp/ \ \ && runDeps="$( \ scanelf --needed --nobanner --format '%n#p' /usr/sbin/nginx /usr/lib/nginx/modules/*.so /tmp/envsubst \ | tr ',' '\n' \ | sort -u \ | awk 'system("[ -e /usr/local/lib/" $1 " ]") == 0 { next } { print "so:" $1 }' \ )" \ && apk add --no-cache --virtual .nginx-rundeps $runDeps \ && apk del .build-deps \ && apk del .gettext \ && mv /tmp/envsubst /usr/local/bin/ \ \ # Bring in tzdata so users could set the timezones through the environment # variables && apk add --no-cache tzdata \ \ # forward request and error logs to docker log collector && ln -sf /dev/stdout /var/log/nginx/access.log \ && ln -sf /dev/stderr /var/log/nginx/error.log COPY nginx.conf /etc/nginx/nginx.conf EXPOSE 80 443 STOPSIGNAL SIGTERM CMD ["nginx", "-g", "daemon off;"] 参考 Dockerfile-centos:tengine Nginx编译安装Lua模块 Tengine+Lua插件编译安装 docker-zipkinzipkin + elasticsearchspring cloud 2.0 入门系列一 （10）分布式链路追踪-Zipkin docker-compose.yml version: "3" services: elasticsearch: image: elasticsearch:latest container_name: elasticsearch restart: always networks: - elk ports: - "9200:9200" - "9300:9300" volumes: - ../elasticsearch/data:/usr/share/elasticsearch/data zipkin: image: openzipkin/zipkin:latest container_name: zipkin restart: always networks: - elk ports: - "9411:9411" environment: - STORAGE_TYPE=elasticsearch - ES_HOSTS=elasticsearch networks: elk: docker-zipkin 变量专递分析 docker-zipkin docker-compose.yml 设置环境变量 zipkin/Dockerfile 调用run.sh WORKDIR /zipkin RUN ["/busybox/sh", "-c", "ln -s /busybox/* /bin"] EXPOSE 9410 9411 ENTRYPOINT ["/busybox/sh", "run.sh"] run.sh 根据docker-compose.yml动态设置变量 #!/bin/sh if [ -f ".${STORAGE_TYPE}_profile" ]; then source ${PWD}/.${STORAGE_TYPE}_profile fi exec java ${MODULE_OPTS} ${JAVA_OPTS} -cp . org.springframework.boot.loader.PropertiesLauncher .mysql_profile #!/bin/sh if [[ -z "$MYSQL_HOST" ]]; then if [[ -z "$STORAGE_PORT_3306_TCP_ADDR" ]]; then echo "** ERROR: You need to link with a MySQL container as 'storage' or specify MYSQL_HOST env var." echo "STORAGE_PORT_3306_TCP_ADDR (container link) or MYSQL_HOST should contain a MySQL hostname." exit 1 fi MYSQL_HOST=$STORAGE_PORT_3306_TCP_ADDR # When there's a container named "mysql", MYSQL_PORT will have a value like tcp://172.17.0.2:3306 export MYSQL_PORT=3306 fi export MYSQL_HOST export MYSQL_USER=${MYSQL_USER:=zipkin} export MYSQL_PASS=${MYSQL_PASS:=zipkin} echo "MySQL host: $MYSQL_HOST" spring boot 最终获取配置 /zipkin-server/src/main/resources/zipkin-server-shared.yml mysql: jdbc-url: ${MYSQL_JDBC_URL:} host: ${MYSQL_HOST:localhost} port: ${MYSQL_TCP_PORT:3306} username: ${MYSQL_USER:} password: ${MYSQL_PASS:} db: ${MYSQL_DB:zipkin} max-active: ${MYSQL_MAX_CONNECTIONS:10} use-ssl: ${MYSQL_USE_SSL:false} 容器使用远程storagedocker plugin install vieux/sshfs docker volume create \ -d vieux/sshfs \ --name sshvolume \ -o sshcmd=user@1.2.3.4:/remote \ -o password=$(cat file_containing_password_for_remote_host) docker run --rm -v sshvolume:/data busybox ls /data #删除 docker volume rm sshvolume docker plugin disable vieux/sshfs docker plugin remove vieux/sshfs docker-mongo参考博文： 使用Docker一键部署MongoDB Deploy GitLab in a Docker swarm https://hub.docker.com/_/mongo nacos-dockernacos-docker fastdfshttps://github.com/happyfish100/fastdfs 更多官方学习资源 Samples: Our samples include multiple examples of popular software running in containers, and some good labs that teach best practices. User Guide: The user guide has several examples that explain networking and storage in greater depth than was covered here. Admin Guide: Covers how to manage a Dockerized production environment. Training: Official Docker courses that offer in-person instruction and virtual classroom environments. Blog: Covers what’s going on with Docker lately. 配置Docker 安装最简单官网方案 $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun 官网安装教程 install-docker-ce 从入门到实战 install 配置优化 使用国内镜像 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows { "registry-mirrors": ["http://hub-mirror.c.163.com"] } 配置全部容器的 DNS /etc/docker/daemon.json { "dns" : [ "114.114.114.114", "8.8.8.8" ] } Docker 网络配置 docker c/s 模式客户端和服务器通信的方式 unix:///var/run/docker.sock tcp://host:port fd://socketfd or fd://* 守护进程默认配置： unix:///var/run/docker.sock docker 远程访问 # 修改服务器标识Label vim /etc/docker/daemon.json # 增加： "labels":["name=docker_daemon_server_on_ubuntu"] # 重启 systemctl daemon-reload systemctl restart docker # 验证生效 docker info ... Labels: name=docker_daemon_server_on_ubuntu ... 修改默认网桥 vim /etc/docker/daemon.json { "bridge": "br0" } # 重启生效 systemctl daemon-reload systemctl restart docker daemon.jsonlinux版本 { "api-cors-header": "", "authorization-plugins": [], "bip": "", "bridge": "", "cgroup-parent": "", "cluster-store": "", "cluster-store-opts": {}, "cluster-advertise": "", "debug": true, "default-gateway": "", "default-gateway-v6": "", "default-runtime": "runc", "default-ulimits": {}, "disable-legacy-registry": false, "dns": [], "dns-opts": [], "dns-search": [], "exec-opts": [], "exec-root": "", "fixed-cidr": "", "fixed-cidr-v6": "", "graph": "", "group": "", "hosts": [], "icc": false, "insecure-registries": [], "ip": "0.0.0.0", "iptables": false, "ipv6": false, "ip-forward": false, "ip-masq": false, "labels": [], "live-restore": true, "log-driver": "", "log-level": "", "log-opts": {}, "max-concurrent-downloads": 3, "max-concurrent-uploads": 5, "mtu": 0, "oom-score-adjust": -500, "pidfile": "", "raw-logs": false, "registry-mirrors": [], "runtimes": { "runc": { "path": "runc" }, "custom": { "path": "/usr/local/bin/my-runc-replacement", "runtimeArgs": [ "--debug" ] } }, "selinux-enabled": false, "storage-driver": "", "storage-opts": [], "swarm-default-advertise-addr": "", "tls": true, "tlscacert": "", "tlscert": "", "tlskey": "", "tlsverify": true, "userland-proxy": false, "userns-remap": "" } windows10 { "authorization-plugins": [], "bridge": "", "cluster-advertise": "", "cluster-store": "", "debug": true, "default-ulimits": {}, "disable-legacy-registry": false, "dns": [], "dns-opts": [], "dns-search": [], "exec-opts": [], "fixed-cidr": "", "graph": "", "group": "", "hosts": [], "insecure-registries": [], "labels": [], "live-restore": true, "log-driver": "", "log-level": "", "mtu": 0, "pidfile": "", "raw-logs": false, "registry-mirrors": [], "storage-driver": "", "storage-opts": [], "swarm-default-advertise-addr": "", "tlscacert": "", "tlscert": "", "tlskey": "", "tlsverify": true } config 官网说明 有三个详细的案例 关键命令提取 # 第一个 site.conf 为config命名， 第二个为config读取路径 docker config create site.conf ./site.conf docker config ls 使用 $ docker service create \ --name nginx \ --secret site.key \ --secret site.crt \ --config source=site.conf,target=/etc/nginx/conf.d/site.conf,mode=0440 \ --publish published=3000,target=443 \ nginx:latest \ sh -c "exec nginx -g 'daemon off;'" 替换 removing the old config and adding the new config at the same mount point within the container docker config create site-v2.conf site.conf $ docker service update \ --config-rm site.conf \ --config-add source=site-v2.conf,target=/etc/nginx/conf.d/site.conf,mode=0440 \ nginx 清除并退出 $ docker config rm site.conf $ docker service rm nginx $ docker secret rm site.crt site.key $ docker config rm site-v2.conf compose config创建config后直接使用 configs: #docker config create mongod.conf ./mongod.conf - source: mongod.conf target: /etc/mongo/mongod.conf 全局config version: "3.6" services: gitlab: image: gitlab/gitlab-ce:latest environment: GITLAB_OMNIBUS_CONFIG: "from_file('/omnibus_config.rb')" configs: - source: gitlab target: /omnibus_config.rb secrets: - gitlab_root_password gitlab-runner: image: gitlab/gitlab-runner:alpine deploy: mode: replicated replicas: 4 configs: gitlab: file: ./gitlab.rb secrets: gitlab_root_password: file: ./root_password.txt gitlab.rb external_url 'https://my.domain.com/' gitlab_rails['initial_root_password'] = File.read('/run/secrets/gitlab_root_password') 使用案例 Nexus 起到缓存的作用（链接到 DockerHub 中下载并缓存到 Nexus 中） 其它的仓库创建方法请各位自己摸索，还可以创建一个 docker (proxy) 类型的仓库链接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。 使用docker修改查看JDK源码，用于深度的调试 第三方库使用Vagrant ubuntu 安装vagrant过程 downloads ubuntu: dpkg -i xx.deb 问题解决 ubuntu： docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/create: dial unix /var/run/docker.sock: connect: permission denied.See ‘docker run –help’. 猜测是需ROOT权限， docker服务没有启动,解决方案 su root #切换到root用户 systemctl enable docker #设置开机自动启用docker服务 systemctl start docker #启动docker 服务 或者赋予docker sudo 权限 sudo groupadd docker sudo usermod -aG docker $USER sudo service docker restart #实战中需要切换到root的运行过一遍 su 到root su jobs 到当前用户 # 测试 docker run hello-world # 或 docker version Unable to locate package nginx 解决方案： apt-get update 无法获得锁 /var/lib/dpkg/lock - open原因可能是上次我直接在VM切断的电源导致资源一直被占用未被释放解决：(养成正常关机的习惯) sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock docker 各种命令都报 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? systemctl status docker 出现日志如下 docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: failed (Result: start-limit-hit) since 三 2019-01-30 23:47:41 CST; 1min 49s ago Docs: https://docs.docker.com Process: 3700 ExecStart=/usr/bin/dockerd -H fd:// (code=exited, status=1/FAILURE) Main PID: 3700 (code=exited, status=1/FAILURE) 1月 30 23:47:38 jobs-machine systemd[1]: Failed to start Docker Application Container Engine. 1月 30 23:47:38 jobs-machine systemd[1]: docker.service: Unit entered failed state. 1月 30 23:47:38 jobs-machine systemd[1]: docker.service: Failed with result 'exit-code'. 1月 30 23:47:41 jobs-machine systemd[1]: docker.service: Service hold-off time over, scheduling restart. 1月 30 23:47:41 jobs-machine systemd[1]: Stopped Docker Application Container Engine. 1月 30 23:47:41 jobs-machine systemd[1]: docker.service: Start request repeated too quickly. 1月 30 23:47:41 jobs-machine systemd[1]: Failed to start Docker Application Container Engine. 1月 30 23:47:41 jobs-machine systemd[1]: docker.service: Unit entered failed state. 1月 30 23:47:41 jobs-machine systemd[1]: docker.service: Failed with result 'start-limit-hit'. 解决： 原因 /etc/docker/daemon.json 语法错误 mv /etc/docker/daemon.json /etc/docker/daemon.json.bak vagrant box 错误信息 /usr/lib/ruby/2.3.0/rubygems/specification.rb:949:in `all=': undefined method `group_by' for nil:NilClass (NoMethodError) from /usr/lib/ruby/vendor_ruby/vagrant/bundler.rb:275:in `with_isolated_gem' from /usr/lib/ruby/vendor_ruby/vagrant/bundler.rb:231:in `internal_install' from /usr/lib/ruby/vendor_ruby/vagrant/bundler.rb:102:in `install' from /usr/lib/ruby/vendor_ruby/vagrant/plugin/manager.rb:62:in `block in install_plugin' from /usr/lib/ruby/vendor_ruby/vagrant/plugin/manager.rb:72:in `install_plugin' from /usr/share/vagrant/plugins/commands/plugin/action/install_gem.rb:37:in `call' from /usr/lib/ruby/vendor_ruby/vagrant/action/warden.rb:34:in `call' from /usr/lib/ruby/vendor_ruby/vagrant/action/builder.rb:116:in `call' from /usr/lib/ruby/vendor_ruby/vagrant/action/runner.rb:66:in `block in run' from /usr/lib/ruby/vendor_ruby/vagrant/util/busy.rb:19:in `busy' from /usr/lib/ruby/vendor_ruby/vagrant/action/runner.rb:66:in `run' from /usr/share/vagrant/plugins/commands/plugin/command/base.rb:14:in `action' from /usr/share/vagrant/plugins/commands/plugin/command/install.rb:32:in `block in execute' from /usr/share/vagrant/plugins/commands/plugin/command/install.rb:31:in `each' from /usr/share/vagrant/plugins/commands/plugin/command/install.rb:31:in `execute' from /usr/share/vagrant/plugins/commands/plugin/command/root.rb:56:in `execute' from /usr/lib/ruby/vendor_ruby/vagrant/cli.rb:42:in `execute' from /usr/lib/ruby/vendor_ruby/vagrant/environment.rb:268:in `cli' from /usr/bin/vagrant:173:in `' 解决方案：更新vagrant到最新版本； COPY failed: Forbidden path outside the build context:原因对 build 。 的理解有问题，context 就是。 他不会向上找资源，只会向下递归查找资源，使用 。 上级目录是找不到资源的。 这样设计目的是限制生成上下文占用的资源 docker build -f dockerfile/Dockerfile . 附录一学习资料 Dockerfile 最佳实践 Docker for Java Developers 学习源码 docker-java-sample 有简单的Mvn 和gradle 生成docker image 的案例 mongo-docker-demo docker-javaee A simple Java EE application deployed using WildFly and accessing MySQL database installing-helm 官方网站 Get started with Docker Docker 官网 附录二常用工具 docker-maven-plugin document 如何用Gradle创建Docker镜像]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F13%2F2019-3-23-linux-note%2F</url>
    <content type="text"><![CDATA[第五章、Linux 的文件权限与目录配置用户管理[root@study ~]# groupadd project 交换区总量, 3998716 free－－>空闲交换区总量, 0 used－－>使用的交换区总量. 3327816 avail Mem－－> 进程信息 PID－－>进程ＩＤ USER－－>用户 PR－－>优先级 NI－－>nice值。负值表示高优先级，正值表示低优先级 VIRT－－>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES－－>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR－－>共享内存大小，单位kb S－－>进程状态。 D=不可中断的睡眠状态R=运行 S=睡眠T=跟踪/停止Z=僵尸进程 %CPU－－>上次更新到现在的CPU时间占用百分比 %MEM－－>进程使用的物理内存百分比 TIME+－－>进程使用的CPU时间总计，单位1/100秒 COMMAND－－>命令名/命令行 vmstat - Report virtual memory statistics vmstat 1 4 每一秒采集一次，共采集四次 常用应用场景解析 变量获取，截取，替换，（没设置、空值、非空值） shell中的${}，##和%%的使用 Shell特殊变量：Shell $0, $#, $*, $@, $?, $和命令行参数 bash shell命令行选项与修传入参数处理|变量| 含义|| —- | —- ||$n | $1 the first parameter,$2 the second… ||$# | The number of command-line parameters. ||$0 | The name of current program. ||$? | Last command or function’s return value.||$$ | The program’s PID. ||$! | Last program’s PID. ||$@ | Save all the parameters. | shell比较两个字符串是否相等 文档比较运算符 if 命令参数说明 Shell 条件判断[ -a FILE ] 如果 FILE 存在则为真。 [ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 [ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 [ -d FILE ] 如果 FILE 存在且是一个目录则为真。 [ -e FILE ] 如果 FILE 存在则为真。 [ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。 [ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。 [ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。 [ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。 [ -r FILE ] 如果 FILE 存在且是可读的则为真。 [ -s FILE ] 如果 FILE 存在且大小不为0则为真。 [ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。 [ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。 [ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。 [ -x FILE ] 如果 FILE 存在且是可执行的则为真。 [ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 [ -G FILE ] 如果 FILE 存在且属有效用户组则为真。 [ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 [ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 [ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。 [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 [ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 [ -z STRING ] “STRING” 的长度为零则为真。 [ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 [ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。 [ STRING1 != STRING2 ] 如果字符串不相等则为真。 [ STRING1 < STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。 [ STRING1 > STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。 [ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers. 参考资料 每日一linux命令 第十五章、例行性工作排程（crontab）仅执行一次的工作排程循环执行的例行性工作排程可唤醒停机间工作的排程第二十章、基础系统设定与备份策略20.1 系统基本设定20.1.1 网络设置常用配置#hosts地址 /etc/hosts nmcli 全称是”NetworkManage CommandLine Interface” #1. nmcli device show 查看网络配置简写 nmcli d show #2. nmcli connection show 查看网络状态的简写 nmcli con show # 3 查看网络设备状态 nmcli dev status # 4. 查看网络状态 nmcli dev status # 5.快速修改连接配置 nmcli con mod “eth0” connection.autoconnect no nmcli con mod “eth0” ipv4.dns 172.16.0.1 nmcli con mod “eth0” +ipv4.dns 8.8.8.8 nmcli con mod “eth0” -ipv4.dns 8.8.8.8 nmcli con mod “eth0” ipv4.addresses “172.25.X.10/24 172.25.X.254” nmcli con mod “eth0” +ipv4.addresses 10.10.10.10/16 # 5.1 生效 nmcli con reload #6 激活和禁用网卡 nmcli con down “system eth0” 可被自动激活 nmcli con up “system eth0” nmcli dev dis eth0 禁用网卡，访止被自动激活 注意：如果出现Error: NetworkManager is not running. 重启network service sudo /etc/init.d/network-manager restart 修改完成后禁止NetworkMananger systemctl disable NetworkManager 1） 手动设定 IP 网络参数 查看指定网卡状态 nmcli con show eth0, 重要参数 connection.autoconnect [yes|no] ：是否于开机时启动这个联机，预设通常是 yes 才对！ ipv4.method [auto|manual] ：自动还是手动设定网络参数 设置网络参数 nmcli con modify eth0 [root@study ~]# nmcli con modify eth0 \ > connection.autoconnect yes \ > ipv4.method manual \ > ipv4.addresses 172.16.1.1/16 \ > ipv4.gateway 172.16.200.254 \ > ipv4.dns 172.16.200.254 生效 nmcli con up eth0 验证是否生效 nmcli con show eth0 网络会话配置快速实现IP地址等网络配置的变更 新增网络会话,ens192为 nmcli con show name 栏目下的硬件，设置interface-name网络接口 nmcli con add con-name datacenter-daxing \ ifname ens192 autoconnect no type ethernet \ ip4 172.16.60.100/16 \ gw4 172.16.0.1\ ipv4.dns 202.101.172.35 开启会话 nmcli con up datacenter-daxing 删除会话 nmcli con del datacenter-daxing 第二十一、章 软件安装常用软件安装 软件管理工具 Homebrew for linux 编译工具 go 系统安装说明 tar -C /usr/local -xzf go1.11.5.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin source $HOME/.profile Ubuntu使用snap安装常用软件 VPN（翻墙）影梭Shadowsocks官网 有Client和Server下载，常用配置 Chrome插件：SwitchyOptions.bak下载Ubuntu直接安装 sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5 ss-qt5 软件配置及使用常用配置 Ubuntu下配置支持Windows访问的Samba共享 vim ～/.vimrc hi Comment ctermfg =blue #蓝色注释 git config –global core.editor vim 中文乱码 set fencs=utf-8,GB18030,ucs-bom,default,latin1 设置TABset ts=4 (注：ts是tabstop的缩写，设TAB宽4个空格) set expandtab 对于已保存的文件，可以使用下面的方法进行空格和TAB的替换： TAB替换为空格： :set ts=4 :set expandtab :%retab! 空格替换为TAB： :set ts=4 :set noexpandtab :%retab! 加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。 常用命令 vim FileName +LineNumber == vim + LineNumber Filename 问题解决记录软件安装 使用：sudo apt-get install openvswitch-switch 报错 E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解决： sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock ubuntu adb 安装问题：adb devices: ?????? no permissions解决办法 lsusb ： 查看USB的连接状态 Bus 001 Device 003: ID 04f2:b5a7 Chicony Electronics Co., Ltd Bus 001 Device 006: ID 05c6:9091 Qualcomm, Inc. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub 设置USB # 编辑 sudo echo '"SUBSYSTEM=="usb", ATTR{idVendor}=="05c6", MODE="0666", GROUP="plugdev""' >> /etc/udev/rules.d/70-android.rules # 重启 sudo chmod a+rx /etc/udev/rules.d/70-android.rules sudo service udev restart # adb 重启 adb kill-server adb devices 以上没有下过的都无效果，查看硬件手动重启USB调试是否正常参考： adb devices: ?????? no permissions解决办法 附录 Centos国内下载源 CentOS国内镜像-YUM源更新 日常解决问题 设置影梭代理 #1.临时方案 export ALL_PROXY=socks5://127.0.0.1:1080 #永久方案 echo export ALL_PROXY=socks5://127.0.0.1:1080 >> ~/.bash_profile ubuntu 下 su: Authentication failure sudo passwd root Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully 常用命令Linux termial shortcut 终端操作快捷键 cmd function ctrl + a /&lt;- move to line head ctrl + e/-&gt; move to line tail ctrl + b /f move back/front a char alt + b move back a word ctrl+w delete a word before cursor alt + d delete a word after cursor ctrl +k delete all word after cursor 学习资料博客 Linux shell 常用技巧系列教程]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Basic</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程学习笔记]]></title>
    <url>%2F2019%2F04%2F13%2F2019-3-21-network-coding-note%2F</url>
    <content type="text"><![CDATA[[TOC] 基本知识基本术语Socket操作系统为软件提供输入/出的端口，链接过程Service端监听某个端口，客户端访问服务器端口； int socket(int domain, int type, int protocol); domain：协议域，又称协议族（family）。常用有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等,决定了socket的地址类型,在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type ：指定Socket类型，有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。 SOCK_STREAM 面向连接, 针对于面向连接的TCP服务应用 SOCK_DGRAM 一种无连接, 对应于无连接的UDP服务应用 protocol: 指定协议,有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等 参考： socket百科 TCP/IP Transmission Control Protocol (TCP) and the Internet Protocol (IP) provides end-to-end data communication specifying how data should be packetized, addressed, transmitted, routed, and received. From lowest to highest link layer: containing communication methods for data that remains whichin a single network segment; internet layer: providing internetworking between independent network; transport layer: providing end-to-end comminucation services for applications; applicaton layer: providing services to users and system functions; such as SMTP, FTP, SSH, HTTP 参考： Internet protocol suite Http协议中CookieCookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie,内存Cookie由浏览器维护; HTTP请求中的cookie明文，HTTPS加密，大小限制在4kB 语法 Set-Cookie: &lt;cookie-name>=&lt;cookie-value> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Expires=&lt;date> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Max-Age=&lt;non-zero-digit> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Domain=&lt;domain-value> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Path=&lt;path-value> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Secure Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; HttpOnly Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; SameSite=Strict Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; SameSite=Lax // Multiple directives are also possible, for example: Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Domain=&lt;domain-value>; Secure; HttpOnly 案例Server-&gt;Client Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.169it.com; HttpOnly Set-Cookie: made_write_conn=1295214458; Path=/; Domain=.169it.com Set-Cookie: reg_fb_gate=deleted; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Path=/; Domain=.169it.com; HttpOnly Client-&gt;Server GET /spec.html HTTP/1.1 Host: www.example.org Cookie: name=value; name2=value2 Accept: */* 属性详解 cookie-name： 变量名用于获取cookie-value； Expires：cookie过期时间，可以设置时间小于当前使cookie无效； Path：cookie的有效范围，如Path=”/”整个域名内有效； domain： cookie有效的域名； 参考： Set-Cookie Http协议中Cookie介绍 HTTPS开源库分析OkHttp 3.7源码分析整体架构师分析 Interceptor功能分析 RetryAndFollowUpInterceptor 在网络请求失败后进行重试 当服务器返回当前请求需要进行重定向时直接发起新的请求，并在条件允许情况下复用当前连接 BridgeInterceptor 设置其他报头 设置gzip压缩 CacheInterceptor 请求有符合要求直接返回Cache 服务器返回内容有改变时更新当前cache cache失效删除 ConnectInterceptor 即为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。 CallServerInterceptor 负责向服务器发起真正的访问请求，并在接收到服务器返回后读取响应返回 缓存策略HTTP缓存策略 Expires: 告知客户端对应资源的过期时间 Cache-Control:当前资源的有效期(s),比Expires优先级更高:Cache-Control:max-age=31536000,public 条件GET请求 Last-Modified-Date客户端第一次请求时，服务器返回：Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT,当客户端二次请求时，可以头部加上如下header:If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT如果当前资源没有被二次修改，服务器返回304告知客户端直接复用本地缓存。 ETag: ETag是对资源文件的一种摘要. 当客户端第一次请求某资源时，服务器返回：ETag: &quot;5694c7ef-24dc&quot;客户端再次请求时，可在头部加上如下域：If-None-Match: &quot;5694c7ef-24dc&quot;如果文件并未改变，则服务器返回304告知客户端可以复用本地缓存。 no-cache/no-store: 不使用缓存 only-if-cached:只使用缓存多路复用 实战案例Fiddler 抓包 fiddler Android下https抓包全攻略 Android手机抓包Fiddler设置 手机代理设置 证书安装 用默认的浏览器 电脑抓包 系统代理设置 Fiddler 使用 过滤Android端数据 点击”Rules-&gt;CustomizeRules”; 在这个函数OnBeforeResponse后面添加 if (oSession.oRequest[“User-Agent”].indexOf(“Android”)&gt; -1 &amp;&amp; oSession.HTTPMethodIs(“CONNECT”)) {oSession.oResponse.headers[“Connection”] = “Keep-Alive”; } 如图： 参考： Fiddler 抓包工具总结]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页WEB笔记汇总]]></title>
    <url>%2F2019%2F04%2F13%2F2019-3-7-web-note%2F</url>
    <content type="text"><![CDATA[[TOC] 常用在线编辑（IDE） http://jsfiddle.net/ http://plnkr.co/edit/?p=preview 在线资料 常用对照表 mozilla 提供的 CSS，HTML，Javascript api 【重点应用】 工具 tamperchrome 谷歌推出一个网站开发利器，可以拦截并修改HTTP请求。也就是说，网页跟服务器的通信，你可以轻松监控，随手改掉，HTTPS 请求也可以喔！ 数据可视化分析工具大集合汇总 设计基础知识 Tomcat在Linux上的安装与配置 IntelliJ IDEA (idea)引入eclipse web项目 HTMLElement 和input标签配合 点击label标签，input标签可以获取焦点 具有代码关联性，如在无障碍模式下会读取label作为input的描述 CSS关键字记录 overflow 自己太大的时候该怎么显示 ::after .ribbon::after { content: "This is a fancy orange box."; background-color: #FFBA10; border-color: black; border-style: dotted; } box-shadow /* offset-x | offset-y | blur-radius | color */ box-shadow: 10px 5px 5px black; position position: absolute; // 参照浏览器会跳出父控件的内容范围 position:fixed; // 屏幕滑动时固定 list-style/* type | image | position */ list-style: lower-roman url('../img/shape.png') outside; list-style-type/list-style-image/list-style-position background/* A single image, centered and scaled */ background: no-repeat center/80% url("../img/image.png"); z-index：0 重叠优先级数组越高越在上面 margin /* vertical | horizontal */ margin: 5% auto; /* top | right | bottom | left */ margin: 2px 1em 0 auto; border/* width | style | color */ border: medium dashed green; border: 1px solid black ; 动画 transition /* property name | duration | timing function | delay */ transition: margin-right 4s ease-in-out 1s; /* Global values */ transition: inherit; transition: initial; transition: unset; 教程 https://www.freecodecamp.org/ 何循序渐进有效学习 JavaScript 谈谈WebView的使用【从零开始搭建android框架系列（5）】 全栈工程师培训材料 全栈工程师培训材料，帮助学习者掌握全栈开发的基本知识，承担简单 Web 应用的前后端开发。一共四讲，适合两天的训练营，请先阅读《培训准备》 博客 H5 缓存机制浅析 移动端 Web 加载性能优化 Weex Android SDK源码分析 张鑫旭老师的博客 开源库收集相关开源库 html5-boilerplate Scripto Js 和 Java互调用的库 UI 开源库 material-datetime-picker 时间选择/日期选择 buttons各式各样的Button 可视化语法库 G2 其他案例 我的实操经验分享：如何通过Adsense赚3万美金 SEO 推广 比较喜欢的网站风格https://javalin.io/ https://www.prisma.io/docs/ 附录一常用网站 SVG 案例及属性查询]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础学习笔记；]]></title>
    <url>%2F2019%2F04%2F13%2F2019-3-21-Java-basic%2F</url>
    <content type="text"><![CDATA[[TOC] Java 基础学习Core Java 书籍官网 泛型 方法 public &lt;T&gt; T tell(T t){ return t; } 数组`public static void main(String[] args){ String arr[] = {“java”,”web”}; tell(arr);} public static viod tell(T arr[]){ for(int i=0;i&lt;arr.length;i++){ System.out.println(arr[i]); }} demo private T getObject(Message msg, Class c) { return (T) msg.getData().getParcelable(c.getSimpleName()); } 现实案例： [RxSharePreference.java](https://raw.githubusercontent.com/f2prateek/rx-preferences/master/rx-preferences/src/main/java/com/f2prateek/rx/preferences2/RxSharedPreferences.java) ```java @CheckResult @NonNull public &lt;T&gt; Preference&lt;T&gt; getObject(@NonNull String key, @NonNull T defaultValue, @NonNull Preference.Converter&lt;T&gt; converter) { checkNotNull(key, &quot;key == null&quot;); return new RealPreference&lt;&gt;(preferences, key, defaultValue, new ConverterAdapter&lt;&gt;(converter), keyChanges); } FlowableConversionTest.java from Rxjava public &lt;R, O> O x(Function&lt;Publisher&lt;T>, O> operator) { return operator.apply(onSubscribe); } 基本类型数字 //java7 以后数字可以加下划线 int b = 1_000_000; int by = 0B1111_0100_0010; // 二进制 int x = 0xCAFE;//十六进制 int eight = 010; // 八进制 Float float 4 字节 double 8 字节 3.14F or 3.14D 不写默认为double类型 System.out.println(2.0 - 1.1); // ==&gt; 0.8999999999999999 二进制无法表示 1/10 强转 double x = 9.997; int nx = (int) x; // nx = 9; int nx2 = (int)Math.round(x); // nx2 = 10; int y = 2; y += 3.9; // y = 5; 常用转化 List&lt;Object&gt; list ; Object[] listener = list.toArray(); List&lt;Object&gt; list = Arrays.asList(T... elements); Security Java加密技术 异常 常见异常 ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 常用技巧静态方法导入直接使用 import static java.lang.Math.*; Annotation@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test {} 生命周期 Retention SOURCE: 在源码生效，不会被编译器编译进入class CLASS: class核源码生效，执行时会被vm忽略。未的注释Retention时以class为默认值。 RUNTIME: 作用范围 Targetpublic enum ElementType { /**标明该注解可以用于类、接口（包括注解类型）或enum声明*/ TYPE, /** 标明该注解可以用于字段(域)声明，包括enum实例 */ FIELD, /** 标明该注解可以用于方法声明 */ METHOD, /** 标明该注解可以用于参数声明 */ PARAMETER, /** 标明注解可以用于构造函数声明 */ CONSTRUCTOR, /** 标明注解可以用于局部变量声明 */ LOCAL_VARIABLE, /** 标明注解可以用于注解声明(应用于另一个注解上)*/ ANNOTATION_TYPE, /** 标明注解可以用于包声明 */ PACKAGE, /** * 标明注解可以用于类型参数声明（1.8新加入） * @since 1.8 */ TYPE_PARAMETER, /** * 类型使用声明（1.8新加入) * @since 1.8 */ TYPE_USE } 数据类型package com.zejian.annotationdemo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * Created by wuzejian on 2017/5/19. * 数据类型使用Demo */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface Reference{ boolean next() default false; } public @interface AnnotationElementDemo { //枚举类型 enum Status {FIXED,NORMAL}; //声明枚举 Status status() default Status.FIXED; //布尔类型 boolean showSupport() default false; //String类型 String name()default ""; //class类型 Class&lt;?> testCase() default Void.class; //注解嵌套 Reference reference() default @Reference(next=true); //数组类型 long[] value(); } 默认赋值方式默认会赋值给value方法 package com.zejian.annotationdemo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * Created by zejian on 2017/5/20. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */ //定义注解 @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface IntegerVaule{ int value() default 0; String name() default ""; } //使用注解 public class QuicklyWay { //当只想给value赋值时,可以使用以下快捷方式 @IntegerVaule(20) public int age; //当name也需要赋值时必须采用key=value的方式赋值 @IntegerVaule(value = 10000,name = "MONEY") public int money; } 反射中的使用查看 反射Annotation 常用注解 @Documented 被修饰的注解会生成到javadoc中 @Inherited 可以让注解被继承 enum Java 枚举(enum) 详解7种常见的用法 深入理解public class EnumDemo { public static void main(String[] args){ //直接引用 Day day =Day.MONDAY; } } //定义枚举类型 enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } 编译 javac EnumDemo.java 反编译 final class Day extends Enum { //编译器为我们添加的静态的values()方法 public static Day[] values() { return (Day[])$VALUES.clone(); } //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法 public static Day valueOf(String s) { return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s); } //私有构造函数 private Day(String s, int i) { super(s, i); } //前面定义的7种枚举实例 public static final Day MONDAY; public static final Day TUESDAY; public static final Day WEDNESDAY; public static final Day THURSDAY; public static final Day FRIDAY; public static final Day SATURDAY; public static final Day SUNDAY; private static final Day $VALUES[]; static { //实例化枚举实例 MONDAY = new Day("MONDAY", 0); TUESDAY = new Day("TUESDAY", 1); WEDNESDAY = new Day("WEDNESDAY", 2); THURSDAY = new Day("THURSDAY", 3); FRIDAY = new Day("FRIDAY", 4); SATURDAY = new Day("SATURDAY", 5); SUNDAY = new Day("SUNDAY", 6); $VALUES = (new Day[] { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }); } } 反射//正常使用 Day[] ds=Day.values(); //向上转型Enum Enum e = Day.MONDAY; //无法调用,没有此方法 //e.values(); //获取class对象引用 Class&lt;?> clasz = e.getDeclaringClass(); if(clasz.isEnum()) { Day[] dsz = (Day[]) clasz.getEnumConstants(); System.out.println("dsz:"+Arrays.toString(dsz)); } /** 输出结果: dsz:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY] */ 覆盖enum类方法package com.zejian.enumdemo; /** * Created by zejian on 2017/5/8. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */ public enum Day2 { MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"), THURSDAY("星期四"), FRIDAY("星期五"), SATURDAY("星期六"), SUNDAY("星期日");//记住要用分号结束 private String desc;//中文描述 /** * 私有构造,防止被外部调用 * @param desc */ private Day2(String desc){ this.desc=desc; } /** * 覆盖 * @return */ @Override public String toString() { return desc; } public static void main(String[] args){ for (Day2 day:Day2.values()) { System.out.println("name:"+day.name()+ ",desc:"+day.toString()); } } /** 输出结果: name:MONDAY,desc:星期一 name:TUESDAY,desc:星期二 name:WEDNESDAY,desc:星期三 name:THURSDAY,desc:星期四 name:FRIDAY,desc:星期五 name:SATURDAY,desc:星期六 name:SUNDAY,desc:星期日 */ } 抽象方法package com.zejian.enumdemo; /** * Created by zejian on 2017/5/9. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */ public enum EnumDemo3 { FIRST{ @Override public String getInfo() { return "FIRST TIME"; } }, SECOND{ @Override public String getInfo() { return "SECOND TIME"; } } ; /** * 定义抽象方法,每个枚举都要实现这个抽象方法 * @return */ public abstract String getInfo(); //测试 public static void main(String[] args){ System.out.println("F:"+EnumDemo3.FIRST.getInfo()); System.out.println("S:"+EnumDemo3.SECOND.getInfo()); /** 输出结果: F:FIRST TIME S:SECOND TIME */ } } 与接口public enum Meal{ APPETIZER(Food.Appetizer.class), MAINCOURSE(Food.MainCourse.class), DESSERT(Food.Dessert.class), COFFEE(Food.Coffee.class); private Food[] values; private Meal(Class&lt;? extends Food> kind) { //通过class对象获取枚举实例 values = kind.getEnumConstants(); } public interface Food { enum Appetizer implements Food { SALAD, SOUP, SPRING_ROLLS; } enum MainCourse implements Food { LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO; } enum Dessert implements Food { TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL; } enum Coffee implements Food { BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA; } } } 枚举单利/** * Created by wuzejian on 2017/5/9. * 枚举单利 */ public enum SingletonEnum { INSTANCE; private String name; public String getName(){ return name; } public void setName(String name){ this.name = name; } } EnumMap Map&lt;Color,Integer> enumMap=new EnumMap&lt;>(Color.class); Key 值必须是枚举类型； 使用EnumMap比HashMap会更加高效 EnumSet 内部实现是位向量,直接存储和操作都是bit，因此EnumSet空间和时间性能都十分可观 EnumSet不允许使用 null 元素 线程不安全 用法创建一个具有指定元素类型的空EnumSet。 EnumSet&lt;E> noneOf(Class&lt;E> elementType) //创建一个指定元素类型并包含所有枚举值的EnumSet &lt;E extends Enum&lt;E>> EnumSet&lt;E> allOf(Class&lt;E> elementType) // 创建一个包括枚举值中指定范围元素的EnumSet &lt;E extends Enum&lt;E>> EnumSet&lt;E> range(E from, E to) // 初始集合包括指定集合的补集 &lt;E extends Enum&lt;E>> EnumSet&lt;E> complementOf(EnumSet&lt;E> s) // 创建一个包括参数中所有元素的EnumSet &lt;E extends Enum&lt;E>> EnumSet&lt;E> of(E e) &lt;E extends Enum&lt;E>> EnumSet&lt;E> of( E... rest) //创建一个包含参数容器中的所有元素的EnumSet &lt;E extends Enum&lt;E>> EnumSet&lt;E> copyOf(EnumSet&lt;E> s) &lt;E extends Enum&lt;E>> EnumSet&lt;E> copyOf(Collection&lt;E> c) // 不会copy重复的值 参考 深入理解Java枚举类型(enum) 反射类的实例化// 1. class //获取Class对象的引用 clazz = Class.forName("study.reflect.User"); //第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常 User user = (User) clazz.newInstance(); // 2. public constructor //获取带String参数的public构造函数 Constructor cs1 =clazz.getConstructor(String.class); //创建User User user1= (User) cs1.newInstance("xiaolong"); // 3. private constructor Constructor cs2=clazz.getDeclaredConstructor(int.class,String.class); //由于是private必须设置可访问 cs2.setAccessible(true); //创建user对象 User user2= (User) cs2.newInstance(25,"lidakang"); //获取所有构造包含private Constructor&lt;?> cons[] = clazz.getDeclaredConstructors(); //获取构造函数参数类型 Class&lt;?> clazzs[] = cons[i].getParameterTypes(); Field类及方法 方法返回值 方法名称 方法说明 Field getDeclaredField(String name) (包含private修饰的)字段，不包括继承的字段 Field[] getDeclaredField() 获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段 Field getField(String name) 获取具有public修饰的字段，包含继承字段 Field[] getField() 获取修饰符为public的字段，包含继承字段 Field 常用操作 Class claz = Class.forName("study.reflect.TestReflect$Animal"); Field field = claz.getDeclaredField("name"); System.out.println("field-->" + field.getType()); System.out.println("toGenericString-->" + field.toGenericString()); System.out.println("getDeclaringClass-->" + field.getDeclaringClass()); //study.reflect.TestReflect$Animal //field-->class java.lang.String //toGenericString-->private java.lang.String //study.reflect.TestReflect$Animal.name //getDeclaringClass-->class study.reflect.TestReflect$Animal Method类及用法get Method方法包含父类 //根据参数获取public的Method,包含继承自父类的方法 Method method = clazz.getMethod("draw",int.class,String.class); //获取所有public的方法:包含父类 Method[] methods =clazz.getMethods(); 方法不包含父类 //可以获取privat, 无法获取父类方法 Method method1 = clazz.getDeclaredMethod("drawCircle"); Method[] methods1=clazz.getDeclaredMethods(); Invokeinvoke(Object obj,Object... args) Array基本用法//获取类型 Class&lt;?> clazz = array.getClass().getComponentType(); // new 一个指定类型的Array Object newArr = Array.newInstance(clazz, 15); int co = Array.getLength(array); //copy 赋值原数组到新数组 System.arraycopy(array, 0, newArr, 0, co); // setter/getter Array.set(newArr, 5/*pos*/, 3); Array.get(newArra,5) 案例Array的动态创建, 无效语句T[] a = new T[]; /** * 接收一个泛型数组，然后创建一个长度与接收的数组长度一样的泛型数组， * 并把接收的数组的元素复制到新创建的数组中， * 最后找出新数组中的最小元素，并打印出来 * @param a * @param &lt;T> */ public &lt;T extends Comparable&lt;T>> void min(T[] a) { //通过反射创建相同类型的数组 T[] b = (T[]) Array.newInstance(a.getClass().getComponentType(), a.length); for (int i = 0; i &lt; a.length; i++) { b[i] = a[i]; } T min = null; boolean flag = true; for (int i = 0; i &lt; b.length; i++) { if (flag) { min = b[i]; flag = false; } if (b[i].compareTo(min) &lt; 0) { min = b[i]; } } System.out.println(min); } 反射Annotation//指定类型是否存在 isAnnotationPresent(Class&lt;? extends Annotation> annotationClass) //得到指定的注解，没有返回null clazz.getAnnoations(Depressed.class) Annotation[] annote1 = getAnnotations() //不包括父类 Annotation[] annote2 = getDeclaredAnnotations() 常用反射操作 /** * 修饰符、父类、实现的接口、注解相关 */ //获取修饰符，返回值可通过Modifier类进行解读 public native int getModifiers(); //获取父类，如果为Object，父类为null public native Class&lt;? super T> getSuperclass(); //对于类，为自己声明实现的所有接口，对于接口，为直接扩展的接口，不包括通过父类间接继承来的 public native Class&lt;?>[] getInterfaces(); //自己声明的注解 public Annotation[] getDeclaredAnnotations(); //所有的注解，包括继承得到的 public Annotation[] getAnnotations(); //获取或检查指定类型的注解，包括继承得到的 public &lt;A extends Annotation> A getAnnotation(Class&lt;A> annotationClass); public boolean isAnnotationPresent(Class&lt;? extends Annotation> annotationClass); /** * 内部类相关 */ //获取所有的public的内部类和接口，包括从父类继承得到的 public Class&lt;?>[] getClasses(); //获取自己声明的所有的内部类和接口 public Class&lt;?>[] getDeclaredClasses(); //如果当前Class为内部类，获取声明该类的最外部的Class对象 public Class&lt;?> getDeclaringClass(); //如果当前Class为内部类，获取直接包含该类的类 public Class&lt;?> getEnclosingClass(); //如果当前Class为本地类或匿名内部类，返回包含它的方法 public Method getEnclosingMethod(); /** * Class对象类型判断相关 */ //是否是数组 public native boolean isArray(); //是否是基本类型 public native boolean isPrimitive(); //是否是接口 public native boolean isInterface(); //是否是枚举 public boolean isEnum(); //是否是注解 public boolean isAnnotation(); //是否是匿名内部类 public boolean isAnonymousClass(); //是否是成员类 public boolean isMemberClass(); //是否是本地类 public boolean isLocalClass(); enum 反射public enum RunnableState{ RUNNING, ERROR, DONE } public static void main(String[] args) { Class clazz = RUNNING.getClass(); Object[] enumConstants = clazz.getEnumConstants(); for (Object enumConstant : enumConstants) { System.out.println(enumConstant); } } //========= out ======== RUNNING ERROR DONE //====================== 关键字 assert false ; 在jvm的参数，参数是-ea或者-enableassertions 抛出java.lang.AssertionErro。增加错误信息，assert false : &quot;这个异常没有性格&quot;; Clone浅度拷贝/深度拷贝 //1.直接强转只能克隆基本数据类型，原因是clone方法只是复制了相同的内存块 @Override protected Student clone() throws CloneNotSupportedException { return (Student) super.clone(); } //2.存在非基本数据类型的克隆方法 @Override protected Student3 clone() throws CloneNotSupportedException { Student3 stu = (Student3) super.clone(); stu.bag = bag.clone(); return stu; } //3.有些类是不能拷贝的如：StringBuffer没有重载clone()方法 读写操作 Java IO教程.英文 Java IO教程.中文 Apache Commons IO FileUtils Apache Commons IO 教程 监控监控工具 java自带的监控工具VisualVM一 jstat JVM分析工具 Java常用命令javap -c PathForClazz.class 查看class汇编指令 常用工具正则表达式元字符 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符，空格回车 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”； Mac系统里，每行结尾是“&lt;回车&gt;”,即“\r”。 Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”； Mac系统里，每行结尾是“&lt;回车&gt;”,即“\r”。 而UNIX/Linux采用换行符LF表示下一行，即\n 苹果机(MAC OS系统)则采用回车符CR表示下一行，即\r 常用的限定符 重复 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 反义 代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 后向引用 JAVA 正则表达式 （超详细) 正则表达式30分钟入门教程 Ratifier 集中了Android验证的库,列如: Mobile Number: /^(+\d{1,3}[- ]?)?\d{10}$/ Email Address: /^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ URL: /^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-])/?$/ IP Address:/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ 正则表达式30分钟入门教程笔记简单的白话翻译 白话 正则翻译 精确地查找hi这个单词 \bhi\b hi后面不远处跟着一个Lucy \bhi\b.*\bLucy\b 以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字 0\d{2}-\d{8} QQ号必须为5位到12位数字 ^\d{5,12}$ 匹配deerchao.net deerchao\.net 匹配C:\Windows C:\\Windows 匹配Windows后面跟1个或更多数字 Windows\d+ 匹配一行的第一个单词 ^\w+ 匹配任何一个英文元音字母 [aeiou] 匹配标点符号(.或?或!) [.?!] \S+ 匹配不包含空白符的字符串 &lt;a[^&gt;]+&gt; 用尖括号括起来的以a开头的字符串 \b(\w+)\b\s+\1\b 匹配重复的单词，像go go 复杂的阅读理解| 正则 | 翻译 || :———————————————————: | :————–: ||0\d{2}-\d{8}| 0\d{3}-\d{7}|匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)||(0\d{2})[- ]?\d{8}| 0\d{2}[- ]?\d{8}|匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔||(\d{1,3}.){3}\d{1,3}|简单的IP地址匹配||\b\w+(?=ing\b)|以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc||(?&lt;=\bre)\w+\b|以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading||((?&lt;=\d)\d{3})+\b|234567890进行查找时结果是234567890||(?&lt;=\s)\d+(?=\s)|以空白符间隔的数字(再次强调，不包括这些空白符)||\d{3}(?!\d)|三位数字，而且这三位数字的后面不能是数字||\b((?!abc)\w)+\b|不包含连续字符串abc的单词||(?&lt;![a-z])\d{7}|前面不是小写字母的七位数字||(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)|匹配不包含属性的简单HTML标签内里的内容| 匹配IP地址:((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) 正则表达式——详细讲解平衡组 JavaDoc实战案例 Class Level /** * Hero is the main entity we'll be using to . . . * * Please see the {@link com.baeldung.javadoc.Person} class for true identity * @author Captain America * */ public class SuperHero extends Person { // fields and methods } Field Level /** * The public name of a hero that is common knowledge */ private String heroName; Method Level /** * Factory for {@linkplain Call calls} // 连接到其他类的说明 * &lt;h3>OkHttpClients should be shared&lt;/h3> //设置字体大小 * {@link #newBuilder()} // 连接本地方法 * {@link ExecutorService#shutdown shutdown()} // 连接其他类的方法 * &lt;p>This is a simple description of the method. . . // &lt;p> 能实现换行功能 * &lt;a href="http://www.supermanisthegreatest.com">Superman!&lt;/a> * &lt;/p> * //代码块 * &lt;pre> {@code * // The singleton HTTP client. * public final OkHttpClient client = new OkHttpClient.Builder() * .addInterceptor(new HttpLoggingInterceptor()) * .cache(new Cache(cacheDir, cacheSize)) * .build(); * }&lt;/pre> * {@code String} //{@code text} 将文本标记为code 一般在Javadoc中只要涉及到类名或者方法名，都需要使用@code进行标记 * &lt;ul>&lt;li>{@code toffset} is negative. // 无符号列表 * &lt;li>{@code ooffset} is negative. * &lt;li>{@code toffset+len} is greater than the length of this * {@code String} object. * &lt;li>{@code ooffset+len} is greater than the length of the other * &lt;/ul> * @param incomingDamage the amount of incoming damage * @return the amount of health hero has after attack * @see &lt;a href="http://www.link_to_jira/HERO-402">HERO-402&lt;/a> * @since 1.0 * @version 版本 */ public int successfullyAttacked(int incomingDamage) { // do things return 0; } javadoc -d doc src\* 生成 maven plugin mvn javadoc:javadoc &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-javadoc-plugin&lt;/artifactId> &lt;version>3.0.0&lt;/version> &lt;configuration> &lt;source>1.8&lt;/source> &lt;target>1.8&lt;/target> &lt;/configuration> &lt;tags> ... &lt;/tags> &lt;/plugin> &lt;/plugins> &lt;/build> Custom TAG javadoc -tag location:a:“Notable Locations:”-d doc src* /** * This is an example... * @location New York * @returns blah blah */ @location 替换成 Notable Locations: above maven plugin ... &lt;tags> &lt;tag> &lt;name>location&lt;/name> &lt;placement>a&lt;/placement> &lt;head>Notable Places:&lt;/head> &lt;/tag> &lt;/tags> ... 参考 How to Write Doc Comments for the Javadoc Tool Java 高级JVM1. ClassLoader 介绍1.1 结束一个JVM的生命周期方式 1.2 类加载的三中方式 验证 -&gt; 确保被加载类的正确性 准备 -&gt; 为类的静态变量分配内存，将其初始化为默认值 解析 -&gt; 把类中的符号引用转换为直接应用 初始化 -&gt; 为类的静态变量赋予正确的初始化值 1.4 主动使用 除了以下六个，其余的都是被动使用，不会导致类的初始化 new, 直接使用 访问某个类或者接口的静态变量，或者对静态变量进行赋值操作 访问类的静态变量会初始化class 调用静态方法 反射某个类 初始化一个子类 启动类，比如：java HelloWorld 1.5 被动使用 三种易错的被动使用 通过子类访问父类的static变量，不会导致子类的初始化 定义引用数组，不会初始化类 final修饰的常量会在编译期间放到常量池中，不会初始化类 final修饰的复杂类型，在编译期间无法计算得出，会初始化类 2. 类加载详解2.1 加载类的方式 本地磁盘加载 内存直接加载 网络加载 URLClassLoader 从zip,jar等归档文件中加载.class文件 数据库中提取.class文件 动态编译 2.2 JVM内存简介 Execution engine功能：执行classes中的指令 Native interface组件：与native libraries交互 Runtime Data Area组件也就是JVM内存 2.2.1 Program Counter Register 2.2.2 Java Virtual Machine Stacks 2.2.3 Heap Memory 2.2.4 Method Area 2.2.5 Run-time Constant Pool 2.2.6 Native Method Stack Class and Object in the Memory 创建对象的过程 3. 类的连接详解3.1 验证 字节流中包含的信息符合虚拟机的要求，并不会损害到JVM自身安全 文件格式验证 魔术因子是否正确，0xCAFEBABE 主从版本号是否符合当前虚拟机 常量池中的常量类型是不是支持 … 元素数据验证 字节码验证 字符号引用验证 3.2 准备阶段 初始值 3.3 解析 3.4 初始化 4. 类的初始化详解5. 类加载器（JDK自带）详细介绍 JVM自带的几种加载器根（Bootstrap） 负责加载核心类库，如java.lang.*等。 指定加载目录为System.getProperty(&quot;sun.boot.class.path&quot;) 没有继承ClassLoader类，没有父加载器； 扩展（Extension）类加载器 父加载器为Bootstrap； 指定加载目录为System.getProperty(“java.ext.dirs”)，或者从jdk/jre/lib/ext 中加载 系统（System）类加载器 父家加载器为Extension； 指定加载目录为classpath或System.getProperty(“java.class.path”)指定目录 用户自定义类默认加载器 6. 类加载的父委托机制 先有父加载，父加载不到再由儿子孙子加载，Tomcat的加载器机制和JVM正好相反 父加载器和子加载器其实是一种包装关系，或者包含关系 优点： 能提高系统的安全性，在此机制下，用户自定义的类加载器不可能加载应该有父加载器加载的可靠类，防止恶意的代码代替父加载的可靠代码 7. 命名空间&amp;运行时包命名空间每个类的加载器都有子的命名空间，命名空间由该加载器及其所有父加载器所加载的类组成。 运行时包 父类家加载器看不到子类加载器加载的类 不同命名空间下的类加载器之间的类互相不可访问 8. 创建自定义类加载器9. 类的卸载 JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）: 该类所有的实例都已经被GC。 加载该类的ClassLoader实例已经被GC。 该类的java.lang.Class对象没有任何地方被引用。 GC的时机我们是不可以控的，那么同样的我们对于Class的卸载也是不可控的。 10. 自定义解密加密类加载器11. 线程上下文加载器 SPI（Service Provider Interface） is an API intended to be implemented or extended by a third party. It can be used to enable framework extension and replaceable components. for example jdbc, jndi,jms in the rt.jar. The reason for ContextLoader: rt.jar was loaded by BootClassLoader, but the implementation is loaded by AppClassLoader JDBC examplecom.mysql.jdbc.Driver static{ try{ java.sql.DriverManager.registerDriver(new Driver()); }catch(SQLException E){ throw new RuntimeException("Cann't register driver!"); } } Custom Context Class LoaderThread.currentThread().setContextClassLoader(new MyClassLoader()); System.out.println(Thread.currentThread().getContextClassLoader()); 12. 关于JVM类加载器的总结附录 The Java Virtual Machine Specification Java SE 8 Edition Java实战笔记class声明为final的好处 不会被重载 Vm产生更快codes 防止自己改的代码影响到客户 多线程使用安全 针对Final的优化 Jvm和Application有针对final的缓存 Final keyword allows JVM to optimized method, variable or class. jit能够避免使用虚函数表 结论：能用final尽量使用final 运行Java代码Exmaple.java #编译Java代码成.class javac Exmaple.java # 运行.class文件 java -cp . Example #后台运行 nohup java -cp . Exmaple # 查看后台运行日志 tail -f nohup.out 问题解决 Intellij idea 报错：Error : java 不支持发行版本5 学习资源 JCSprout 处于萌芽阶段的 Java 核心知识库 Core Java Cookbooks and Examples 很好的深入Java基层系列 深入理解Java类型信息(Class对象)与反射机制 深入理解Java枚举类型(enum) 深入理解Java注解类型(@Annotation) 深入理解Java并发之synchronized实现原理 深入理解Java内存模型(JMM)及volatile关键字 深入理解Java类加载器(ClassLoader) 附录javase 11 API 官方文档搜索 工具Expresso 正则工具http://www.ultrapico.com/ExpressoDownload.htm]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程笔记汇总]]></title>
    <url>%2F2019%2F04%2F13%2F2019-4-13-netwok_pragram_note%2F</url>
    <content type="text"><![CDATA[[TOC] 基本知识基本术语Socket操作系统为软件提供输入/出的端口，链接过程Service端监听某个端口，客户端访问服务器端口； int socket(int domain, int type, int protocol); domain：协议域，又称协议族（family）。常用有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等,决定了socket的地址类型,在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type ：指定Socket类型，有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。 SOCK_STREAM 面向连接, 针对于面向连接的TCP服务应用 SOCK_DGRAM 一种无连接, 对应于无连接的UDP服务应用 protocol: 指定协议,有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等 参考： socket百科 TCP/IP Transmission Control Protocol (TCP) and the Internet Protocol (IP) provides end-to-end data communication specifying how data should be packetized, addressed, transmitted, routed, and received. From lowest to highest link layer: containing communication methods for data that remains whichin a single network segment; internet layer: providing internetworking between independent network; transport layer: providing end-to-end comminucation services for applications; applicaton layer: providing services to users and system functions; such as SMTP, FTP, SSH, HTTP 参考： Internet protocol suite Http协议中CookieCookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie,内存Cookie由浏览器维护; HTTP请求中的cookie明文，HTTPS加密，大小限制在4kB 语法 Set-Cookie: &lt;cookie-name>=&lt;cookie-value> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Expires=&lt;date> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Max-Age=&lt;non-zero-digit> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Domain=&lt;domain-value> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Path=&lt;path-value> Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Secure Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; HttpOnly Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; SameSite=Strict Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; SameSite=Lax // Multiple directives are also possible, for example: Set-Cookie: &lt;cookie-name>=&lt;cookie-value>; Domain=&lt;domain-value>; Secure; HttpOnly 案例Server-&gt;Client Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.169it.com; HttpOnly Set-Cookie: made_write_conn=1295214458; Path=/; Domain=.169it.com Set-Cookie: reg_fb_gate=deleted; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Path=/; Domain=.169it.com; HttpOnly Client-&gt;Server GET /spec.html HTTP/1.1 Host: www.example.org Cookie: name=value; name2=value2 Accept: */* 属性详解 cookie-name： 变量名用于获取cookie-value； Expires：cookie过期时间，可以设置时间小于当前使cookie无效； Path：cookie的有效范围，如Path=”/”整个域名内有效； domain： cookie有效的域名； 参考： Set-Cookie Http协议中Cookie介绍 URL Uniform Resource Locator / 同一资源定位器 格式 scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment] 案例： http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument 浏览器处理URL完整过程 网络协议经典五层模型 HTTP基础HTTP历史 HTTP/1.1持久连接， Pipeline（并行/串行传输），增加host命令 HTTP2 所有数据进行二进制传输，带来的好处： 同一个连接里面发送多个请求不需要按照顺序 同信息压缩以及推送等提高效率的功能三次握手 三次握手时序图 HTTP报文 响应状态码 1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急… 2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息. 3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。 4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。 5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。 常见的HTTP响应报文头Cache-Control Cacheability public private 只有浏览器可以缓存数据，代理是不允许缓存的 no-store The cache should not store anything about the client request or server response. 到期 Cache-Control: max-age=3600 让客户端对响应内容缓存3600秒,如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户 s-maxage=&lt;seconds&gt; 代理服务器读取 max-stale=&lt;seconds&gt;过期后是继续使用缓存，发起端设置 重新认证(revalidation and reloading) must-revaliadate Indicates that once a resource has become stale (e.g. max-age has expired), a cache must not use the response to satisfy subsequent requests for this resource without successful validation on the origin server. proxy-revalidate Same as must-revalidate, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache. other no-transform The Content-Encoding, Content-Range, Content-Type headers must not be modified by a proxy on HTTPS is redundant 判断Contentg Keep-alive 长连接 Connection: keep-alive Connection: close CORS跨域'Access-Control-Allow-Origin': '*' // 所有的网站可以用 'Access-Control-Allow-Origin': 'https:www.bai.com' 'Access-Control-Allow-Headers': 'X-text-Cors' // 允许指定头访问 'Access-Control-Allow-Methods': 'POST, PUT,DELETE ' // 允许指定方法 'Access-Control-Max-Age': '1000' // 允许以上种方式跨域的时间 数据协商·1. Accept 'Accept-Encoding' 'Accept-Language' 'User-Agent' Content 'Content-Type' 'Content-Encoding':'gzip,br,defalte' 'Content-Language':'zh-cn' redirectconst http = require('http') http.createServer(function(request, response){ console.log('request come',request.url) response.writeHead(302/*每次都重定向*/,{ 'Location':'/new' }) response.end('') if(request.url == 'new'){ response.writeHead(200,{ 'Content-Type':'text/html' }) } }).listen(8887) 301 Sample ... response.writeHead(301 /*告诉浏览器，如果下次在访问/ 直接重定向到/new，是永久的变更*/,{ 'Location':'/new' }) ... 301 会缓存到浏览器缓存中，除非请缓存否则，浏览器不会访问旧地址，故使用的时候需非常谨慎 Content-Security-Policy（CSP） 限制资源获取 报告资源获取越权 限制方式 deafault-src: 限制全局 //限制通过http/https的方式加载，禁止内联方式加载防止js注入 'Content-Security-Policy': 'default-src http: https:' // 限制本域名方式加载，不能限制form表单提交 'Content-Security-Policy': 'default-src \'self\'' //限制form表单提交 'Content-Security-Policy': 'default-src \'self\'; from-action \'self\'' 限制特定的资源类型： connect-src,img-src,font-src,media-src,style-src,script-src,frame-src Content-Security-Policy-Report-Only 只提交不限制 meta 形式 &lt;meta http-equiv="", content="content-src 'self'; from-action 'self'"> 参考： 实战案例 缓存的简单使用 if(request.url == '/script.js'){ // 针对js文件进行缓存 response.writeHead(200,{ 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=200' }) respone.end('console.log("script loaded twice")') } 对一下不常变动的资源进行缓存; 对JavaScript进行打包加入hashcode, hash 值变动不使用服务器缓存 验证头 Last-Modified 上次修改时间，配合If-Modified-Since或者If-Unmodified-Since使用 Etag 数据签名，配合If-Match或者If-Non_Match使用，对比资源签名判断是否使用缓存 Sample: if(request.url == '/script.js'){ const etag = request.headers['if-none-match'] if(etag=='777'){ response.writeHead(304/*告诉浏览器使用缓存*/,{ 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=2000,no-Cache', 'Last-Modified': '123', 'Etag': '777' }) response.end('123'); }else{ response.writeHead(304,{ 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=2000,no-Cache', 'Last-Modified': '123', 'Etag': '777' }) respone.end('console.log("script loaded twice")') } } no-cache和no-store的区别 no-cache 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用no-store 彻底得禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取 Cookie and session response.writeHead(200,{ 'Content-Type': 'text/html', 'Set-Cookie': ['id=123;max=32', 'abc=456'; 'HttpOnly'/*禁止Js访问*/] }) // js 中读取 document.cookie HTTPSHTTPS 握手过程 配置签名 服务器配置https协议，三种免费的方法 阿里云 nginx配置ssl证书实现https访问 问题解决HTTP2优势 信道复用 分帧传输 Server Push 压缩头 请求分级 兼容HTTP 1.0 HTTP1. 1 存在的问题 浏览器创建连接数有限制Chrome 6个， 多于6个就等待 信道不复用，握手消耗大 不能分帧传输，只能处理完一个请求后处理另一个请求 实战案例 Server push 提升%8的速度 //通过response 响应头中添加如下 Link: &lt;/styles.css>; rel=preload; as=style, &lt;/example.png>; rel=preload; as=image springboo2开启http2 参考 HTTP/2.0 中英文对照 HTTP 2.0在OKHttp中的应用 HTTP/2 HTTP/2 头部压缩技术介绍 WebSocket WebSocket 是独立的、创建在 TCP 上的协议 基本知识优点 较少的控制开销 全双工 更好的二进制支持 更好的压缩效果 支持网页 可以支持扩展 扩展 性能测试的一些测试结果 使用四种框架分别实现百万websocket常连接的服务器 七种WebSocket框架的性能比较 建立连接的过程Client –&gt; Server 发起HTTP 1.1 GET 方法的重点头部信息 GET / HTTP/1.1 Host: localhost:8080 Origin: http://127.0.0.1:3000 Connection: Upgrade Upgrade: websocket Sec-WebSocket-Version: 13 Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw== ... ​ 【Remark】： 上面是一个标准的GET请求，省略了一下内容， 如Host、Origin、Cookie等 握手阶段可以进行安全限制和权限校验 Server response 101 switch protocols successfully HTTP/1.1 101 Switching Protocols Connection:Upgrade Upgrade: websocket Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU= ... 【Remark】at the end of header must be \r\n , the end of request must new a empty line with \r\n Where the Sec-WebSocket-Accept come from >toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ) ) Base Framing Protocol 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ 详细定义参考 RFC6455 5.2节 Masking-key algorithm original-octet-i：为原始数据的第i字节。 transformed-octet-i：为转换后的数据的第i字节。 j：为i mod 4的结果。 masking-key-octet-j：为mask key第j字节。 j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j Data transmission 基于数据帧的传递。 WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。 数据分片的例子 Writing WebSocket servers Heart Beat 发送方-&gt;接收方：ping 接收方-&gt;发送方：pong ws.ping('', false, true); More With websocket extension we can add a lot of capability and imagination to this protocol, for example data compression, encryption，multiplexing 实践 SpringBoot2.0集成WebSocket，实现后台向前端推送信息 相关连接RFC6455：websocket规范https://tools.ietf.org/html/r… 规范：数据帧掩码细节https://tools.ietf.org/html/r… 规范：数据帧格式https://tools.ietf.org/html/r… server-examplehttps://github.com/websockets… 编写websocket服务器https://developer.mozilla.org… 对网络基础设施的攻击（数据掩码操作所要预防的事情）https://tools.ietf.org/html/r… Talking to Yourself for Fun and Profit（含有攻击描述）http://w2spconf.com/2011/pape… What is Sec-WebSocket-Key for?https://stackoverflow.com/que… 10.3. Attacks On Infrastructure (Masking)https://tools.ietf.org/html/r… Talking to Yourself for Fun and Profithttp://w2spconf.com/2011/pape… Why are WebSockets masked?https://stackoverflow.com/que… How does websocket frame masking protect against cache poisoning?https://security.stackexchang… What is the mask in a WebSocket frame?https://stackoverflow.com/que… 常用工具Wireshark 过滤报文 Analyze -&gt; display filters nginx配置导入servers/目录下所有conf文件 include servers/*.conf; servers/test.conf server { listen 80; server_name test.com; location / { proxy_pass http://127.0.0.1:8888; #设置host为浏览器的host，而不是代理host`http://127.0.0.1:8888` proxy_set_header Host $host; } } 代理缓存nginx 配置缓存目录 proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m ... server{ location /{ proxy_cache my_cache; } } 后台设置返回头 'Cache-Control':'max-age=2,s-maxage=20', 'Vary':'X-Test-Cache' // 只有Vary的值是相同的情况下使用缓存 前端设置增加返回头 fetch('/data',{ headers:{ 'X-Test-Cache': index ++ } }).then(function(resp){ return resp.text() }).then(function(text){ data.innerText = text }) 只有Vary的值是相同的情况下使用缓存 应用场景 使用服务器缓存，但PC端和移动端可能拿到的数据是不一样的，当Vary值是一样的时候才使用缓存， 如果不一样他们分别是不同的缓存 lang=zh 或者en， 是不同的缓存 可优化 默认nginx缓存写在磁盘上，可以写个脚本把缓存放到服务器上 参考： Nginx HTTP缓存设置 nginx proxy_cache 缓存配置 【精彩博文】 HTTPS配置支持HTTPSserver{ listen 443; server_name test.com; ssl on; ssl_certificate_key ../certs/localhost-privkey.pem ssl_certificate ../certs/localhost-cert.pem location / { proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } HTTP自动跳转到HTTPSserver｛ listen 80 default_server; listen [::]:80 default_server; server_name test.com #https://test.com/path #server_name == test.com, #request_uri = /path return 302 https://$server_name$request_uri; ｝ HTTP2 服务器返回头 'Content-Type':'text/html', 'Connection':'close', 'Like':'&lt;/test.jpg>; as=image;rel=preload' # 服务器推送test.jpg（绝对路径）, 类型为image，repload 需要服务器的推送 Link: &lt;/styles.css>; rel=preload; as=style, &lt;/example.png>; rel=preload; as=image nginx 把http2转化成http server{ listen 443 http2; server_name test.com; http2_push_preload on; } 使用nginx转化的原因 nginx配置简单，不用修改服务器代码 服务器和nginx在同一个局域网使用http1，没有更多的性能问题 nginx 可以使用兼用HTTP2和HTTP1.1 chrome 查看推送 chrome://net-internals#http2 最新版本没有参考：https://docs.google.com/document/d/1Ll7T5cguj5m2DqkUTad5DWRCqtbQ3L1q9FRvTN5-Y28/edit#查看是否有推送 HTTP2 Demo HTTP1 VS HTTP2 图片加载 其他对比Demo curl使用 curl -v test.com #查看网址是否支持HTTP2 curl -k test.com #忽略证书问题 curl -v --http1.1 test.com # 强制使用http1.1 开源库分析OkHttp 3.7源码分析基本流程 整体架构分析 Interceptor功能分析 RetryAndFollowUpInterceptor 在网络请求失败后进行重试 当服务器返回当前请求需要进行重定向时直接发起新的请求，并在条件允许情况下复用当前连接 BridgeInterceptor 设置其他报头 设置gzip压缩 CacheInterceptor 请求有符合要求直接返回Cache 服务器返回内容有改变时更新当前cache cache失效删除 ConnectInterceptor 即为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。 CallServerInterceptor 负责向服务器发起真正的访问请求，并在接收到服务器返回后读取响应返回 缓存策略HTTP缓存策略 Expires: 告知客户端对应资源的过期时间 Cache-Control:当前资源的有效期(s),比Expires优先级更高:Cache-Control:max-age=31536000,public 条件GET请求 Last-Modified-Date客户端第一次请求时，服务器返回：Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT,当客户端二次请求时，可以头部加上如下header:If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT如果当前资源没有被二次修改，服务器返回304告知客户端直接复用本地缓存。 ETag: ETag是对资源文件的一种摘要. 当客户端第一次请求某资源时，服务器返回：ETag: &quot;5694c7ef-24dc&quot;客户端再次请求时，可在头部加上如下域：If-None-Match: &quot;5694c7ef-24dc&quot;如果文件并未改变，则服务器返回304告知客户端可以复用本地缓存。 no-cache/no-store: 不使用缓存 only-if-cached:只使用缓存 多路复用]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown 语法补全]]></title>
    <url>%2F2019%2F04%2F13%2F2019-3-3-MarkDown-grammar-plugs%2F</url>
    <content type="text"><![CDATA[[TOC] [TOC] [TOC] 生成目录 样式（字体段落）页面内跳转 - [Usage](#usage) - [Examples](#examples) - [Download](#download) - [Tests](#tests) - [Code style](#code-style) - [Static code analysis](#static-code-analysis) - [JavaDoc](#javadoc) - [Changelog](#changelog) - [Releasing](#releasing) - [References](#references) - [License](#license) 字体样式&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt; &lt;font color=#00ffff size=3&gt;null&lt;/font&gt; &lt;font color=gray size=5&gt;gray&lt;/font&gt; 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 字体 字体 中文字体的英文名 网页字体样式方正舒体 FZShuTi 网页字体样式方正姚体 FZYaoti 网页字体样式华文彩云 STCaiyun 网页字体样式华文琥珀 STHupo 网页字体样式华文隶书 STLiti 网页字体样式华文行楷 STXingkai 网页字体样式华文新魏 STXinwei 网页字体样式华文黑体 STHeiti 网页字体样式华文楷体 STKaiti 网页字体样式华文宋体 STSong 网页字体样式华文仿宋 STFangsong 网页字体样式黑体 SimHei 网页字体样式宋体 SimSun 网页字体样式新宋体 NSimSun 网页字体样式仿宋 FangSong 网页字体样式楷体 KaiTi 网页字体样式仿宋_GB2312 FangSong_GB2312 网页字体样式楷体_GB2312 KaiTi_GB2312 网页字体样式微软正黑体 Microsoft JhengHei 网页字体样式微软雅黑体 Microsoft YaHei 网页字体样式隶书 LiSu 网页字体样式幼圆 YouYuan 网页字体样式华文细黑 STXihei 网页字体样式华文楷体 STKaiti 网页字体样式华文宋体 STSong 网页字体样式华文中宋 STZhongsong 网页字体样式华文仿宋 STFangsong 富媒体图片嵌入链接 [![Build Status](https://img.shields.io/travis/pwittchen/RxBiometric.svg?branch=master&amp;style=flat-square)](https://travis-ci.org/pwittchen/RxBiometric) 调节图片样式 嵌入HTML 方法说明颜色名称颜色 此处实现方法利用 CSDN-markdown 内嵌 html 语言的优势Hotpinkrgb(240, 248, 255) 借助 table, tr, td 等表格标签的 bgcolor 属性实现背景色设置AntiqueWhitergb(255, 192, 203) graph LR A--&gt;B sequenceDiagram A-&gt;&gt;B: How are you? B-&gt;&gt;A: Great! gantt dateFormat YYYY-MM-DD section S1 T1: 2014-01-01, 9d section S2 T2: 2014-01-11, 9d section S3 T3: 2014-01-02, 9d 脚注(注解)样式1 评价：相对于超链接方式，提供了对超链接的解说作用 I get 10 times more traffic from Google than from Yahoo or MSN. 样式2 这是一个链接到谷歌的[^脚注的详细说明]。 [^脚注的详细说明]: http://www.google.com 增加一些评论 评论： 1. 可以新建隐藏一些提示说明 2. 可以把链接地址增加说明，鼠标悬停是可以自己点击 段落缩进（空格）半方大的空白&amp;ensp;或&amp;#8194;看，飞碟 全方大的空白&amp;emsp;或&amp;#8195;看，飞碟 不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟 &amp;emsp;&amp;emsp;段落从此开始。 半方大的空白&ensp;或&#8194;看，飞碟全方大的空白&emsp;或&#8195;看，飞碟不断行的空白格&nbsp;或&#160;看，飞碟&emsp;&emsp;段落从此开始。 表格| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 或者 项目 | 价格 -------- | --- Computer | $1600 Phone | $12 Pipe | $1 项目 价格 Computer $1600 Phone $12 Pipe $1 分割线 三个-*_ --- *** ___ 引用 引用 引用中的引用 引用 引用中的引用 标题 大标题小标题大标题 === 小标题 --- 有序列表 有序列表 有序列表 有序列表 有序列表` 有序列表 有序列表 有序列表 有序列表 【不连续】`checkBox [x] 地方大 [ ] 地方大 一级标题二级标题三级标题四级标题五级标题六级标题]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后台基础学习笔记]]></title>
    <url>%2F2019%2F04%2F13%2F2019-2-26-server%2F</url>
    <content type="text"><![CDATA[重点研究开源库 zheng 比较热门的后台开源库 Guns 权限管理 公开课 https://www.bilibili.com/video/av32112009 vue-element-admin 非常惊艳的前端UI README.zh-CN.md 中文文档有教程 Cloud-Admin RabbitMQ配置 Consul1.2.2配置 Docker Get started with Docker Docker Compose docker-compose教程（安装，使用, 快速入门） AG-Admin-v2.0 安装问题解决 https://www.jianshu.com/p/fd3b19cacd99Error: Can't find Python executable "D:\workspace\env\common\Python\phyton_3.7.0\python.EXE", you can set the PYTHON env variable ## 解决，管理员身份 npm install --global --production windows-build-tools npm install --global node-gyp Module build failed: Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime (64) 原因：Node Sass 版本低 解决： npm uninstall node-sass -D npm install node-sass -D Mallhttps://github.com/macrozheng/mall Payhttps://gitee.com/52itstyle/spring-boot-pay 秒杀系统https://gitee.com/52itstyle/spring-boot-seckill https://gitee.com/xiandafu/springboot-plus 常用工具 scouter is an open source APM and an open source profiler for java application like web applications on a tomcat . tomcat挂掉解决方案 Tomcat集群 tomcat线程监控并自启 管理工具 RAP Web接口管理工具，开源免费，接口自动化，MOCK数据自动生成，自动化测试，企业级管理。阿里妈妈MUX团队出品！阿里巴巴都在用！1000+公司的选择！API 接口管理 Consul官网下载地址： https://www.consul.io/downloads.html CentOS7.5.1804 Minimal安装配置单机Consul1.2.2 consul安装配置，生产环境部署高可用环境 下载解压后window 使用 consul agent -dev 访问控制nginx windows下nginx的安装及使用 start nginx nginx -s stop(快速停止nginx) 或 nginx -s quit(完整有序的停止nginx) Nginx 常用命令 sudo nginx #打开 nginx nginx -s reload|reopen|stop|quit #重新加载配置|重启|停止|退出 nginx nginx -t #测试配置是否有语法错误 nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives] -?,-h : 打开帮助信息 -v : 显示版本信息并退出 -V : 显示版本和配置选项信息，然后退出 -t : 检测配置文件是否有语法错误，然后退出 -q : 在检测配置文件期间屏蔽非错误信息 -s signal : 给一个 nginx 主进程发送信号：stop（停止）, quit（退出）, reopen（重启）, reload（重新加载配置文件） -p prefix : 设置前缀路径（默认是：/usr/local/Cellar/nginx/1.2.6/） -c filename : 设置配置文件（默认是：/usr/local/etc/nginx/nginx.conf） -g directives : 设置配置文件外的全局指令 nginx -t 能查看配置文件所在目录 nginx: the configuration file /usr/local/tengine/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/tengine/conf/nginx.conf test is successful 阿里云后台配置文件路径：/usr/local/tengine/conf/nginx.conf 开源库 nginx-quick-reference 网上教程 转化工具properties2yml 数据库 数据库从入门到进阶必读18本技术书籍网盘吐血整理 RedisStudio redis图形界面管理工具 Redis Redis 命令参考 redisson Hibernate IntelliJ IDEA Hibernate hibernate生成数据库实体类 MongoDB配置文档： MongoDB manual MongoDB 入门教程 studio 3t破解, studio3t.bat @echo off ECHO 重置Studio 3T的使用日期...... FOR /f "tokens=1,2,* " %%i IN ('reg query "HKEY_CURRENT_USER\Software\JavaSoft\Prefs\3t\mongochef\enterprise" ^| find /V "installation" ^| find /V "HKEY"') DO ECHO yes | reg add "HKEY_CURRENT_USER\Software\JavaSoft\Prefs\3t\mongochef\enterprise" /v %%i /t REG_SZ /d "" ECHO 重置完成, 按任意键退出...... pause>nul exit 复制到：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp, 双击运行 Docker hub mongod 命令解析 权限​ Built-In Roles（内置角色）：​ \1. 数据库用户角色：read、readWrite;​ \2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；​ \3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；​ \4. 备份恢复角色：backup、restore；​ \5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase​ \6. 超级用户角色：root​ // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）​ \7. 内部角色：__system 具体角色：Read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profileuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。root：只在admin数据库中可用。超级账号，超级权限 授权操作 docker exec -it mongodb_mongo_1 mongo admin db.auth("mongo-admin","admin-initial-password") use octblog # Step2: create a user db.createUser( { user: "gevin", pwd: "gevin", roles: [ { role: "readWrite", db: "octblog" }, { role: "readWrite", db: "octblog-log" } ], mechanisms : ["SCRAM-SHA-1"] } ) 授权验证 docker exec -it {containerId} mongo localhost:27017/db_name -u user -p password 基本使用实体类使用流程 第一步：导入pom.xml依赖，配置数据库 org.springframework.data spring-data-commons 1.13.9.RELEASE mongoDB 数据库设置 spring: data: mongodb: uri: mongodb://root:123@localhost:27017 database: xc_cms spring: data: mongodb: database: xc_cms host: port: 27017 password: username: 第二步：定义实体类 import org.springframework.data.annotation.Id; import org.springframework.data.mongodb.core.mapping.Document; @Data @ToString @Document(collection = "cms_page") public class CmsPage { private String siteId; //页面ID @Id private String pageId; } 第三步：配置符合jpa规范的操作仓库 public interface CmsPageRepository extends MongoRepository&lt;CmsPage, String> { CmsPage findByPageName(String pageName); } 第四步：实现分页 导入pom.xml依赖 &lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --> &lt;dependency> &lt;groupId>org.springframework.data&lt;/groupId> &lt;artifactId>spring-data-commons&lt;/artifactId> &lt;version>1.13.9.RELEASE&lt;/version> &lt;/dependency> PageService.java //查询条件匹配 ExampleMatcher matcher = ExampleMatcher.matching(); Example example = Example.of(cmsPage, matcher); //分页设置 Pageable pageable = PageRequest.of(page &lt; 0 ? 0 : page, size &lt;= 0 ? 10 : size); Page&lt;CmsPage> all = cmsPageRepository.findAll(example, pageable); RabbitMQ springboot(八)：RabbitMQ详解 配置 #启动 rabbitmq-server -detached #查看的服务状态 rabbitmqctl status #关闭 rabbitmqctl stop # 配置网页插件， 1. 创建目录； 2. 启用插件 mkdir /etc/rabbitmq rabbitmq-plugins enable rabbitmq_management # 配置linux网页管理端口： 15672 AMQP端口：5672 # 然后访问http://localhost:15672即可， 阿里云：http://47.107.130.109:15672 #默认用户guest 密码guest 常用命令#添加用户: rabbitmqctl add_user #添加权限: rabbitmqctl set_permissions -p "/" ".*" ".*" ".*" #修改用户角色: rabbitmqctl set_user_tags administrator # 常用命令 add_user delete_user change_password list_users add_vhost delete_vhost list_vhostsset_permissions [-p ] clear_permissions [-p ] list_permissions [-p ] list_user_permissions list_queues [-p ] [ ...] list_exchanges [-p ] [ ...] list_bindings [-p ] list_connections [ ...] MyBatis工具 mybatis 逆向工程 mybatis-generator-gui 使用教程 推荐一款好用的mybatis逆向生成工具(真的很好用) MyBatis Generator 使用教程 MyBatis-Plus 官网 MyBatis-Plus + mysql 网络访问入门demo mybatis-plus-samples 参考 Spring Data Jpa系列教程 附件1、mybatis-spring-boot-starter 配置项手册 2、GitHub仓库地址，包含代码示例 3、中文官方文档 dubbo Dubbo入门—搭建一个最简单的Demo框架 incubator-dubbo Apache Dubbo (incubating) is a high-performance, java based, open source RPC framework. zipkin 微服务之分布式跟踪系统（springboot+zipkin） spring cloud 2.0 入门系列一 （10）分布式链路追踪-Zipkin Tomcat阿里云Tomcat地址 /root/document/backup/apache-tomcat-7.0.63 部署 Spring Boot 两种部署到服务器的方式 jps kill [ip] nohup java -jar test.jar >temp.txt &amp; FastDFS [用FastDFS一步步搭建文件管理系统] 官网： fastdfs docker-compose 和Dockerfile 生成fastdfs 学习案例 moocu/fastdfs source 成功使用的案例 Docker安装fastdfs Frp 内网穿透 十分钟教你配置frp实现内网穿透 frp 教程 github官网 下载：版本号（0.27.0）改为最新（本地缓存位置：E:\software\2.coder\debug） #linux 64 wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_linux_amd64.tar.gz #window 64 wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_windows_amd64.zip 常用命令#启动服务 ./frps -c ./frps.ini #启动后台服务 nohup ./frps -c ./frps.ini & #启动客户端 ./frpc -c ./frpc.ini #配置热更新 frpc reload -c ./frpc.ini #得到代理任务 frpc status -c ./frpc.ini 自定义子域名使其转发到内网服务中 阿里云配置所以*.linz.tech 转发到阿里云服务器 服务端配置 [common] bind_port = 7000 subdomain_host = linz.tech vhost_http_port = 6081 #log log_file = ./frps.log log_level = debug log_max_days =3 dashboard_port = 7500 # dashboard 用户名密码，默认都为 admin dashboard_user = admin dashboard_pwd = admin #connection pool setting max_pool_count = 3 #token 和客户端配置的 accesstoken保持一致，不一致无法保持连接 token=1234567890 客户端设置 [common] server_addr = 47.107.130.109 server_port = 7000 user = jobs token=1234567890 pool_count = 2 [portainer] type = http local_port = 9000 subdomain = portainer #below 2 param default is false use_encryption = true use_compression = true [eureka] type = http local_port = 50101 subdomain = eureka ssh 登录# frpc.ini [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 ssh 连接 ssh -oPort=6000 test@x.x.x.x 其中 test为服务器登录名称 zuul zuul入门（1）zuul 的概念和原理 zuul 动态网关路由 Zuul性能测试 配置管理对密码加密 springboot中对数据库密码加密 spring-boot-security 配置案例 建议还是把配置文件放在配置中心，类似的有携程的阿波罗https://github.com/ctripcorp/apollo/wiki/Quick-Start disconf https://github.com/knightliao/disconf 开源库nacos nacos 服务提供者集成nacos第一步：加入必要的依赖配置 pom.xml &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.0.5.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>Finchley.SR1&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-alibaba-dependencies&lt;/artifactId> &lt;version>0.2.2.RELEASE&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>1.18.2&lt;/version> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;/dependencies> 第二步： 应用入口App启用 @EnableDiscoveryClient @EnableDiscoveryClient @SpringBootApplication public class TestApplication { } 第三步： 接入nacos服务,如application.properties server.port=8001 spring.application.name=alibaba-nacos-discovery-server spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 #命名空间设置 spring.cloud.nacos.discovery.namespace=f1e5a968-5ddb-479b-8e35-1f8c9ccea438 服务消费者第一，二，三步：同上 第四: 请求 RestTemplate @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } String result = restTemplate.getForObject("http://alibaba-nacos-discovery-server/hello?name=didi", String.class); WebClient 第一步：加入必要依赖配置 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-webflux&lt;/artifactId> &lt;/dependency> 第二步：使用 @Bean @LoadBalanced public WebClient.Builder loadBalancedWebClientBuilder() { return WebClient.builder(); } @GetMapping("/test") public Mono&lt;String> test() { Mono&lt;String> result = webClientBuilder.build() .get() .uri("http://alibaba-nacos-discovery-server/hello?name=didi") .retrieve() .bodyToMono(String.class); return result; } Feign使用 第一步： 增加openfeign依赖 &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-openfeign&lt;/artifactId> &lt;/dependency> 第二步：App 入口启用@EnableFeignClients @EnableFeignClients @SpringBootApplication public class TestApplication { } 第三步：使用 @FeignClient(value = "XC-SERVICE-MANAGE-CMS") //指定要远程调用的服务名 public interface CmsPageClient { /** * 根据页面id查询页面信息，远程调用cms请求数据 * @param id page id * @return */ @GetMapping("/cms/page/get/{id}") CmsPage findCmsPageById(@PathVariable("id") String id); /** * 保存页面 * @param cmsPage * @return */ @PostMapping("/cms/page/save") CmsPageResult saveCmsPage(@RequestBody CmsPage cmsPage); /** * 一键发布接口 * @param cmsPage * @return */ @PostMapping("/cms/page/postPageQuick") CmsPostPageResult postPageQuick(@RequestBody CmsPage cmsPage); } 配置中心集成第一步：加入必要的依赖， &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.0.5.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>Finchley.SR1&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-alibaba-dependencies&lt;/artifactId> &lt;version>0.2.2.RELEASE&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-config&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>1.18.2&lt;/version> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;/dependencies> 如果已经集成了服务提供或者消费，只需增加如下配置： &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-config&lt;/artifactId> &lt;/dependency> 第二步：代码中使用 @SpringBootApplication public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Slf4j @RestController @RefreshScope static class TestController { @Value("${didispace.title:}") private String title; @GetMapping("/test") public String hello() { return title; } } } 配注： @Value(&quot;${didispace.title:}&quot;) 读取配置信息 @RefreshScope 这个类配置内容支持动态更新 第三步：创建配置文件bootstrap.properties spring.application.name=alibaba-nacos-config-client server.port=8001 spring.cloud.nacos.config.server-addr=127.0.0.1:8848 第四步：自定义配置 # blog: http://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/ #自定义配置文件选择 A #spring.cloud.nacos.config.prefix=example #spring.cloud.nacos.config.file-extension=properties #spring.cloud.nacos.config.group=DEV_GROUP # 开发模式选择 # blog: http://blog.didispace.com/spring-cloud-alibaba-nacos-config-2/ #spring.profiles.active=DEV #spring.cloud.nacos.config.group=DEV_GROUP # blog: http://blog.didispace.com/spring-cloud-alibaba-nacos-config-3/ #多文件配置 #1. B 数组形式 #spring.cloud.nacos.config.ext-config[0].data-id=actuator.properties #spring.cloud.nacos.config.ext-config[0].group=DEFAULT_GROUP #spring.cloud.nacos.config.ext-config[0].refresh=true #spring.cloud.nacos.config.ext-config[1].data-id=log.properties #spring.cloud.nacos.config.ext-config[1].group=DEFAULT_GROUP #spring.cloud.nacos.config.ext-config[1].refresh=true #2. C 分割符形式 #spring.cloud.nacos.config.shared-dataids=actuator.properties,log.properties #spring.cloud.nacos.config.refreshable-dataids=actuator.properties,log.properties #配置优先级： A > B > C 开源库1. 后台 主要是在码云上找的， 官网：https://gitee.com/explore 几个分数很高的后台 https://www.oschina.net/p/guns 【参考】 https://gitee.com/shuzheng/zheng 【推荐】star个数最多 https://gitee.com/jfinal/jfinal 【了解】 2. 权限管理 https://www.oschina.net/p/iBase4J 权限管理 3. UI 有很多的网页端的开源框架，具体的可以咨询藤来 http://www.layui.com/admin/ 【推荐看】这个能直接看到案例，感觉直接套用就可以了 http://element-cn.eleme.io/ 主要参考的资料： 2016 年度开源中国新增开源软件排行榜 TOP 100 网址：https://www.oschina.net/news/80846/2016-osc-new-open-source-software-top-100 2017 年度开源中国新增开源软件排行榜 TOP 100 网址：https://www.jianshu.com/p/ea9f08267c83 Tengine CSDN 正在使用 Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。它的目的是打造一个高效、安全的Web平台。 学习资料基础教程 Spring Boot基础教程 Spring-Boot-Reference-Guide spring-boot集成graphql入门教程 前人总结 springcloud学习资料汇总 【重点】 JCSprout 处于萌芽阶段的 Java 核心知识库 JavaGuide 学习视频汇总 Java架构师分享自己的从业心得，从码农到架构师我用了八年，高级视频课程学习 开源库汇总 springboot快速开发框架推荐，接私活利器 博客资料 http://blog.didispace.com/ 纯洁的微笑 阿里云学习 远程连接密码 934698 实例密码：林茂权16899199 （Lin） 阿里云后台 47.107.130.109 容器镜像服务登录密码：Lmq16899199 阿里云手机终端通过SSH连接后台# 网页端后台操作步骤 # 1. 找到管理页面 云服务器ECS-->网络和安全--> 秘钥对-> 秘钥对管理 # 2. 新建绑定下载 创建秘钥->绑定指定后台-> 重启服务器 # Android SSH工具使用 iP：47.107.130.109 登录名：root 密钥： 选择上面下载xxx.pem 密钥口令：不用填 端口：22（和后台ssh相同） 别名: 随意 安全组配置 Redis 有专门的选择专门的Redis协议 6379 自定义TCP协议无效 常用配置界面 linz.tech 域名配置界面 后台端口开发设置界面 新建报警机制 亚马逊云学习Linux用r3.pem登录 /mnt/hgfs/ubuntu/workspace/tools/亚马逊服务器连接 chmod 400 aws亚马逊_服务秘钥r3.pem ssh -i aws亚马逊_服务秘钥r3.pem ubuntu@ec2-18-191-169-66.us-east-2.compute.amazonaws.com shadowsocket 详细教程：shadowsocket：比vpn更牛的科学上网方式，自己搭建shadowsocket的超详细教程 https://github.com/shadowsocks 开源库官网 总结命令 install # root sudo -s # install apt-get update apt-get install python-pip pip install shadowsocks setting vi /etc/shadowsocks.json 单用户 { "server":"0.0.0.0", "server_port":8989, "local_address":"127.0.0.1", "local_port":1080, "password":"yourpassword", "timeout":300, "method":"aes-256-cfb", "fast_open": false } 多用户 { "server":"0.0.0.0", "local_address":"127.0.0.1", "local_port":1080, "port_password":{ "8989":"password0", "9001":"password1", "9002":"password2", "9003":"password3", "9004":"password4" }, "timeout":300, "method":"aes-256-cfb", "fast_open": false } 运行 ssserver -c /etc/shadowsocks.json -d start 出现如下打印成功启动 INFO: loading config from /etc/shadowsocks.json 2019-02-18 14:32:45 INFO loading libcrypto from libcrypto.so.1.0.0 started 设置开机启动 vi /etc/rc.local #!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will "exit 0" on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # By default this script does nothing. #增加 ssserver -c /etc/shadowsocks.json -d start exit 0 Node jsnodejs 在linux上后台运行 1.用forever 进行管理搜索 npm install -g forever forever start index.js 常用配置Centos virtual-box 安装 Download VirtualBox for Linux Hosts 配置版本仓库，在/etc/yum.repos.d/目录下新建virtualbox.repo并写入如下内容[virtualbox] name=Oracle Linux / RHEL / CentOS-$releasever / $basearch - VirtualBox baseurl=http://download.virtualbox.org/virtualbox/rpm/el/$releasever/$basearch enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://www.virtualbox.org/download/oracle_vbox.asc 安装# 6.更新yum缓存 yum clean all yum makecache # 7.安装virtualbox yum install VirtualBox-6.0 Mail126邮箱设置 邮件服务器名称 服务器地址 端口号 POP3服务器 pop.126.com 110 SMTP服务器 smtp.126.com 25 IMAP服务器 imap.126.com 143 Navicat 自动发送短信设置 SMTP服务器： smtp.126.com:25 用户名： zhilinchn@126.com 密码(区分大小写)： !!16...99qQ 安全连接: TLS Maven 私服务搭建 Nexus创建Maven私有仓库 RedisRedis 外部访问设置 1&gt;注释掉bind #bind 127.0.0.1 3&gt;禁用保护模式 protected-mode no Jenkins Jenkins设置网易系邮件通知 问题解决SpringBoot Tomcat 8080 端口配占用 Windows# 找到pid 代LISTENING的 netstat -ano | findstr "8080" # 找到进程 tasklist | findstr "pid" # 杀掉进程 taskkill /f /t /im java.exe Docker [Windows10下Docker出现net/http:TLS handshake timeout](https://blog.csdn.net/pop0fa/article/details/80029739） http://69292621.m.daocloud.io settings-&gt; daemon-&gt; registry mirrors: add http://69292621.m.daocloud.io VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation。有关更多详细信息，请访问 关闭Hyper-v WARNING: The vboxdrv kernel module is not loaded. Either there is no module available for the current kernel (3.10.0-862.14.4.el7.x86_64) or it failed to load. Please recompile the kernel module and install it by sudo /sbin/vboxconfig You will not be able to start VMs until this problem is fixed. /sbin/vboxconfig vboxdrv.sh: Stopping VirtualBox services. vboxdrv.sh: Starting VirtualBox services. vboxdrv.sh: Building VirtualBox kernel modules. This system is currently not set up to build kernel modules. Please install the Linux kernel "header" files matching the current kernel for adding new hardware support to the system. The distribution packages containing the headers are probably: kernel-devel kernel-devel-3.10.0-862.14.4.el7.x86_64 This system is currently not set up to build kernel modules. Please install the Linux kernel "header" files matching the current kernel for adding new hardware support to the system. The distribution packages containing the headers are probably: kernel-devel kernel-devel-3.10.0-862.14.4.el7.x86_64 There were problems setting up VirtualBox. To re-start the set-up process, run /sbin/vboxconfig as root. 七牛云测试域名过渡 操作界面： 域名管理-&gt; 创建域名 操作： 如域名为 linz.tech, 填写加速域名为 cdn.linz.tech 其他默认点击创建即可。说明：cdn是可以随意取名的二级域名操作结果： 域名管理 界面新增一个域名列表，点击配置 获取如: CNAME：cdn.linz.tech.qiniudns.com的域名映射； 配置CNAME：到域名解析管理里面增加二级域名操作步骤： 添加记录 记录类型，选择CNAME； 主机记录： 填入cdn,上面自定义的二级域名 记录值把上一步操作的值（cdn.linz.tech.qiniudns.com）填入，其他默认，确定即可； 测试： 到内容管理界面随便复制一个文件测试访问，访问域名为http://cdn.linz.tech并访问成功，设置成功 参考 如何从测试域名过渡到自定义域名 域名接入文档 附录常用命令状态监测 #查看端口号是否被占用 netstat -tunlp |grep 8000]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 基础比较]]></title>
    <url>%2F2019%2F04%2F13%2F2019-4-13-git-basic-note%2F</url>
    <content type="text"><![CDATA[[TOC] Open source git-flow git-extras 基础Git配置 list all git config git config -l /etc/gitconfig &lt; ~/.gitconfig &lt; .git/config 逐级覆盖 $ git config –global core.editor vim $ git config –global merge.tool vimdiff 用户名git config –global user.name “edward.lin”git config –global user.email “edward.lin@anarry.com“ 显示为彩色（默认）git config –global color.ui true 生成秘钥ssh-keygen -t rsa -C “1129103472@qq.com”按3个回车，密码为空。(不要输密码)然后到.ssh下面将id_rsa.pub里的内容复制出来粘贴到github个人中心的账户设置的ssh key里面测试：ssh -T git@github.com linxu : .ssh/id_rsa.pub ==&gt; githubwindow: C:\Users\Administrator.ssh\id_rsa.pub ==&gt; github 忽略配置.gitignore #把.o 文件与.a文件过滤掉不添加 *.[oa] #ignore优先级问题,!test.o会继续提交这个文件 *.o !test.o #匹配0个或者多个目录,当前目录与子目录 **/res #匹配文件夹 foo/ 常用配置 命令别名 git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch 带参数 git config --global alias.last 'log -1 HEAD' git log -1 HEAD ==> git last 对比文件的不同 git diff - -cached #查看已缓存与已提交的改动 git diff HEAD #查看已提交的与未缓存的所有改动 git diff - - stat 显示摘要而非整个 diff 移除文件 git reset HEAD – file //git reset HEAD 以取消之前 git add 添加 git rm file //会将文件从缓存区和你的硬盘中（工作目录）删除 git rm –cached //在工作目录中留着该文件，and delete the status of under version control $ git rm log/\*.log #反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式 $ git rm \\*~ （译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配) 移动文件Git 中对文件改名 $ git mv file_from file_to 日志查看日志的内容差异，并指定次数： $ git log -p -2 commit ca82a6dff817ec66f44342007202690a93763949--stat 只显示统计的修改行数 如： | 31 ++++++++++++++—————–$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 另外还有 oneline, short，full 和fuller 可以用 结合 –graph$ git log --pretty=format:&quot;%h %s&quot; --graph Filter$ git log --since=2.weeksgit log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \ --before=&quot;2008-11-01&quot; --no-merges 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之 Log 命令的使用git log q //exit from the log status like man git log --oneline git log --graph git log --oneline new_branch git log --oneline erlang ^master //look the sumbit no include master git loggit log # 查看该文件每次提交记录 git log -p # 显示版本历史，以及版本间的内容差异 git log -p -2 # 查看最近两次详细修改内容的diff git log --stat # 查看提交统计信息 git log --since="6 hours" # 显示最近6小时提交 git log --before="2 days" # 显示2天前提交 git log -1 HEAD~3 # 显示比HEAD早3个提交的那个提交 git log -1 HEAD^^^git reflog # 查看操作 git log branchA ^branchB git log –author 只寻找某个特定作者的提交 $ git log --author=Linus --oneline -5 git log –since –before 根据日期过滤提交记录 git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges # --no-merges 隐藏合并提交 git log –grep 根据提交注释过滤提交记录 $ git log --grep=search_key_work --no-merges git log -S 依据所引入的差值过滤 如果你要找某个函数是何时引入的，某些变量是在哪里开始被使用的？ 你可以告诉 Git 在每个提交之间的差值中查找特定字符串 git log -p 基于快照，产生各个快照的差值（补丁）VS git log –stat 显示每个提交引入的改动的差值"统计" 撤消操作修改最后一次提交$ git commit --amend #用当前的暂存区域快照提交 没有作任何改动 ==&gt; 重写commit日志 有改动，提交改动 And 重写日志 取消已经暂存的文件use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage 取消对文件的修改 A) trace 1.git reset xxxxxx path/to/file 2. use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory B) untrace --&gt;&gt; git rm paht/to/file 远程仓库基础 git remote # list alias of remote git remote add [alias] [url] #add a new remote repository git remote rm # delete a remote alias git remote rm origin git remote rename [old-alias] [new-alias] set-urlgit remote set-url origin git://github.com/github/git-reference.gitgit remote set-url –push origin git://github.com/pjhyett/hw.git git push -uhttp://stackoverflow.com/questions/18031946/what-does-set-upstream-do 推送数据到远程仓库 git push [alias] [branch] git push &lt;=&gt; git push origin master git push origin new_branch # push local new_branch to reomte repository 查看远程仓库信息git remote show [remote-name] 标签列显已有的标签 git tag 我们可以用特定的搜索模式列出符合条件的标签 $ git tag -l &#39;v1.4.2.*&#39; result: v1.4.2.1 v1.4.2.2 v1.4.2.3 v1.4.2.4 新建标签Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。 轻量级标签: 就像是个不会变化的分支，实际上它就是个指向特 定提交对象的引用 含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标 签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证 含附注的标签$ git tag -a v1.4 -m &#39;delete so libs&#39; -a annotated 指定标签名字 -m msg 可以使用 git show &lt;tag name&gt; 显示tag信息 常用命令 $ git tag -a v0.1.1 8e918de2ca5bc06d436df990d658369c462f5c69 #补打标签 remote $ git push origin v0.1.2 # 将v0.1.2标签提交到git服务器 $ git push origin –tags # 将本地所有标签一次性提交到git服务器 Git Branch常用命令 git checkout -b (branch name) 创建新分支，并立即切换到它 git branch -d (branch name) #需合并才能删除分支 git branch -D (branch name) 删除分支 git branch 基于当前分支的某一次commit来创建分支 git checkout -B force to overwrite same name branch git checkout --orphan ## new a log_clear branch and switch to it git checkout --track -b track_master origin/master $ git cherry-pick xxx #可以同步一个commit到本分支 何谓分支 Git会先计算每一个子目录（本例中就是项目根目录）的校验和 在Git仓库将这些目录保存为树（tree）对象 分享与更新项目git archive -o ../updated.zip HEAD $(git diff --name-only HEAD^) #xxx代表SHA-1 Hash值。Git打包源码 #Fetch And Pull git fetch origin # 取得远程更新（到origin/master "origin/master" 和普通的branch一样，除了git不允许切换到它）， 但还没有合并 git merge origin/master master # 把更新的内容（origin/master）合并到本地分支（master） git merge origin/master master --squash // no branch log history git log origin/master ^master # after fetch before merge look the origin/master diff log from local master git pull origin master # 相当于fetch和merge的合并，但分步操作更保险 检查与比较git diff v0.9 #diff current status and tag status可以执行类似 git diff branchA branchB 的命令。 不过它的问题在于它会完完全全按你说的作 —— 它会直接给你个补丁文件，该补丁能够将甲分支的最新快照变成乙分支的最新快照的样子。 这意味着如果两个分支已经产生分歧 —— 奔往两个不同方向了 —— 它会移除甲分支中引入的所有工作，然后累加乙分支中的所有工作。 这大概不是你要的吧 —— 你想要不在甲分支中的乙分支的改动。所以你真的需要的是两个分支叉开去时，和最新的乙分支的差别。 所以，如果我们的历史记录看起来像这样：$ git log –graph –oneline –decorate –allgit diff branchA…branchB 来查看 branchB 与 branchA 的相对差值。 Git之本地忽略未跟踪文件 git config --global core.excludesfile 文件的绝对路径或 .git/info/exclude 已跟踪了的文件 $ git update-index --assume-unchanged /path/to/file #忽略跟踪 $ git update-index --no-assume-unchanged /path/to/file #恢复跟踪 还原git reset HEAD a_file #undo last time git add a_file git reset - - hard HEAD #reset repo to HEAD git reset - - hard 3d409b9a302ce55d12dffdf3d99f0bed7dc2d7ff #reset to this commit time git checkout 3d409b9a302ce55d12dffdf3d99f0bed7dc2d7ff # checkout a temp branch to look around 技巧和窍门自动完成如果你用的是 Bash shell，可以试试看 Git 提供的自动完成脚本。下载 Git 的源代码，进入 contrib/completion 目录，会看到一个git-completion.bash 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：cp git-completion.bash ~/.git-completion.bash，并把下面一行内容添加到你的.bashrc 文件中： source ~/.git-completion.bash 也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 /opt/local/etc/bash_completion.d目录中，Linux 上则复制到/etc/bash_completion.d/ 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。 如果在 Windows 上安装了 msysGit，默认使用的 Git Bash 就已经配好了这个自动完成脚本，可以直接使用。 Git 命令别名 Git分支管理策略 Master Develop Tmeporary * 功能（feature）分支 * 预发布（release）分支 * 修补bug（fixbug）分支 Create a Feature branch: git checkout -b feature-x develop 预发布分支Create a release branch: git checkout -b release-1.2 develop 预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 确认没有问题后，合并到master分支： git checkout master git merge --no-ff release-1.2 # 对合并生成的新节点，做一个标签 git tag -a 1.2 再合并到develop分支并删除： git checkout develop git merge --no-ff release-1.2 git branch -d release-1.2 修补bug分支 #Create a fixbug branch: git checkout -b fixbug-0.1 master #fixbug over git checkout master git merge --no-ff fixbug-0.1 git tag -a 0.1.1 #merge to develop git checkout develop git merge --no-ff fixbug-0.1 #delete branch git branch -d fixbug-0.1 git 文件打包命令 Git 提交规范 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 type（必需）、scope（可选）和subject（必需） `&lt;type>(&lt;scope>): &lt;subject>` 附录博客教程 Git知识总览(一) 从 git clone 和 git status 谈起]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android P 电量管理]]></title>
    <url>%2F2018%2F10%2F31%2F2018-10-31-android-p-api-28%2F</url>
    <content type="text"></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>android-p</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javapoet API 简介使用思路-Java代码生成]]></title>
    <url>%2F2018%2F09%2F23%2F2018-9-23-javapoet-note%2F</url>
    <content type="text"><![CDATA[基础总结JavaPoet简介JavaPoet 是一个生成.Java源文件的Java API。源文件生成在annotation processing 或者和一些元数据，例如文件，数据库设计，协议格式等，进行交互时会很有用。通过代码生成，你能够减少冗余的代码模板，同时保证唯一正确的源文件为元数据。 目录 基础总结 JavaPoet简介 使用总结 最小案例 类说明 公共 方法相关 其他 JavaPoet 官网 基础总结JavaPoet简介JavaPoet 是一个生成.Java源文件的Java API。源文件生成在annotation processing 或者和一些元数据，例如文件，数据库设计，协议格式等，进行交互时会很有用。通过代码生成，你能够减少冗余的代码模板，同时保证唯一正确的源文件为元数据。 原文JavaPoet is a Java API for generating .java source files. Source file generation can be useful when doing things such as annotation processing or interacting with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate the need to write boilerplate while also keeping a single source of truth for the metadata. 使用总结 基本使用逻辑，按照正常的新建.java，按照逻辑编写对应的代码，编写的代码替换为Javapoet的语法就可以了，Javapoet 的语法过一遍不用记忆,甚至看一下最小案例，直接开车都木有问题，使用的时候不记得访问GitHub主页对应搜索 引用配置 compile &#39;com.squareup:javapoet:1.11.1&#39; &lt;dependency&gt; &lt;groupId&gt;com.squareup&lt;/groupId&gt; &lt;artifactId&gt;javapoet&lt;/artifactId&gt; &lt;version&gt;1.11.1&lt;/version&gt; &lt;/dependency&gt; 最小案例HelloWorld.java package com.example.helloworld; public final class HelloWorld { public static void main(String[] args) { System.out.println("Hello, JavaPoet!"); } } JavaPoet.java MethodSpec main = MethodSpec.methodBuilder("main") .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .returns(void.class) .addParameter(String[].class, "args") .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!") .build(); TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld") .addModifiers(Modifier.PUBLIC, Modifier.FINAL) .addMethod(main) .build(); JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld) .build(); javaFile.writeTo(System.out); 类说明 类生成：TypeSpec.classBuilder(“HelloWorld”) 接口：TypeSpec.interfaceBuilder(“HelloWorld”) 方法生成：MethodSpec.methodBuilder(“main”) 增加访问权限： addModifiers(Modifier.PUBLIC, Modifier.STATIC) 属性：FieldSpec /TypeSpec.addField 参数：ParameterSpec/MethodSpec.addParameter(ParameterSpec) 文档：MethodSpec.addJavadoc 公共 String.format() 字符串格式化 $L for Literals .addStatement(&quot;result = result $L i&quot;, op) $S for Strings .addStatement(&quot;return $S&quot;, name) $T for Types .addStatement(&quot;return new $T()&quot;, Date.class) 会自动import java.util.Date;包名 手动指定包名：ClassName hoverboard = ClassName.get(&quot;com.mattel&quot;, &quot;Hoverboard&quot;); Code block 代码块 CodeBlock.builder().add(&quot;I ate $2L $1L&quot;, &quot;tacos&quot;, 3) mapMap&lt;String, Object> map = new LinkedHashMap&lt;>(); map.put("food", "tacos"); map.put("count", 3); CodeBlock.builder().addNamed("I ate $count:L $food:L", map) Import static 静态导入JavaFile.builder("com.example.helloworld", hello) .addStaticImport(hoverboard, "createNimbus") .build(); 方法相关 增加代码块 addCode MethodSpec main = MethodSpec.methodBuilder("main") .addCode("" + "int total = 0;\n" + "for (int i = 0; i &lt; 10; i++) {\n" + " total += i;\n" + "}\n") .build(); void main() { int total = 0; for (int i = 0; i &lt; 10; i++) { total += i; } } beginControlFlow( { )ddStatementendControlFlow 不用写{\n;}等MethodSpec main = MethodSpec.methodBuilder("main") .addStatement("int total = 0") .beginControlFlow("for (int i = 0; i &lt; 10; i++)") .addStatement("total += i") .endControlFlow() .build(); 函数内部调用 public String byteToHex(int b) { char[] result = new char[2]; result[1] = hexDigit(b &amp; 0xf); return new String(result); } public char hexDigit(int i) { return (char) (i &lt; 10 ? i + '0' : i - 10 + 'a'); } //------------------------------------- MethodSpec hexDigit = MethodSpec.methodBuilder("hexDigit") .addParameter(int.class, "i") .returns(char.class) .addStatement("return (char) (i &lt; 10 ? i + '0' : i - 10 + 'a')") .build(); MethodSpec byteToHex = MethodSpec.methodBuilder("byteToHex") .addParameter(int.class, "b") .returns(String.class) .addStatement("char[] result = new char[2]") .addStatement("result[1] = $N(b &amp; 0xf)", hexDigit) .addStatement("return new String(result)") .build(); 匿名内部类：Anonymous Inner Classes 抽象方法：Modifier.ABSTRACTpublic abstract class HelloWorld { protected abstract void flux(); } //------------------------- MethodSpec flux = MethodSpec.methodBuilder("flux") .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED) .build(); TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld") .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT) .addMethod(flux) .build(); 构造方法public HelloWorld(String greeting) { this.greeting = greeting; } //------------------------------ MethodSpec flux = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(String.class, "greeting") .addStatement("this.$N = $N", "greeting", "greeting") .build(); MethodSpec.addAnnotation(Override.class) 其他 参数: Parametersvoid welcomeOverlords(final String android, final String robot) { } //------------------------------- ParameterSpec android = ParameterSpec.builder(String.class, "android") .addModifiers(Modifier.FINAL) .build(); MethodSpec welcomeOverlords = MethodSpec.methodBuilder("welcomeOverlords") .addParameter(android) .addParameter(String.class, "robot", Modifier.FINAL) .build(); 属性：FieldSpecFieldSpec android = FieldSpec.builder(String.class, "android") .addModifiers(Modifier.PRIVATE, Modifier.FINAL) .initializer("$S + $L", "Lollipop v.", 5.0d) .build(); Javadoc JavaPoet 官网]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>javapoet</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员怎么高效做笔记]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-20-method-for-note%2F</url>
    <content type="text"><![CDATA[目录 前言 25分搞定 Markdown 怎么快速入门Markdown Markdown的进阶玩法 Markdown 管理API或者项目说明文档 巧用EverNote，做网页笔记 用Gist 记录经典和常用的代码块 用编程常用Studio做笔记工具 模仿Android studio的todo的样式 参考 前言告诉你一个秘密我刚知道程序员怎么高效做笔记 25分搞定 Markdown 作为程序员不知道Markdown那你真的是Out了，用Markdow语法写博客笔记几个##就能把你的文章，用清晰的分级标题理清楚，不再是没有重点一团乱麻，轻松的解决代码块插入无格式的老大难问题，加上各种插件，轻松打造美观的文章。Markdown支持转换为常见的文件格式如：HTML,doc,PDF等； 怎么快速入门Markdown其实Markdown常用的语法就几个，最快速的方法是用支持Markdown语法的编辑器试一次UI中提供各种语法，15分基本能搞定，1分钟回顾一下，任何用到的时候忘记了在看一下案例。推荐资源有： pandao 提供的在线案例如上图 使用有道笔记本，新建Markdown笔记； Markdown的进阶玩法 目前大部分的博客网站都支持Markdown语法，如CSDN，掘金，简书等可以注册，尝试一下进入Markdown的世界； Gitbook 把你的Markdown弄成书 Gitbook安装与使用教程 国外最流行的相关网站www.gitbook.com，能找到用gitbook写的各种书籍； MarkDown在线简历工具，可在线预览、编辑和生成PDF Markdown 转换成Work，HTML，PDF格式 使用Hexo搭建自己的博客 如果一切顺利半天就能搭好博客，遇到一些问题已天就能搞定； 注意： 虽然很多网站都支持Markdown，但是很多网站对Markdown做了深度定制，这会导致不同编辑器之间出现显示偏差，如包有道的Markdown文件拷贝到Hexo博客上经常出现格式混乱的问题；注意，不同编辑器检查一下文章格式 图片尽量放在自己的云服务器上，以便以后迁移不会丢失，这里推荐七牛云为个人提供10G的免费储存； Markdown 管理API或者项目说明文档下面的工具都是使用Markdown语法，看自己喜欢什么样式直接安装 MkDocs Docusaurus Docsify docpress 巧用EverNote，做网页笔记相信现在很多人经常上网浏览网页，但是遇到一些一下子无法消化的内容，需要重复浏览和做笔记怎么办? Chrome 的Evernote插件很好的解决了这个痛点，如下： 做好的网页笔记，不仅能在电脑端的客户端打开，而且还能进一步编辑，上传音视频文件： 用Gist 记录经典和常用的代码块 场景1：看源码的时候，我靠这段代码太经典/常用了我怎么保存他呢？ 场景2：这个功能的代码我看过，在哪个项目来着？ 场景3：关于文件操作的代码我看了好多，怎么集合在一起？ 上面的场景都是代码片段的保存需求，github上早就提供了代码片段管理Gist功能，只是国内需要翻墙使用比较麻烦，而没有普及开来； 其他软件没用过，推荐我一直用很好用的Lepton软件：推荐原因： 跨平台Window，Mac，Linux都支持； UI设计简洁，操作简单； 基本能解决翻墙问题，注意：但是有时候还是会登录不上 用编程常用Studio做笔记工具程序员每天都跟Studio打交道，对自己语言的Studio自然比其他软件更熟悉，各种快捷键手到擒来，当然用Studio最笔记自然无形中提高了效率，我自己就用Android studio 中的markdown插件写hexo博客 模仿Android studio的todo的样式想要达到的效果 设置步骤 参考 知乎：学习编程用什么做笔记比较好？ 基本都试过，只有notion惊艳到我了]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQlite数据库查缺补漏]]></title>
    <url>%2F2018%2F09%2F17%2F2018-9-17-note-sqlite%2F</url>
    <content type="text"><![CDATA[目录 SQLite基础 表操作 增 使用一个表来填充另一个表 查 高级教程 索引 索引避免使用 应用Indexed-By 常用命令： PRAGMA SQLite约束 Join 内连接 - INNER JOIN 外连接 - OUTER JOIN 交叉连接 - CROSS JOIN(了解) Unions 子句 触发器（Trigger） 创建 找 删除 综合 Alter修改 视图（View） 语法 Transaction SQLite 子查询 查询 插入 更新 删除 Explain 语法 日期 &amp; 时间 SQLite 基础SQLite 基础 教程网址 表操作Create CREATE TABLE COMPANY( ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); 增INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1, &#39;Paul&#39;, 32, &#39;California&#39;, 20000.00 ); 使用一个表来填充另一个表语法： INSERT INTO first_table_name [(column1, column2, ... columnN)] SELECT column1, column2, ...columnN FROM second_table_name [WHERE condition]; 查SQLite Where 子句 SELECT * FROM COMPANY WHERE AGE > (SELECT AGE FROM COMPANY WHERE SALARY > 65000); Like 百分号 （%）匹配多个 下划线 （_） 匹配一个 Glob 和like同样用法，不同大小写敏感 星号 （*）多个 问号 （?）单个 OFFSET SELECT * FROM COMPANY LIMIT 3 OFFSET 2; # 第三位开始提取 3 个记录： Having过滤分组条件位置在 group by having order by distinct select distinct name from company; 高级教程索引索引避免使用 表小 频繁写入 列有大量NULL 不应使用在频繁操作的列上 CREATE INDEX index_name ON table_name; CREATE INDEX index_name ON table_name (column_name);# 单列 CREATE UNIQUE INDEX index_name on table_name (column_name);# 唯一 CREATE INDEX index_name on table_name (column1, column2); #组合 应用Indexed BySELECT|DELETE|UPDATE column1, column2... INDEXED BY (index_name) table_name WHERE (CONDITION); 常用命令：查出数据库所有索引 SELECT * FROM sqlite_master WHERE type = &#39;index&#39;; PRAGMAPRAGMA 网址 作用读写Sqlite内部环境变量和状态，操作如下： PRAGMA pragma_name; #读取 PRAGMA pragma_name = value; #设置 常用可设置的选项 auto_vacuum 数据从数据库移除而缩小 encoding 控制字符串/存储数据编码 index_info ( table_name ); 索引信息…. SQLite 约束 NOT NULL 约束 DEFAULT 约束 UNIQUE 约束 PRIMARY Key CHECK 约束CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL UNIQUE, ADDRESS CHAR(50), SALARY REAL DEFAULT 50000.00 bonus INT CHECK(bonus &gt; 0) ); Join http://www.runoob.com/sqlite/sqlite-joins.html 内连接 - INNER JOIN SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; -- 自动检测两个表中的每一列的值之间相等值 SELECT EMP_ID, NAME, DEPT FROM COMPANY NATURAL JOIN DEPARTMENT 结果： EMP_ID NAME DEPT /---------- ---------- ---------- 1 Paul IT Billing 2 Allen Engineerin 7 James Finance 外连接 - OUTER JOIN SQLite 只支持 左外连接（LEFT OUTER JOIN） SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; 结果： EMP_ID NAME DEPT ---------- ---------- ---------- 1 Paul IT Billing 2 Allen Engineerin Teddy Mark David Kim 7 James Finance 交叉连接 - CROSS JOIN(了解)相当于把第一个表选中的列插入第二个中 SELECT EMP_ID, NAME, DEPT FROM COMPANY CROSS JOIN DEPARTMENT; Unions 子句Unions 子句 网址 合并两个或多个 SELECT 语句的结果，不返回任何重复的行 须select 列数相同（数目，类型相同） 案例： SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID UNION SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; UNION ALL 显示重复 触发器（Trigger）触发器（Trigger） 监听table上的INSERT、DELETE 和 UPDATE做出对应的操作，类似于观察者模式 当触发器相关联的表删除时，自动删除触发器（Trigger） 要修改的表必须存在于同一数据库中 when 可以连接sql子句 创建语法： CREATE TRIGGER trigger_name [BEFORE|AFTER] UPDATE OF column_name ON table_name BEGIN -- Trigger logic goes here.... END; 案例： CREATE TRIGGER audit_log AFTER INSERT ON COMPANY BEGIN INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, datetime('now')); END; 注意：datetime,new的使用,new代表COMPANY 找SELECT name FROM sqlite_master WHERE type = 'trigger'; SELECT name FROM sqlite_master WHERE type = 'trigger' AND tbl_name = 'COMPANY'; 删除DROP TRIGGER trigger_name; 综合案例1： CREATE TRIGGER trigger_name AFTER UPDATE OF id ON table_1 FOR EACH ROW WHEN new.id>30 BEGIN UPDATE table_2 SET id=new.id WHERE table_2.id=old.id; END; when 或 begin~ end 可以用new,old 访问table_1状态改变的前后变化 FOR EACH ROW ： 删了 10 行就触发 10 次 对应for each state 只删除一次sqlite 只支持each row; 案例2： 当表的内容超过4条时，删除指定内容的数据 create TRIGGER autit_trigger2 AFTER INSERT on AUDIT WHEN (select count(*) from AUDIT) > 4 BEGIN DELETE from AUDIT WHERE emp_id > 3; END 注意：When和begin~end 的操作须独立跑过一遍 Alter修改-- 重命名table ALTER TABLE database_name.table_name RENAME TO new_table_name; -- 增加字段 ALTER TABLE database_name.table_name ADD COLUMN column_def...; -- 案例 ALTER TABLE AUDIT add COLUMN ID INT 视图（View）视图（View）是一种虚表，由1或多个表组合而成，故View表由三大特点： 由于是任意组合可以更多变的展示数据，更直观； 有组合必有舍弃，故可以隐藏部分字段 直接生成虚拟表，比直接操作多个表会更方便 语法-- 创建View CREATE [TEMP | TEMPORARY] VIEW view_name AS SELECT column1, column2..... FROM table_name WHERE [condition]; -- 删除View DROP VIEW COMPANY_VIEW 案例： CREATE VIEW COMPANY_VIEW AS SELECT ID, NAME, AGE FROM COMPANY; 案例2： CREATE VIEW COMPANY_VIEW AS SELECT C.ID, C.NAME, C.AGE, A.EMP_ID FROM COMPANY C, AUDIT A WHERE C.ID = A.EMP_ID Transaction 事务控制命令只与DML命令INSERT、UPDATE 和 DELETE 一起使用,他们不能在创建表或删除表时使用 db.beginTransaction(); // 开启事务 try { db.execSQL（&quot;insert into person (name, age) values(?,?)&quot;, new Object[]{&quot;张三&quot;, 4}); db.execSQL(&quot;update person set name=? where personid=?&quot;, new Object[]{&quot;李四&quot;, 1}); db.setTransactionSuccessful(); // 标记事务完成 } finally { db.endTransaction(); // 结束事务 db.close(); } SQLite 子查询温馨提示： Where XX in (OOO) 查询SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY WHERE SALARY &gt; 45000) ; 插入INSERT INTO COMPANY_BKP SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY) ; 更新UPDATE COMPANY SET SALARY = SALARY * 0.50 WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt;= 27 ); 删除DELETE FROM COMPANY WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt; 27 ); Explain 输出只用于交互式分析和排除故障。 输出格式的细节随SQLite 版本变化 语法EXPLAIN [SQLite Query] EXPLAIN QUERY PLAN [SQLite Query] 案例： EXPLAIN SELECT * FROM COMPANY WHERE Salary &amp;gt= 20000; EXPLAIN QUERY PLAN SELECT * FROM COMPANY WHERE Salary &amp;gt= 20000; -- 结果： order from detail ---------- ---------- ------------- 0 0 TABLE COMPANY 日期 &amp; 时间日期 &amp; 时间 教程网址： date -- 当前时间 2018-09-17 SELECT date('now') -- 当前月份加1 --> 2018-10-01 SELECT date('now','start of month','+1 month') -- 当月最后一天 SELECT date('now','start of month','+1 month','-1 day'); -- 计算当年 10 月的第一个星期二的日期 SELECT date('now','start of year','+9 months','weekday 2'); datetime -- UNIX 时间戳 --> 2004-08-19 18:51:06 select datetime(1092941466, 'unixepoch'); strftime SELECT strftime('%s','now'); -- now - `1988-01-02 02:34:56` 过了多少秒 SELECT strftime('%s','now') - strftime('%s','1988-01-02 02:34:56');]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本UI空控件的用方法和属性]]></title>
    <url>%2F2018%2F09%2F17%2F2018-7-3-ui-open-source%2F</url>
    <content type="text"><![CDATA[提示类型Tosat GlideToast 工具类型 MaterialDateTimePicker 质感设计日期时间选择器 输入 Pattern Lock View 九宫格解锁 菜单 操作控件Button android-morphing-button]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌API之ConnectivityManager实战全解析（9分钟阅读时间）]]></title>
    <url>%2F2018%2F09%2F12%2F2018-9-12-api-ConnectivityManager%2F</url>
    <content type="text"><![CDATA[目录 最小案例 概况 实践概要 NetworkInfo 实践详解 ConnectivityManager 实践详解 Network 浅析 实用工具 参考 最小案例需要的权限 &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; MainActivity.java public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter=new IntentFilter(); intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver,intentFilter); } @Override protected void onDestroy(){ super.onDestroy(); unregisterReceiver(networkChangeReceiver); } private final class NetworkChangeReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent){ ConnectivityManager cm=(ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo= cm.getActiveNetworkInfo(); if(networkInfo == null){ // WIFI 和 移动网络都关闭 即没有有效网络 Log.e(TAG, "当前无网络连接"); return; } String typeName = ""; if(networkInfo.getType()==ConnectivityManager.TYPE_WIFI){ //WIFI网络跳转的页面. typeName = networkInfo.getTypeName();//==> WIFI }else if(networkInfo.getType()==ConnectivityManager.TYPE_MOBILE) { //无线网络跳转的页面 typeName = networkInfo.getTypeName();//==> MOBILE } Log.e(TAG, "==>" + typeName); Log.e(TAG, "==>" + networkInfo.getDetailedState()); } } } 概况ConnectivityManager主要职责，官方说明： Monitor network connections (Wi-Fi, GPRS, UMTS, etc.) Send broadcast intents when network connectivity changes Attempt to “fail over” to another network when connectivity to a network is lost Provide an API that allows applications to query the coarse-grained or fine-grained state of the available networks Provide an API that allows applications to request and select networks for their data traffic 平民翻译： 监控网络连接(Wi-Fi, GPRS, UMTS, etc.)； 当网络连接改变时发送Intent； 当连接到一个网络失败时，尝试用其他网络补救； 提供API给应用查询有效网络粗略或者精确的状态； 提供API给应用为它们的数据传输请求和选择网络； 实践概要NetworkInfo 实践详解 名称 说明 isConnected() 判断网络连接是否存在 isAvailable() 判断网络连接（注：isConnected为true，不代表isAvailable为true） getDetailedState() （详细）报告当前网络状态 getState()报告当前网络状态 getExtrInfo() 报告关于网络状态的额外信息，由较低的网络层提供的 getType() 获取当前网络的类型 和ConnectivityManager.TYPE_**对比 getTypeName() 获取当前网络的类型名如 “WIFI” or “MOBILE” 注意: isConnected() 和 isAvailable() 都为true 不能保证能正常连接到服务器，解决方案用ping命令，参考ShellUtil.execCmd：//ShellUtil.CommandResult result = ShellUtil.execCmd(String.format("ping -c 1 %s", ip), false); String[] command = new String[]{String.format("ping -c 1 %s", ip)}; int result = -1; Process process = Runtime.getRuntime().exec(isRoot ? "su" : "sh"); DataOutputStream os = new DataOutputStream(process.getOutputStream()); for (String command : commands) { if (command == null) continue; os.write(command.getBytes()); os.writeBytes(LINE_SEP); os.flush(); } os.writeBytes("exit" + LINE_SEP); os.flush(); result = process.waitFor(); getDetailedState/getState 直接看NetworkInfo源码getState等到的值为public enum State { CONNECTING, CONNECTED, SUSPENDED, DISCONNECTING, DISCONNECTED, UNKNOWN } getExtrInfo() WIFI链接返回SSID名称，移动网络返回APN（Access Point Name）,电信物联网得卡到列如：ctnet或ctwap ConnectivityManager 实践详解ConnectivityManager类按照其主要职能，常用方法大致可分为三类： 获取网络链接信息getXXX如getActiveNetwork，getDefaultProxy 多网络链接绑定指定网络 bindsocket和bindprocesstonetwork（6.0的系统 api&gt;23） 监听类型 registerDefaultNetworkCallback/registerNetworkCallback 方法 详解 addDefaultNetworkActiveListener 在网络有一定量的数据传输时间隔调用，可用于链接优化 cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); cm.addDefaultNetworkActiveListener(new ConnectivityManager.OnNetworkActiveListener() { @Override public void onNetworkActive() { Log.e(TAG, "Active ==>"); //无论是否成功链接外网，只要有一定量的数据传输就会间隔有回调 } }); 方法 详解 bindProcessToNetwork 多网络同时链接时指定网络链接 应用场景： 手机同时连接移动网络和本地局域网，手机所有的连接默认访问移动网络，需要手机连接本地局域网：Okhttp,picasso与glidez指定网络访问的案例 方法 详解 registerNetworkCallback 指定网络监听的内容回调 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP/*5.0*/) { ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); // 请注意这里会有一个版本适配bug，所以请在这里添加非空判断 if (connectivityManager != null) { NetworkRequest.Builder builder = new NetworkRequest.Builder(); NetworkRequest request = builder.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) .addTransportType(NetworkCapabilities.TRANSPORT_WIFI) .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR) .build(); connectivityManager.registerNetworkCallback(request,new ConnectivityManager.NetworkCallback(){ /** * 网络可用的回调连接成功 * */ @Override public void onAvailable(Network network) { super.onAvailable(network); Log.e(TAG, "onAvailable ==>" + network.toString()); } /** * 实践中在网络连接正常的情况下，丢失数据会有回调 * */ @Override public void onLosing(Network network, int maxMsToLive) { super.onLosing(network, maxMsToLive); Log.e(TAG, "onLosing ==>" + network.toString() + " max==>" + maxMsToLive); } /** * 网络不可用时调用和onAvailable成对出现 */ @Override public void onLost(Network network) { super.onLost(network); Log.e(TAG, "onLost ==>" + network.toString()); } @Override public void onUnavailable() { super.onUnavailable(); Log.e(TAG, "onUnavailable ==>"); } /** * 字面直接能理解 * @param network 新连接网络 * @param networkCapabilities 新连接网络的一些能力参数 */ @Override public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) { super.onCapabilitiesChanged(network, networkCapabilities); Log.e(TAG, "onCapabilitiesChanged ==>" + networkCapabilities.toString()); //WIFI -> CELLULAR //[ Transports: CELLULAR Capabilities: INTERNET&amp;NOT_RESTRICTED&amp;TRUSTED&amp;NOT_VPN&amp;VALIDATED LinkUpBandwidth>=51200Kbps LinkDnBandwidth>=102400Kbps Specifier: &lt;3>] //CELLULAR -> WIFI //==>[ Transports: WIFI Capabilities: INTERNET&amp;NOT_RESTRICTED&amp;TRUSTED&amp;NOT_VPN&amp;VALIDATED LinkUpBandwidth>=1048576Kbps LinkDnBandwidth>=1048576Kbps SignalStrength: -42] } /** * 和上面类似，但是没有试出效果 */ @Override public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) { super.onLinkPropertiesChanged(network, linkProperties); Log.e(TAG, "onLinkPropertiesChanged ==>" + linkProperties.toString()); } }); } } 更多监听内容设置请访问官网NetworkRequest 科学上网 Network 浅析从源码中可以得出Network就是一个Parcelable数据，最重要的参数是 public final int netId; 在回想一下Network什么时候第一次获得 @Override public void onAvailable(Network network) 如果到这里还啥都不get代码意图，那看Network提供的方法 public InetAddress[] getAllByName(String host) throws UnknownHostException { return InetAddress.getAllByNameOnNet(host, netId); } public InetAddress getByName(String host) throws UnknownHostException { return InetAddress.getByNameOnNet(host, netId); } bindSocket(Socket socket) getSocketFactory() openConnection(URL url) openConnection(URL url, Proxy proxy) 好到此我的理解是在网络连接onAvailable成功后,返回基于netId的底层网络标识，可以基于这个Network建立一些特殊的URL访问； 实用工具NetUtil.java //NetUtils.java private static final int NETWORK_TYPE_GSM = 16; private static final int NETWORK_TYPE_TD_SCDMA = 17; private static final int NETWORK_TYPE_IWLAN = 18; /** * 判断网络是否可用 * &lt;p>需要异步 ping，如果 ping 不通就说明网络不可用&lt;/p> * * @param ip ip 地址（自己服务器 ip），如果为空，ip 为阿里巴巴公共 ip * @return {@code true}: 可用&lt;br>{@code false}: 不可用 */ public static boolean isAvailableByPing(String ip) { if (ip == null || ip.length() &lt;= 0) { // 阿里巴巴公共 ip ip = "223.5.5.5"; } ShellUtil.CommandResult result = ShellUtil.execCmd(String.format("ping -c 1 %s", ip), false); boolean ret = result.result == 0; if (result.successMsg != null) { Log.d("NetUtil", "isAvailableByPing() called" + result.successMsg); } if (result.errorMsg != null) { Log.d("NetUtil", "isAvailableByPing() called" + result.errorMsg); } return ret; } /** * 判断移动数据是否打开 * * @return {@code true}: 是&lt;br>{@code false}: 否 */ public static boolean isMobileDataEnabled() { try { TelephonyManager tm = (TelephonyManager) Utils.getApp().getSystemService(Context.TELEPHONY_SERVICE); Method getMobileDataEnabledMethod = tm.getClass().getDeclaredMethod("getDataEnabled"); if (getMobileDataEnabledMethod != null) { return (boolean) getMobileDataEnabledMethod.invoke(tm); } } catch (Exception e) { e.printStackTrace(); } return false; } /** * 打开或关闭移动数据 * * @param enabled {@code true}: 打开&lt;br>{@code false}: 关闭 */ public static void setMobileDataEnabled(boolean enabled) { try { TelephonyManager tm = (TelephonyManager) Utils.getApp().getSystemService(Context.TELEPHONY_SERVICE); Method setMobileDataEnabledMethod = tm.getClass().getDeclaredMethod("setDataEnabled", boolean.class); if (null != setMobileDataEnabledMethod) { setMobileDataEnabledMethod.invoke(tm, enabled); } } catch (Exception e) { e.printStackTrace(); } } private enum NetworkType { // wifi NETWORK_WIFI, // 4G 网 NETWORK_4G, // 3G 网 NETWORK_3G, // 2G 网 NETWORK_2G, // 未知网络 NETWORK_UNKNOWN, // 没有网络 NETWORK_NO } /** * 获取当前网络类型 * * @return 网络类型 * &lt;ul> * &lt;li>{@link NetworkType#NETWORK_WIFI } &lt;/li> * &lt;li>{@link NetworkType#NETWORK_4G } &lt;/li> * &lt;li>{@link NetworkType#NETWORK_3G } &lt;/li> * &lt;li>{@link NetworkType#NETWORK_2G } &lt;/li> * &lt;li>{@link NetworkType#NETWORK_UNKNOWN} &lt;/li> * &lt;li>{@link NetworkType#NETWORK_NO } &lt;/li> * &lt;/ul> */ public static NetworkType getNetworkType() { NetworkType netType = NetworkType.NETWORK_NO; NetworkInfo info = getActiveNetworkInfo(); if (info != null &amp;&amp; info.isAvailable()) { if (info.getType() == ConnectivityManager.TYPE_WIFI) { netType = NetworkType.NETWORK_WIFI; } else if (info.getType() == ConnectivityManager.TYPE_MOBILE) { switch (info.getSubtype()) { case NETWORK_TYPE_GSM: case TelephonyManager.NETWORK_TYPE_GPRS: case TelephonyManager.NETWORK_TYPE_CDMA: case TelephonyManager.NETWORK_TYPE_EDGE: case TelephonyManager.NETWORK_TYPE_1xRTT: case TelephonyManager.NETWORK_TYPE_IDEN: netType = NetworkType.NETWORK_2G; break; case NETWORK_TYPE_TD_SCDMA: case TelephonyManager.NETWORK_TYPE_EVDO_A: case TelephonyManager.NETWORK_TYPE_UMTS: case TelephonyManager.NETWORK_TYPE_EVDO_0: case TelephonyManager.NETWORK_TYPE_HSDPA: case TelephonyManager.NETWORK_TYPE_HSUPA: case TelephonyManager.NETWORK_TYPE_HSPA: case TelephonyManager.NETWORK_TYPE_EVDO_B: case TelephonyManager.NETWORK_TYPE_EHRPD: case TelephonyManager.NETWORK_TYPE_HSPAP: netType = NetworkType.NETWORK_3G; break; case NETWORK_TYPE_IWLAN: case TelephonyManager.NETWORK_TYPE_LTE: netType = NetworkType.NETWORK_4G; break; default: String subtypeName = info.getSubtypeName(); // 中国移动 联通 电信 三种 3G 制式 if (subtypeName.equalsIgnoreCase("TD-SCDMA") || subtypeName.equalsIgnoreCase("WCDMA") || subtypeName.equalsIgnoreCase("CDMA2000")) { netType = NetworkType.NETWORK_3G; } else { netType = NetworkType.NETWORK_UNKNOWN; } break; } } else { netType = NetworkType.NETWORK_UNKNOWN; } } return netType; } 参考 ConnectivityManager 官网API 科学上网 Android多网络机制浅析 android 5.0 以上监听网络变化]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ConnectivityManager</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F09%2F2018-9-9-json-server%2F</url>
    <content type="text"><![CDATA[[TOC] 安装运行#Linxu/Mac os sudo npm install json-server -g #window npm install json-server -g 新建db.json用于测试json-server db.json -p 3003,-p 指定端口号为3003 json-server --watch db.json 在db.json 改变的时候不用重启服务器 { &quot;news&quot;:[ { &quot;id&quot;: 1, &quot;title&quot;: &quot;曹县宣布昨日晚间登日成功&quot;, &quot;date&quot;: &quot;2016-08-12&quot;, &quot;likes&quot;: 55, &quot;views&quot;: 100086 }, { &quot;id&quot;: 2, &quot;title&quot;: &quot;长江流域首次发现海豚&quot;, &quot;date&quot;: &quot;2016-08-12&quot;, &quot;likes&quot;: 505, &quot;views&quot;: 9800 } ], &quot;comments&quot;:[ { &quot;id&quot;: 1, &quot;news_id&quot;: 1, &quot;data&quot;: [ { &quot;id&quot;: 1, &quot;content&quot;: &quot;支持党中央决定&quot; }, { &quot;id&quot;: 2, &quot;content&quot;: &quot;抄写党章势在必行！&quot; } ] } ] } 出现错误：/usr/bin/env: node: No such file or directory 解决 ln -s /usr/bin/nodejs /usr/bin/node json-server requires at least version 6 of Node, please upgrade 解决 sudo npm cache clean -f sudo npm install -g n sudo n stable 快速启动脚本db.json 目录下新建package.json, 运行npm run mock { &quot;scripts&quot;: { &quot;mock&quot;: &quot;json-server db.json --port 3003&quot; } } 简单的数据操作 json-server和postman 简单教程 postman是模拟请求的开发神器 POST, PUT, PATCH or DELETE 这些操作会自动的保存在db.json文件里，请求必须是Json格式，包含头文件Content-Type: application/json 否则返回的虽然是200 OK，但是不会修改数据 id 的值是不可以修改的。任何id值在你的PUT 或者PATCH的body请求中将会被忽略。只有POST请求并且id值没有重复的时候会被考虑。注意：Object 如：profile:{} ，id值是可以改变的 GEThttp://localhost:3003/db ==&gt; 返回所以db.json数据http://localhost:3003/news ==&gt; 返回所有news节点 http://localhost:3003/news/1 ==&gt; 返回news节点id=1 的数据， &lt; font color=red &gt; 注意：必须存在id这个属性,并且类型为Integer POSTPostman向http://localhost:3003/news 新增id=3的参数 { &quot;id&quot;: 3, &quot;title&quot;: &quot;我是新加入的新闻&quot;, &quot;date&quot;: &quot;2016-08-12&quot;, &quot;likes&quot;: 0, &quot;views&quot;: 0 } json-server 后台反应 POST /news?id=3&amp;title=%E6%88%91%E6%98%AF%E6%96%B0%E5%8A%A0%E5%85%A5%E7%9A%84%E6%96%B0%E9%97%BB&amp;date=2016-08-12&amp;likes=0&amp;views=0 201 2.622 ms - 13 使用url encode 解码点击UrlDecode解码 POST /news?id=3&amp;title=我是新加入的新闻&amp;date=2016-08-12&amp;likes=0&amp;views=0 201 2.622 ms - 13 ##DELETE 删除news节点中id=3的参数 Postman向http://localhost:3003/news/3 请求方式PUThttp://localhost:3003/news/2 原参数为： { "id": 2 "title": "我", "date": "2016-08-12", "likes": 3, "views": 5 } 请求参数为： { "title": "我", "date": "2016-08-12" } 结果全量更新news节点id=2的参数 { "id": 2 "title": "我", "date": "2016-08-12" } json-server 后台打印 PUT /news?title=我是新加入的新闻&amp;date=2016-08-12&amp;likes=55&amp;views=100086 404 2.430 ms - 2 请求方式PATCH（部分更新）http://localhost:3003/news/2 原参数为： { "id": 2 "title": "我", "date": "2016-08-12", "likes": 3, "views": 5 } 请求参数 { "title": "我2" } 修改结果： { "id": 2 "title": "我", "date": "2016-08-12", "likes": 3, "views": 5 } 数据加工Filter对应的数据九宫格 comments:[ { "id": 1, "news_id": 1, "author":{ "name":"Steven-jobs", "age":32 }, "data": [ { "id": 1, "content": "支持党中央决定" }, { "id": 2, "content": "抄写党章势在必行！" } ] } ] ], "posts": [ { "id": 1, "title": "json-server", "author": "typicode" }, { "id": 2, "title": "json-server2", "author": "google" }, { "id": 3, "title": "json-server3", "author": "facebook" } 查询语句： GET /comments?id=1&amp;new_id=2 GET /posts?id=1&amp;id=2 GET /comments?author.name=Steven-jobs Paginate 分页GET /posts?_page=7 GET /posts?_page=7&amp;_limit=20 默认返回 10 items 表头会出现 first, prev, next and last 的直接访问地址，x-total-count数据总数信息access-control-expose-headers →X-Total-Count, Link link →&lt;http://localhost:3000/news?_page=1&gt;; rel=&quot;first&quot;, &lt;http://localhost:3000/news?_page=2&gt;; rel=&quot;next&quot;, &lt;http://localhost:3000/news?_page=2&gt;; rel=&quot;last&quot; x-total-count →20 其他排序默认升序 GET /posts?_sort=views&amp;_order=asc GET /posts/1/comments?_sort=votes&amp;_order=asc 切片 Slice包括_star,不包括_end GET /posts/1/comments?_start=20&amp;_end=30 GET /posts/1/comments?_start=20&amp;_limit=10 汇总 # _gte &gt; || _lte &lt; GET /posts?views_gte=10&amp;views_lte=20 # _ne != GET /posts?id_ne=1 # _like 注意title的字段名称 GET /posts?title_like=server # 全局搜索 GET /posts?q=internet # 直接获取数据 GET /db 关系图谱posts id 和comments id 是关联的 { &quot;posts&quot;: [ { &quot;id&quot;: 1, &quot;title&quot;: &quot;post的第一个title&quot;, &quot;author&quot;: &quot;typicode&quot; }, { &quot;id&quot;: 2, &quot;title&quot;: &quot;post的第二个title&quot;, &quot;author&quot;: &quot;tangcaiye&quot; } ], &quot;comments&quot;: [ { &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment1111&quot;, &quot;postId&quot;: 2 }, { &quot;id&quot;: 2, &quot;body&quot;: &quot;some comment2222&quot;, &quot;postId&quot;: 1 } ], &quot;profile&quot;: { &quot;name&quot;: &quot;typicode&quot; } } _embed http://localhost:3000/posts/2?_embed=comments 返回posts/2下级关联数据comments{ &quot;id&quot;: 2, &quot;title&quot;: &quot;post的第二个title&quot;, &quot;author&quot;: &quot;tangcaiye&quot;, &quot;comments&quot;: [ { &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment1111&quot;, &quot;postId&quot;: 2 } ] } _expand http://localhost:3000/comments/2?_expand=post 返回comments上级关联数据post{ &quot;id&quot;: 2, &quot;body&quot;: &quot;some comment2222&quot;, &quot;postId&quot;: 1, &quot;post&quot;: { &quot;id&quot;: 1, &quot;title&quot;: &quot;post的第一个title&quot;, &quot;author&quot;: &quot;typicode&quot; } } 模拟动态数据简单的返回数组/mock/db.js module.exports = function() { var data = { users: [] } // Create 1000 users for (var i = 0; i &lt; 1000; i++) { data.users.push({ id: i, name: &#39;user&#39; + i }) } return data } 运行 json-server db.js -p 3003 访问 http://localhost:3003/users 返回 [ { &quot;id&quot;: 0, &quot;name&quot;: &quot;user0&quot; }, { &quot;id&quot;: 1, &quot;name&quot;: &quot;user1&quot; } ...... ] 拒绝僵硬的数据，引入mockjs安装mockjs 在 /mock 目录下安装 npm install mockjs --save 示例:返回100条新闻数据 // # /mock/db.js let Mock = require(&#39;mockjs&#39;); let Random = Mock.Random; module.exports = function() { var data = { news: [] }; var images = [1,2,3].map(x=&gt;Random.image(&#39;200x100&#39;, Random.color(), Random.word(2,6))); for (var i = 0; i &lt; 100; i++) { var content = Random.cparagraph(0,10); data.news.push({ id: i, title: Random.cword(8,20), desc: content.substr(0,40), tag: Random.cword(2,6), views: Random.integer(100,5000), images: images.slice(0,Random.integer(1,3)) }) } return data } 运行 json-server db.js -p 3000 访问http://localhost:3000/news返回 [ { &quot;id&quot;: 0, &quot;title&quot;: &quot;元小总小把清保住影办历战资和总由&quot;, &quot;desc&quot;: &quot;共先定制向向圆适者定书她规置斗平相。要广确但教金更前三响角面等以白。眼查何参提适&quot;, &quot;tag&quot;: &quot;值集空&quot;, &quot;views&quot;: 3810, &quot;images&quot;: [ &quot;http://dummyimage.com/200x100/79f2a5&amp;text=别角置&quot;, &quot;http://dummyimage.com/200x100/f28279&amp;text=收面几容受取&quot;, &quot;http://dummyimage.com/200x100/7993f2&amp;text=做件&quot; ] }, ...... ] Mock 语法Mock.mockrepeat 方法（部分） Mock.mock({ &quot;string|5&quot;: &quot;★&quot; =&gt; &quot;string&quot;: &quot;★★★★★&quot; &quot;string|1-10&quot;: &quot;★&quot; =&gt; &quot;string&quot;: &quot;★★&quot; &quot;number|1-100&quot;: 100 =&gt; &quot;number&quot;: 85 &quot;number|1-100.2&quot;: 100 =&gt; &quot;number&quot;: 25.69 }) Mock.Random Random.boolean() =&gt; true false 各50% Random.integer(60, 100) =&gt; 78 Random.float(60, 100) =&gt; 89.565475 Random.range(60, 100) =&gt; [60,61,62,...,99] Random.date() =&gt; &quot;2018-12-28&quot; Random.image(&#39;200x100&#39;,&#39;#396&#39;) =&gt; &quot;http://dummyimage.com/200x100/396&quot; Random.color() =&gt; &quot;#79d8f2&quot; (默认使用hex颜色) Random.county(true) =&gt; &quot;浙江省 舟山市 岱山县&quot; Rnadom.imageRandom.image() // =&gt; &quot;http://dummyimage.com/125x125&quot; Random.image(&#39;200x100&#39;) // =&gt; &quot;http://dummyimage.com/200x100&quot; Random.image(&#39;200x100&#39;, &#39;#fb0a2a&#39;) // =&gt; &quot;http://dummyimage.com/200x100/fb0a2a&quot; Random.image(&#39;200x100&#39;, &#39;#02adea&#39;, &#39;Hello&#39;) // =&gt; &quot;http://dummyimage.com/200x100/02adea&amp;text=Hello&quot; Random.image(&#39;200x100&#39;, &#39;#00405d&#39;, &#39;#FFF&#39;, &#39;Mock.js&#39;) // =&gt; &quot;http://dummyimage.com/200x100/00405d/FFF&amp;text=Mock.js&quot; Random.image(&#39;200x100&#39;, &#39;#ffcc33&#39;, &#39;#FFF&#39;, &#39;png&#39;, &#39;!&#39;) // =&gt; &quot;http://dummyimage.com/200x100/ffcc33/FFF.png&amp;text=!&quot; Textparagraph-&gt; centence -&gt; word -&gt; title #中文 Random.cparagraph() Random.cparagraph( len ) Random.cparagraph( min, max ) #随机生成一段中文文本 Random.csentence() Random.csentence( len ) Random.csentence( min, max ) # 随机生成一个汉字 Random.cword() Random.cword( pool ) Random.cword( length ) Random.cword( pool, length ) Random.cword( min, max ) Random.cword( pool, min, max ) 进阶路由设置 注意：没有设置路由（主要是： “host”: “0.0.0.0” 属性）之前 json-server --watch db.json 只有本机能访问，也就是局域网外网都不能访问 可以用-H 命令指定json-server --watch db.json -H 0.0.0.0 host 设置为127.0.0.1 或者本地局域网IP地址 如192.168.1.168 无效 ，(服务器指定127.0.0.1/ 192.168.1.168是本地调试模式)具体解释网址 大意： 0.0.0.0指的是本机上的所有IPV4地址IPV4中，0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。 在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。 在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。 设置的两种方法 直接命令行指定路由文件json-server db.js -p 3003 -d 500 -q -r ./routes.json json-server.json 文件进行配置后，直接json-server db.json# /mock/json-server.json { &quot;host&quot;: &quot;0.0.0.0&quot;, &quot;port&quot;: &quot;3003&quot;, &quot;watch&quot;: false, &quot;delay&quot;: 500, &quot;quiet&quot;: true, &quot;routes&quot;: &quot;./routes.json&quot; } 自定义路由，可以指定访问链接返回指定的数据，而且可以动态修改 routes.json { &quot;/api/*&quot;: &quot;/$1&quot;, &quot;/:resource/:id/show&quot;: &quot;/:resource/:id&quot;, &quot;/posts/:category&quot;: &quot;/posts?category=:category&quot;, &quot;/articles\\?id=:id&quot;: &quot;/posts/:id&quot; } 对应的效果 /api/posts # → /posts /api/posts/1 # → /posts/1 /posts/1/show # → /posts/1 /posts/javascript # → /posts?category=javascript /articles?id=1 # → /posts/1 &quot;/api/*&quot;: &quot;/$1&quot; 相当于把api路径给忽略掉 /:resource 取值是变动的 每个路径必须以/开头增加中间件 // hello.js module.exports = (req, res, next) =&gt; { res.header(&#39;X-Hello&#39;, &#39;World&#39;) next() } json-server db.json --middlewares ./hello.js json-server db.json --middlewares ./first.js ./second.js Nodejs Module 不用等后台同事API为什么学了上面还要学nodejs的案例呢？ 因为上面的技能还不能很好的满足开发中REST API的需求 rount.json 储存在文件中修改比较麻烦 只用配置文件，不很好使用Mock的相关功能 把配置放在js中相对灵活，能动态的拦截返回和处理相关逻辑 最简单案例node 安装 json-server模块 $ npm install json-server --save-dev // server.js const jsonServer = require(&#39;json-server&#39;) const server = jsonServer.create() const router = jsonServer.router(&#39;db.json&#39;) //默认为当前目录 //const path = require(&#39;path&#39;) 指定其他目录 //const router = jsonServer.router(path.join(__dirname, &#39;db.json&#39;)) const middlewares = jsonServer.defaults() server.use(middlewares) server.use(router) server.listen(3000, () =&gt; { console.log(&#39;JSON Server is running&#39;) }) // 运行 $ node server.js 自定义路由const jsonServer = require(&#39;json-server&#39;) const server = jsonServer.create() const router = jsonServer.router(&#39;db.json&#39;) const middlewares = jsonServer.defaults() // Set default middlewares (logger, static, cors and no-cache) server.use(middlewares) // Add custom routes before JSON Server router server.get(&#39;/echo&#39;, (req, res) =&gt; { res.jsonp(req.query) }) // To handle POST, PUT and PATCH you need to use a body-parser // You can use the one used by JSON Server server.use(jsonServer.bodyParser) server.use((req, res, next) =&gt; { if (req.method === &#39;POST&#39;) { req.body.createdAt = Date.now() } // Continue to JSON Server router next() }) // Use default router server.use(router) server.listen(3000, () =&gt; { console.log(&#39;JSON Server is running&#39;) }) 对上面的几点进行说明res.jsonp res ==&gt; respose res.status(500).jsonp({ error: &quot;error message here&quot; &quot;id&quot;: 21, &quot;title&quot;: &quot;长江&quot;, &quot;date&quot;: &quot;2016-09-12&quot;, &quot;likes&quot;: 509, &quot;views&quot;: 9900 }) 请求的返回Json格式 { &quot;error&quot;: &quot;error message here&quot; &quot;id&quot;: 21, &quot;title&quot;: &quot;长江&quot;, &quot;date&quot;: &quot;2016-09-12&quot;, &quot;likes&quot;: 509, &quot;views&quot;: 9900 } req.body.createdAt = Date.now() 往返回的jons中插入createAt字段，如本应返回 { &quot;id&quot;: 21, &quot;title&quot;: &quot;长江&quot;, &quot;date&quot;: &quot;2016-09-12&quot;, &quot;likes&quot;: 509, &quot;views&quot;: 9900 } 加入req.body.createdAt = Date.now()后返回 { &quot;id&quot;: 21, &quot;title&quot;: &quot;长江&quot;, &quot;date&quot;: &quot;2016-09-12&quot;, &quot;likes&quot;: 509, &quot;views&quot;: 9900, &quot;createdAt&quot;: 1536476508883, } js 增加router.json 配置// Add this before server.use(router) server.use(jsonServer.rewriter({ &#39;/api/*&#39;: &#39;/$1&#39;, &#39;/blog/:resource/:id/show&#39;: &#39;/:resource/:id&#39; })) 访问控制const jsonServer = require(&#39;json-server&#39;) const server = jsonServer.create() const router = jsonServer.router(&#39;db.json&#39;) const middlewares = jsonServer.defaults() server.use(middlewares) server.use((req, res, next) =&gt; { if (isAuthorized(req)) { // add your authorization logic here next() // continue to JSON Server router } else { res.sendStatus(401) } }) server.use(router) server.listen(3000, () =&gt; { console.log(&#39;JSON Server is running&#39;) }) 自定义输出// In this example, returned resources will be wrapped in a body property router.render = (req, res) =&gt; { res.jsonp({ body: res.locals.data }) //res.jsonp =&gt; 包裹数据成json格式 //res.send =&gt; 直接发送字符串 } 访问本应返回 { &quot;id&quot;: 21, &quot;title&quot;: &quot;长江&quot;, &quot;date&quot;: &quot;2016-09-12&quot; } 增加 body: res.locals.data后返回 { body: { id: 1, title: &quot;曹县宣布昨日晚间登日成功&quot;, date: &quot;2016-08-12&quot;, likes: 55, views: 100086 } } 终极Demo访问http://localhost:3000/echo 返回模拟数据 const jsonServer = require(&#39;json-server&#39;) const server = jsonServer.create() const router = jsonServer.router(&#39;db.json&#39;) const middlewares = jsonServer.defaults() let Mock = require(&#39;mockjs&#39;); server.use(middlewares) var template = { &#39;titles&#39;: &#39;Syntax Demo&#39;, &#39;string1|1-10&#39;: &#39;★&#39;, &#39;string2|3&#39;: &#39;value&#39;, &#39;number1|+1&#39;: 100, &#39;number2|1-100&#39;: 100, &#39;number3|1-100.1-10&#39;: 1, &#39;number4|123.1-10&#39;: 1, &#39;number5|123.3&#39;: 1, &#39;number6|123.10&#39;: 1.123, &#39;boolean1|1&#39;: true, &#39;boolean2|1-2&#39;: true, &#39;object1|2-4&#39;: { &#39;110000&#39;: &#39;北京市&#39;, &#39;120000&#39;: &#39;天津市&#39;, &#39;130000&#39;: &#39;河北省&#39;, &#39;140000&#39;: &#39;山西省&#39; }, &#39;object2|2&#39;: { &#39;310000&#39;: &#39;上海市&#39;, &#39;320000&#39;: &#39;江苏省&#39;, &#39;330000&#39;: &#39;浙江省&#39;, &#39;340000&#39;: &#39;安徽省&#39; }, &#39;array1|1&#39;: [&#39;AMD&#39;, &#39;CMD&#39;, &#39;KMD&#39;, &#39;UMD&#39;], &#39;array2|1-10&#39;: [&#39;Mock.js&#39;], &#39;array3|3&#39;: [&#39;Mock.js&#39;], &#39;function&#39;: function() { return this.titles } } server.get(&#39;/echo&#39;, (req, res) =&gt; { var data = Mock.mock(template) var json = JSON.stringify(data, null, 4) console.log(&#39;-----------------\n&#39; + json) res.send(json) }) // To handle POST, PUT and PATCH you need to use a body-parser // You can use the one used by JSON Server server.use(jsonServer.bodyParser) server.use((req, res, next) =&gt; { console.log(&#39;--------------&#39;+req.method) if (req.method === &#39;POST&#39;) { req.body.createdAt = Date.now() req.body.test = 1 } // Continue to JSON Server router next() }) // 返回错误码，和指定json格式的数据 //router.render = (req, res) =&gt; { // res.status(500).jsonp({ // error: &quot;error message here&quot; // &quot;id&quot;: 21, // &quot;title&quot;: &quot;长江&quot;, // &quot;date&quot;: &quot;2016-09-12&quot;, // &quot;likes&quot;: 509, // &quot;views&quot;: 9900 // }) //} // Add this before server.use(router) server.use(jsonServer.rewriter({ &#39;/api/*&#39;: &#39;/$1&#39;, &#39;/blog/:resource/:id/show&#39;: &#39;/:resource/:id&#39; })) router.render = (req, res) =&gt; { res.jsonp({ body: res.locals.data }) } server.use(router) server.listen(3000, () =&gt; { console.log(&#39;JSON Server is running&#39;) }) 附录json-server 命令参数 json-server index.js [options] &lt;source&gt; 选项： --config, -c Path to config file [默认值: &quot;json-server.json&quot;] --port, -p Set port [默认值: 3000] --host, -H Set host [默认值: &quot;localhost&quot;] --watch, -w Watch file(s) [布尔] --routes, -r Path to routes file --middlewares, -m Paths to middleware files [数组] --static, -s Set static files directory --read-only, --ro Allow only GET requests [布尔] --no-cors, --nc Disable Cross-Origin Resource Sharing [布尔] --no-gzip, --ng Disable GZIP Content-Encoding [布尔] --snapshots, -S Set snapshots directory [默认值: &quot;.&quot;] --delay, -d Add delay to responses (ms) --id, -i Set database id property (e.g. _id) [默认值: &quot;id&quot;] --foreignKeySuffix, --fks Set foreign key suffix (e.g. _id as in post_id) [默认值: &quot;Id&quot;] --quiet, -q Suppress log messages from output [布尔] --help, -h 显示帮助信息 [布尔] --version, -v 显示版本号 [布尔] 示例： index.js db.json index.js file.js index.js http://example.com/db.json https://github.com/typicode/json-server Missing &lt;source&gt; argument URL 加密解密工具Json-server Github网址 上面有更详细的使用说明 Mockjs WiKiJSONView：json美化 Chrome 插件 使用Chrome 的同学推荐使用 参考 用JSON-server模拟REST API(一) 安装运行 用JSON-server模拟REST API(二) 动态数据 用JSON-server模拟REST API(三) 进阶使用 json-server的关系图谱详解（Relationships）]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>API</tag>
        <tag>json-server</tag>
        <tag>REST </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬件相关开源库]]></title>
    <url>%2F2018%2F08%2F28%2F2018-8-28-hard-open-source%2F</url>
    <content type="text"><![CDATA[sensey 很简洁的代码实现对传感器的监听 RxBiometric 用RxJava 实现对指纹扫描的控制 RxJava and RxKotlin bindings for Biometric Prompt (Fingerprint Scanner) on Android SmartCamera Android指纹识别API兼容库]]></content>
      <categories>
        <category>open source</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>open source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网页工具]]></title>
    <url>%2F2018%2F08%2F28%2F2018-5-5-android-web-tools%2F</url>
    <content type="text"><![CDATA[在线看代码在线看Android源码 https://www.androidos.net.cn/sourcecode codota 查询代码案例 查看不同版本Android，JDK源码 依赖 maven 仓库中搜索依赖 统计依赖大小，方法数量的变化 引用Android隐藏的Api 查看Android源码#Api 23 举例 /platforms/android-23/android.jar --> backup android.jar ==> android-.jar 下载对应android.jar 开源项目查找 GitHub 搜索 工具 json转化 Free Online IDE and Terminal 支持几乎所有主流编程语言的在线IDE terminalizer 录制终端命令行并转化成gif sourcegraph 基于网页端和Git的智能源码查看工具，可以本地安装 在线很好的正则表达式学习网站 https://regexr.com/]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Preference 设置看图说话之基础篇（5分钟掌握）]]></title>
    <url>%2F2018%2F08%2F28%2F2018-8-28-fundamental-android-preference%2F</url>
    <content type="text"><![CDATA[[TOC] 前言自己独立开发过了比较多的app，发现关于设置的UI和相关的处理自己写不旦增加类开发工作量，而且常常会使整个代码层次和逻辑会变的相当混乱，让人头痛，在不考虑自己花时间弄一个设置管理类管理好设置代码，及自己处理各种UI控件的前提下，使用官方提供的Preference是最优也是最高效的选择； Android Preference 提供的控件这里只列举常用的support.v7,其他的也大同小异引入方式,gradle 下配置 implementation &#39;com.android.support:preference-v7:27.1.1&#39; 官方总结-科学上网, 使用的时候查询对应属性设置 ↳ android.support.v7.preference.Preference ↳ Known Direct SubclassesDialogPreference,PreferenceGroup,SeekBarPreference,TwoStatePreferenceKnown Indirect SubclassesCheckBoxPreference,DropDownPreference,EditTextPreference,ListPreference, MultiSelectListPreference,PreferenceCategory,PreferenceScreen, SwitchPreference, SwitchPreferenceCompat Xml案例(For example:)： &lt;?xml version="1.0" encoding="utf-8"?> &lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"> &lt;CheckBoxPreference android:key="pref_sync" android:title="@string/pref_sync" android:summary="@string/pref_sync_summ" android:defaultValue="true" /> &lt;ListPreference android:dependency="pref_sync" android:key="pref_syncConnectionType" android:title="@string/pref_syncConnectionType" android:dialogTitle="@string/pref_syncConnectionType" android:entries="@array/pref_syncConnectionTypes_entries" android:entryValues="@array/pref_syncConnectionTypes_values" android:defaultValue="@string/pref_syncConnectionTypes_default" /> &lt;/PreferenceScreen> Java 案例： public class SettingsActivity extends PreferenceActivity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.preferences); } } public class SettingsActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Display the fragment as the main content. getFragmentManager().beginTransaction() .replace(android.R.id.content, new SettingsFragment()) .commit(); } } 不同版本大致区别 v14 Preference Support Library com.android.support:preference-v14:27.1.1增加了 PreferenceFragment.OnPreferenceStartFragmentCallback 和PreferenceFragment.OnPreferenceStartScreenCallback, 更新了一些类, 如：`MultiSelectListPreference and PreferenceFragment v17 Preference 主要是增加了对TV的支持； 具体流程 注意： findPreference/onPreferenceTreeClick 等方法在android.preference.PreferenceActivity Api16 (4.1) 中被弃用，在PreferenceFragmentCompat中能正常使用，故官方推荐使用PreferenceFragmentCompat； 新建xml使用组（Group）案例： &lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"> &lt;PreferenceCategory android:title="@string/pref_sms_storage_title" android:key="pref_key_storage_settings"> &lt;CheckBoxPreference android:key="pref_key_auto_delete" android:summary="@string/pref_summary_auto_delete" android:title="@string/pref_title_auto_delete" android:defaultValue="false"... /> &lt;Preference android:key="pref_key_sms_delete_limit" android:dependency="pref_key_auto_delete" android:summary="@string/pref_summary_delete_limit" android:title="@string/pref_title_sms_delete"... /> &lt;Preference android:key="pref_key_mms_delete_limit" android:dependency="pref_key_auto_delete" android:summary="@string/pref_summary_delete_limit" android:title="@string/pref_title_mms_delete" ... /> &lt;/PreferenceCategory> ... &lt;/PreferenceScreen> 使用子屏幕（subscreens）案例代码： &lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"> &lt;!-- opens a subscreen of settings --> &lt;PreferenceScreen android:key="button_voicemail_category_key" android:title="@string/voicemail" android:persistent="false"> &lt;ListPreference android:key="button_voicemail_provider_key" android:title="@string/voicemail_provider" ... /> &lt;!-- opens another nested subscreen --> &lt;PreferenceScreen android:key="button_voicemail_setting_key" android:title="@string/voicemail_settings" android:persistent="false"> ... &lt;/PreferenceScreen> &lt;RingtonePreference android:key="button_voicemail_ringtone_key" android:title="@string/voicemail_ringtone_title" android:ringtoneType="notification" ... /> ... &lt;/PreferenceScreen> ... &lt;/PreferenceScreen> 使用intents&lt;Preference android:title="@string/prefs_web_page" > &lt;intent android:action="android.intent.action.VIEW" android:data="http://www.example.com" /> &lt;/Preference> 属性有： android:action android:data android:mimeType android:targetClass android:targetPackage 请注意：上面的设置已经够日常使用 处理读 SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this); String syncConnPref = sharedPref.getString(SettingsActivity.KEY_PREF_SYNC_CONN, ""); 监听 findPreference里面的参数就是我们使用android:key所定义 onPreferenceTreeClick Prefs tree点击时调用 注册方式： @Override protected void onResume() { super.onResume(); getPreferenceScreen().getSharedPreferences() .registerOnSharedPreferenceChangeListener(this); } @Override protected void onPause() { super.onPause(); getPreferenceScreen().getSharedPreferences() .unregisterOnSharedPreferenceChangeListener(this); } 设置监听方式： SharedPreferences.OnSharedPreferenceChangeListener listener = new SharedPreferences.OnSharedPreferenceChangeListener() { public void onSharedPreferenceChanged(SharedPreferences prefs, String key) { // listener implementation } }; prefs.registerOnSharedPreferenceChangeListener(listener); 使用小案例还原初始设置PreferenceManager.setDefaultValues(Context, R.xml.advanced_preferences, false); false ： 首次调用生效；（true 每次调用都生效） 面包原材料 Develop Guide Settings 【主要.科学上网】 Android Preference 设置全攻略 其实看这个也可以 异常处理 Caused by: java.lang.IllegalStateException: Must specify preferenceTheme in theme at android.support.v7.preference.PreferenceFragmentCompat.onCreate(PreferenceFragmentCompat.java:211)]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>note</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI/NDK开发指南学习笔记]]></title>
    <url>%2F2018%2F08%2F15%2F2018-8-15-jni-note%2F</url>
    <content type="text"><![CDATA[[TOC] JNI开发流程及HelloWorld基础知识：不同平台的动态库（windows：*.dll，linux/unix：*.so，mac os x：*.jnilib） JNI开发主要流程 第一步、并新建一个HelloWorld.java源文件 package com.study.jnilearn; public class HelloWorld { public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现 public static void main(String[] args) { String text = sayHello("yangxin"); // 3.调用本地函数 System.out.println(text); } static { System.loadLibrary("HelloWorld"); // 2.加载实现了native函数的动态库，只需要写动态库的名字 } } 用javac命令将.java源文件编译成.class字节码文件//-d 指定目录 javac src/com/study/jnilearn/HelloWorld.java -d ./bin 生成.h头文件javah -jni -classpath ./bin -d ./jni com.study.jnilearn.HelloWorld 实现.h头文件中的函数com_study_jnilearn_HelloWorld.h： /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h> /* Header for class com_study_jnilearn_HelloWorld */ #ifndef _Included_com_study_jnilearn_HelloWorld #define _Included_com_study_jnilearn_HelloWorld #ifdef __cplusplus extern "C" { #endif /* * Class: com_study_jnilearn_HelloWorld * Method: sayHello * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello (JNIEnv *, jclass, jstring); #ifdef __cplusplus } #endif #endif 将C/C++代码编译成本地动态库文件#-I 包含头文件 # -fPIC： 编译成与位置无关的独立代码 # -shared：编译成动态库 # -o 指定输出 gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so 运行Java程序 so库加载及相关配置如果手上有动态库； win: libHelloWorld.dll，linux/unix：libHelloWorld.so，mac os x：libHelloWorld.jnilib 加载方式 //1. 不需要加lib前缀，也不要加.so、.dll和.jnilib后缀 System.loadLibrary("HelloWorld"); //2. 指定动态库的绝对路径名，需要加上前缀和后缀 System.load("/Users/yangxin/Desktop/libHelloWorld.jnilib"); 加载方式1的配置 //1. 将动态链接库拷贝到java.library.path目录 String libraryDirs = System.getProperty("java.library.path"); System.out.println(libraryDirs); // 输出结果如下： /Users/yangxin/Library/Java/Extensions:/Library/Java/Extensions: // 2. 指定系统属性java.library.path的值 java -Djava.library.path=/Users/yangxin/Desktop // 3. 指定库的搜索目录: Linux/Unix环境下可以通过设置LD_LIBRARY_PATH环境变量。 JNI数据类型// HelloWorld.java public static native void test(short s, int i, long l, float f, double d, char c, boolean z, byte b, String str, Object obj, MyClass p, int[] arr); // HelloWorld.h JNIEXPORT void JNICALL Java_com_study_jnilearn_HelloWorld_test (JNIEnv *env, jclass cls, jshort s, jint i, jlong l, jfloat f, jdouble d, jchar c, jboolean z, jbyte b, jstring j_str, jobject jobj1, jobject job2, jintArray j_int_arr) 主要类型： 数组： 其他JNIEnv和jclass jobject C++ and C 不同C++ 和Java一样面向对象 所有引用类型自jobject派生 class _jobject {}; class _jclass : public _jobject {}; class _jstring : public _jobject {}; class _jarray : public _jobject {}; class _jbooleanArray : public _jarray {}; class _jbyteArray : public _jarray {}; ... C 使用typedef重新定义，如：typedef jobject jstring jvalue typedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l; } jvalue; 字符串处理基础知识 JNI把Java中的所有对象当作一个C指针传递到本地方法中，这个指针指向JVM中的内部数据结构，而内部的数据结构在内存中的存储方式是不可见的。只能从JNIEnv指针指向的函数表中选择合适的JNI函数来操作JVM中的数据结构 Java默认使用Unicode编码，而C/CPP默认使用UTF编码；GetXXUTFXX/ReleaseXXUTFXX 用于C/CPP 字符三部曲 GET -&gt; Release -&gt; Newconst char *c_str = NULL; char buff[128] = {0}; jboolean isCopy; // 返回JNI_TRUE表示原字符串的拷贝，返回JNI_FALSE表示返回原字符串的指针 c_str = (*env)->GetStringUTFChars(env, j_str, &amp;isCopy); printf("C_str: %s \n", c_str); sprintf(buff, "hello %s", c_str); (*env)->ReleaseStringUTFChars(env, j_str, c_str); return (*env)->NewStringUTF(env,buff); GetStringUTFChars(env, j_str, &amp;isCopy) 说明： isCopy 默认为NULL就好 JNI_TRUE Jvm中j_str复制一份; JNI_FALSE 返回源字符串的内容，不推荐； UTF Java默认使用Unicode编码，而C/C++默认使用UTF编码，GetStringUTFChars可以把一个jstring指针（指向JVM内部的Unicode字符序列）转换成一个UTF-8格式的C字符串 异常检查 因为JVM需要为新诞生的字符串分配内存空间，当内存空间不够分配的时候，会导致调用失败，失败后GetStringUTFChars会返回NULL，并抛出一个OutOfMemoryError异常。JNI的异常不会停止而是继续往下，留下一个空指针。 if(GetStringUTFChars == NULL ) return ; 释放字符串 GetStringUTFChars 会分配内存需释放 同理： GETXX就必须调用ReleaseXXX NewStringUTFgraph LR NewStringUTF --&gt; JVM新建java.lang.String; JVM新建java.lang.String --&gt; 没有内存; 没有内存--&gt; OutOfMemoryError ; 其他函数 Get和ReleaseStringChars(Unicode)vs Get/ReleaseStringUTFChars(UTF-8) GetStringLength/GetStringUTFLength 由于UTF-8编码的字符串以’\0’结尾，而Unicode字符串不是。 Get/ReleaseStringCritical：提高JVM返回源字符串直接指针的可能性 当字符1M左右，较大时使用 两个代码间，不可以执行导致阻塞的调用或为新对象在JVM中分配内存，否则，JVM有可能死锁。JNIEXPORT jstring JNICALL Java_com_study_jnilearn_Sample_sayHello (JNIEnv *env, jclass cls, jstring j_str) { const jchar* c_str= NULL; char buff[128] = "hello "; char* pBuff = buff + 6; /* * 在GetStringCritical/RealeaseStringCritical之间是一个关键区。 * 在这关键区之中,绝对不能呼叫JNI的其他函数和会造成当前线程中断或是会让当前线程等待的任何本地代码， * 否则将造成关键区代码执行区间垃圾回收器停止运作，任何触发垃圾回收器的线程也会暂停。 * 其他触发垃圾回收器的线程不能前进直到当前线程结束而激活垃圾回收器。 */ c_str = (*env)->GetStringCritical(env,j_str,NULL); // 返回源字符串指针的可能性 if (c_str == NULL) // 验证是否因为字符串拷贝内存溢出而返回NULL { return NULL; } while(*c_str) { *pBuff++ = *c_str++; } (*env)->ReleaseStringCritical(env,j_str,c_str); return (*env)->NewStringUTF(env,buff); } GetStringRegion和GetStringUTFRegion 源字符串复制到一个预先分配的缓冲区内【不分配内存】，UTF越界 会报StringIndexOutOfBoundsException; 【推荐使用】 缓冲区可以被编译器提前分配，而且永远不会产生内存溢出的异常 提供了一个开始索引和子字符串的长度值 复制少量字符串的消耗非常小jsize len = (*env)->GetStringLength(env,j_str); // 获取unicode字符串的长度 printf("str_len:%d\n",len); char buff[128] = "hello "; char* pBuff = buff + 6; // 将JVM中的字符串以utf-8编码拷入C缓冲区,该函数内部不会分配内存空间 (*env)->GetStringUTFRegion(env,j_str,0,len,pBuff); return (*env)->NewStringUTF(env,buff); Crash错误定位sdk\ndk-bundle\toolchains选择出分析对应CPU架构的so文件 Toolchain Location arm $TOOLCHAIN/arm-linux-androideabi/lib/ arm64 $TOOLCHAIN/aarch64-linux-android/lib/ x86 $TOOLCHAIN/i686-linux-android/lib/ x86_64 $TOOLCHAIN/x86_64-linux-android/lib/ #02 pc 0000242f /data/app/com.hard.dev.spiproject-C3PjhijiVGgyqX2M1fK3KQ==/lib/arm/libspi-lib.so (will_crash+30) #03 pc 0000245b /data/app/com.hard.dev.spiproject-C3PjhijiVGgyqX2M1fK3KQ==/lib/arm/libspi-lib.so (JNI_OnLoad+18) 两位数字 pc”开头的都是backtrace日志 0000242f 0000245b为 arm-linux-androideabi-addr2line 定位出错位置 adb pull /data/app/com.hard.dev.spiproject-C3PjhijiVGgyqX2M1fK3KQ==/lib/arm/libspi-lib.so arm-linux-androideabi-addr2line -e libspi-lib.so 0000242f 0000245b 使用arm-linux-androideabi-objdump 定位出错的函数信息arm-linux-androideabi-objdump -S -D libspi-lib.so &gt; dump.log ndk-stackadb logcat &gt; /tmp/foo.txt #其中$PROJECT_PATH/obj/local/armeabi-v7a 指定生成的so库路径 $NDK/ndk-stack -sym $PROJECT_PATH/obj/local/armeabi-v7a -dump foo.txt 输出 Routine后有指明保存源码位置Stack frame #05 pc 00000d1c /data/app-lib/com.example.hellojni-1/libhello-jni.so (JNI_OnLoad+20):Routine JNI_OnLoad at /samples/hello-jni/jni/hello-jni.c:15 访问数组（基本类型数组与对象数组）GetIntArrayRegion 【小量的、固定大小的数组】返回Int型数组的和例子 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h> /* Header for class com_study_jnilearn_IntArray */ #ifndef _Included_com_study_jnilearn_IntArray #define _Included_com_study_jnilearn_IntArray #ifdef __cplusplus extern "C" { #endif /* * Class: com_study_jnilearn_IntArray * Method: sumArray * Signature: ([I)I */ JNIEXPORT jint JNICALL Java_com_study_jnilearn_IntArray_sumArray (JNIEnv *, jobject, jintArray); #ifdef __cplusplus } #endif #endif // IntArray.c #include "com_study_jnilearn_IntArray.h" #include &lt;string.h> #include &lt;stdlib.h> /* * Class: com_study_jnilearn_IntArray * Method: sumArray * Signature: ([I)I */ JNIEXPORT jint JNICALL Java_com_study_jnilearn_IntArray_sumArray (JNIEnv *env, jobject obj, jintArray j_array) { jint i, sum = 0; jint *c_array; jint arr_len; //1. 获取数组长度 arr_len = (*env)->GetArrayLength(env,j_array); //2. 根据数组长度和数组元素的数据类型申请存放java数组元素的缓冲区 c_array = (jint*)malloc(sizeof(jint) * arr_len); //3. 初始化缓冲区 memset(c_array,0,sizeof(jint)*arr_len); printf("arr_len = %d ", arr_len); //4. 拷贝Java数组中的所有元素到缓冲区中 (*env)->GetIntArrayRegion(env,j_array,0,arr_len,c_array); for (i = 0; i &lt; arr_len; i++) { sum += c_array[i]; //5. 累加数组元素的和 } free(c_array); //6. 释放存储数组元素的缓冲区 return sum; } 优化GetIntArrayElementsJNIEXPORT jint JNICALL Java_com_study_jnilearn_IntArray_sumArray2 (JNIEnv *env, jobject obj, jintArray j_array) { jint i, sum = 0; jint *c_array; jint arr_len; // 可能数组中的元素在内存中是不连续的，JVM可能会复制所有原始数据到缓冲区，然后返回这个缓冲区的指针 c_array = (*env)->GetIntArrayElements(env,j_array,NULL); // NULL JNI_TRUE 缓冲区数组指针 JNI_FALSE 原始 if (c_array == NULL) { return 0; // JVM复制原始数据到缓冲区失败 } arr_len = (*env)->GetArrayLength(env,j_array); printf("arr_len = %d\n", arr_len); for (i = 0; i &lt; arr_len; i++) { sum += c_array[i]; } (*env)->ReleaseIntArrayElements(env,j_array, c_array, 0); // 释放可能复制的缓冲区 return sum; } GetIntArrayElements 缺点 有可能在申请开辟临时缓冲区内存空间时，会内存不足导致申请失败，返回NULL GC占用对象锁，导致本地线程一直堵塞 Get/ReleasePrimitiveArrayCritical 暂停GC 特点：地代码在访问数组对象时会暂停GC线程 注意：两个函数期间不能调用任何会让线程阻塞或等待JVM中其它线程的本地函数或JNI函数 对象数组Get/SetObjectArrayElement案例：ObjectArray.java package com.study.jnilearn; public class ObjectArray { private native int[][] initInt2DArray(int size); public static void main(String[] args) { ObjectArray obj = new ObjectArray(); int[][] arr = obj.initInt2DArray(3); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { System.out.format("arr[%d][%d] = %d\n", i, j, arr[i][j]); } } } static { System.loadLibrary("ObjectArray"); } } C语言 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h> /* Header for class com_study_jnilearn_ObjectArray */ #ifndef _Included_com_study_jnilearn_ObjectArray #define _Included_com_study_jnilearn_ObjectArray #ifdef __cplusplus extern "C" { #endif /* * Class: com_study_jnilearn_ObjectArray * Method: initInt2DArray * Signature: (I)[[I */ JNIEXPORT jobjectArray JNICALL Java_com_study_jnilearn_ObjectArray_initInt2DArray (JNIEnv *, jobject, jint); #ifdef __cplusplus } #endif #endif // ObjectArray.c #include "com_study_jnilearn_ObjectArray.h" /* * Class: com_study_jnilearn_ObjectArray * Method: initInt2DArray * Signature: (I)[[I */ JNIEXPORT jobjectArray JNICALL Java_com_study_jnilearn_ObjectArray_initInt2DArray (JNIEnv *env, jobject obj, jint size) { jobjectArray result; jclass clsIntArray; jint i,j; // 1.获得一个int型二维数组类的引用 clsIntArray = (*env)->FindClass(env,"[I"); //"[I" JNI class descript if (clsIntArray == NULL) { return NULL; } // 2.创建一个数组对象（里面每个元素用clsIntArray表示） // 说明： 函数NewObjectArray只能分配第一维，JVM没有与多维数组相对应的数据结构，JNI也没有提供类似的函数来创建二维数组 result = (*env)->NewObjectArray(env,size,clsIntArray,NULL); if (result == NULL) { return NULL; } // 3.为数组元素赋值 for (i = 0; i &lt; size; ++i) { jint buff[256]; jintArray intArr = (*env)->NewIntArray(env,size); if (intArr == NULL) { return NULL; } for (j = 0; j &lt; size; j++) { buff[j] = i + j; } //把buff[]缓冲中的内容复制到新分配的一维数组中 (*env)->SetIntArrayRegion(env,intArr, 0,size,buff); (*env)->SetObjectArrayElement(env,result, i, intArr); //避免在循环内创建大量的JNI局部引用，造成JNI引用表溢出 (*env)->DeleteLocalRef(env,intArr); } return result; } JVM引用 在JNI中，只有jobject以及子类属于引用变量，会占用引用表的空间，jint，jfloat，jboolean等都是基本类型变量，不会占用引用表空间，即不需要释放。引用表最大空间为512个，如果超出这个范围，JVM就会挂掉。 C/C++访问Java实例方法和静态方法实战案例AccessMethod.java package com.study.jnilearn; /** * AccessMethod.java * 本地代码访问类的实例方法和静态方法 * @author yangxin */ public class AccessMethod { public static native void callJavaStaticMethod(); public static native void callJavaInstaceMethod(); public static void main(String[] args) { callJavaStaticMethod(); callJavaInstaceMethod(); } static { System.loadLibrary(&quot;AccessMethod&quot;); } } ClassMethod.java package com.study.jnilearn; /** * ClassMethod.java * 用于本地代码调用 * @author yangxin */ public class ClassMethod { private static void callStaticMethod(String str, int i) { System.out.format(&quot;ClassMethod::callStaticMethod called!--&gt;str=%s,&quot; + &quot; i=%d\n&quot;, str, i); } private void callInstanceMethod(String str, int i) { System.out.format(&quot;ClassMethod::callInstanceMethod called!--&gt;str=%s, &quot; + &quot;i=%d\n&quot;, str, i); } } Jni 源码 // AccessMethod.c #include &quot;com_study_jnilearn_AccessMethod.h&quot; /* * Class: com_study_jnilearn_AccessMethod * Method: callJavaStaticMethod * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaStaticMethod (JNIEnv *env, jclass cls) { jclass clazz = NULL; jstring str_arg = NULL; jmethodID mid_static_method; // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象 clazz =(*env)-&gt;FindClass(env,&quot;com/study/jnilearn/ClassMethod&quot;); if (clazz == NULL) { return; } // 2、从clazz类中查找callStaticMethod方法 mid_static_method = (*env)-&gt;GetStaticMethodID(env,clazz,&quot;callStaticMethod&quot;,&quot;(Ljava/lang/String;I)V&quot;); if (mid_static_method == NULL) { printf(&quot;找不到callStaticMethod这个静态方法。&quot;); return; } // 3、调用clazz类的callStaticMethod静态方法 str_arg = (*env)-&gt;NewStringUTF(env,&quot;我是静态方法&quot;); (*env)-&gt;CallStaticVoidMethod(env,clazz,mid_static_method, str_arg, 100); // 删除局部引用 (*env)-&gt;DeleteLocalRef(env,clazz); (*env)-&gt;DeleteLocalRef(env,str_arg); } /* * Class: com_study_jnilearn_AccessMethod * Method: callJavaInstaceMethod * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod (JNIEnv *env, jclass cls) { jclass clazz = NULL; jobject jobj = NULL; jmethodID mid_construct = NULL; jmethodID mid_instance = NULL; jstring str_arg = NULL; // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象 clazz = (*env)-&gt;FindClass(env, &quot;com/study/jnilearn/ClassMethod&quot;); if (clazz == NULL) { printf(&quot;找不到&#39;com.study.jnilearn.ClassMethod&#39;这个类&quot;); return; } // 2、获取类的默认构造方法ID mid_construct = (*env)-&gt;GetMethodID(env,clazz, &quot;&lt;init&gt;&quot;,&quot;()V&quot;); if (mid_construct == NULL) { printf(&quot;找不到默认的构造方法&quot;); return; } // 3、查找实例方法的ID mid_instance = (*env)-&gt;GetMethodID(env, clazz, &quot;callInstanceMethod&quot;, &quot;(Ljava/lang/String;I)V&quot;); if (mid_instance == NULL) { return; } // 4、创建该类的实例 jobj = (*env)-&gt;NewObject(env,clazz,mid_construct); if (jobj == NULL) { printf(&quot;在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法&quot;); return; } // 5、调用对象的实例方法 str_arg = (*env)-&gt;NewStringUTF(env,&quot;我是实例方法&quot;); (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,200); // 删除局部引用 (*env)-&gt;DeleteLocalRef(env,clazz); (*env)-&gt;DeleteLocalRef(env,jobj); (*env)-&gt;DeleteLocalRef(env,str_arg); } callJavaStaticMethod静态方法实现说明++void (JNICALL CallStaticVoidMethod)(JNIEnv env, jclass cls, jmethodID methodID, …);++ env：JNI函数表指针 cls：调用该静态方法的Class对象 methodID：方法唯一ID … 参数4：方法实参列表 其他方法 CallStaticXXXMethod CallStaticIntMethod、CallStaticFloatMethod、CallStaticShortMethod、CallStaticObjectMethod callInstanceMethod实例方法实现说明++void (JNICALL CallVoidMethod) (JNIEnv env, jobject obj, jmethodID methodID, …);++ env：JNI函数表指针 obj：调用该方法的实例 【于上不同】 methodID：方法唯一ID … 参数4：方法实参列表 相关的函数CallXXXMethod （CallXXXMethod），如：CallIntMethod、CallFloatMethod、CallObjectMethod等 方法签名fadfaf 方法签名的格式 基本类型映射关系 小结 获取构造方法ID，方法名称使用”“ C/C++访问Java实例Field和static Field C/C++代码中可以访问任意Java类中的属性 实战DemoAccessField.java package com.study.jnilearn; /** * C/C++访问类的实例变量和静态变量 * @author yangxin */ public class AccessField { private native static void accessInstanceField(ClassField obj); private native static void accessStaticField(); public static void main(String[] args) { ClassField obj = new ClassField(); obj.setNum(10); obj.setStr("Hello"); // 本地代码访问和修改ClassField为中的静态属性num accessStaticField(); accessInstanceField(obj); // 输出本地代码修改过后的值 System.out.println("In Java--->ClassField.num = " + obj.getNum()); System.out.println("In Java--->ClassField.str = " + obj.getStr()); } static { System.loadLibrary("AccessField"); } } ClassField.java package com.study.jnilearn; /** * ClassField.java * 用于本地代码访问和修改该类的属性 * @author yangxin * */ public class ClassField { private static int num; private String str; public int getNum() { return num; } public void setNum(int num) { ClassField.num = num; } public String getStr() { return str; } public void setStr(String str) { this.str = str; } } Native 代码 // AccessField.c #include "com_study_jnilearn_AccessField.h" /* * Class: com_study_jnilearn_AccessField * Method: accessInstanceField * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessField_accessInstanceField (JNIEnv *env, jclass cls, jobject obj) { jclass clazz; jfieldID fid; jstring j_str; jstring j_newStr; const char *c_str = NULL; // 1.获取AccessField类的Class引用 clazz = (*env)->GetObjectClass(env,obj); if (clazz == NULL) { return; } // 2. 获取AccessField类实例变量str的属性ID fid = (*env)->GetFieldID(env,clazz,"str", "Ljava/lang/String;"); if (clazz == NULL) { return; } // 3. 获取实例变量str的值 j_str = (jstring)(*env)->GetObjectField(env,obj,fid); // 4. 将unicode编码的java字符串转换成C风格字符串 c_str = (*env)->GetStringUTFChars(env,j_str,NULL); if (c_str == NULL) { return; } printf("In C--->ClassField.str = %s\n", c_str); (*env)->ReleaseStringUTFChars(env, j_str, c_str); // 5. 修改实例变量str的值 j_newStr = (*env)->NewStringUTF(env, "This is C String"); if (j_newStr == NULL) { return; } (*env)->SetObjectField(env, obj, fid, j_newStr); // 6.删除局部引用 (*env)->DeleteLocalRef(env, clazz); (*env)->DeleteLocalRef(env, j_str); (*env)->DeleteLocalRef(env, j_newStr); } /* * Class: com_study_jnilearn_AccessField * Method: accessStaticField * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessField_accessStaticField (JNIEnv *env, jclass cls) { jclass clazz; jfieldID fid; jint num; //1.获取ClassField类的Class引用 clazz = (*env)->FindClass(env,"com/study/jnilearn/ClassField"); if (clazz == NULL) { // 错误处理 return; } //2.获取ClassField类静态变量num的属性ID fid = (*env)->GetStaticFieldID(env, clazz, "num", "I"); if (fid == NULL) { return; } // 3.获取静态变量num的值 num = (*env)->GetStaticIntField(env,clazz,fid); printf("In C--->ClassField.num = %d\n", num); // 4.修改静态变量num的值 (*env)->SetStaticIntField(env, clazz, fid, 80); // 删除属部引用 (*env)->DeleteLocalRef(env,clazz); } 访问实例FieldGetXXField GetIntField，GetFloatField，GetDoubleField，GetBooleanField等 jobject (JNICALL *GetObjectField) (JNIEnv *env, jobject obj, jfieldID fieldID); env是JNI函数表指针 obj是实例变量所属的对象 fieldID是变量的ID 类比Java反射 public static void main(String[] args) throws Exception { ClassField obj = new ClassField(); obj.setStr("YangXin"); // 获取ClassField字节码对象的Class引用 Class&lt;?> clazz = obj.getClass(); // 获取str属性 Field field = clazz.getDeclaredField("str"); // 取消权限检查，因为Java语法规定，非public属性是无法在外部访问的 field.setAccessible(true); // 获取obj对象中的str属性的值 String str = (String)field.get(obj); System.out.println("str = " + str); } Jni的步骤 clazz = (*env)-&gt;GetObjectClass(env,obj); fid = (*env)-&gt;GetFieldID(env,clazz,&quot;str&quot;, &quot;Ljava/lang/String;&quot;); j_str = (jstring)(*env)-&gt;GetObjectField(env,obj,fid); //修改实例属性的值为j_newStr (*env)-&gt;SetObjectField(env, obj, fid, j_newStr); ++SetObjectField++ 类似的有SetIntField、SetDoubleField、SetBooleanField等 访问静态变量// 3.获取静态变量num的值 num = (*env)-&gt;GetStaticIntField(env,clazz,fid); // 4.修改静态变量num的值 (*env)-&gt;SetStaticIntField(env, clazz, fid, 80); 调用构造方法和父类实例方法实例Java代码 // Animal.java package com.study.jnilearn; public class Animal { protected String name; public Animal(String name) { this.name = name; System.out.println(&quot;Animal Construct call...&quot;); } public String getName() { System.out.println(&quot;Animal.getName Call...&quot;); return this.name; } public void run() { System.out.println(&quot;Animal.run...&quot;); } } // Cat.java package com.study.jnilearn; public class Cat extends Animal { public Cat(String name) { super(name); System.out.println(&quot;Cat Construct call....&quot;); } @Override public String getName() { return &quot;My name is &quot; + this.name; } @Override public void run() { System.out.println(name + &quot; Cat.run...&quot;); } } // AccessSuperMethod.java package com.study.jnilearn; public class AccessSuperMethod { public native static void callSuperInstanceMethod(); public static void main(String[] args) { callSuperInstanceMethod(); } static { System.loadLibrary(&quot;AccessSuperMethod&quot;); } } AccessSuperMethod.c // AccessSuperMethod.c #include "com_study_jnilearn_AccessSuperMethod.h" JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessSuperMethod_callSuperInstanceMethod (JNIEnv *env, jclass cls) { jclass cls_cat; jclass cls_animal; jmethodID mid_cat_init; jmethodID mid_run; jmethodID mid_getName; jstring c_str_name; jobject obj_cat; const char *name = NULL; // 1、获取Cat类的class引用 cls_cat = (*env)->FindClass(env, "com/study/jnilearn/Cat"); if (cls_cat == NULL) { return; } // 2、获取Cat的构造方法ID(构造方法的名统一为：&lt;init>) mid_cat_init = (*env)->GetMethodID(env, cls_cat, "&lt;init>", "(Ljava/lang/String;)V"); if (mid_cat_init == NULL) { return; // 没有找到只有一个参数为String的构造方法 } // 3、创建一个String对象，作为构造方法的参数 c_str_name = (*env)->NewStringUTF(env, "汤姆猫"); if (c_str_name == NULL) { return; // 创建字符串失败（内存不够） } // 4、创建Cat对象的实例(调用对象的构造方法并初始化对象) obj_cat = (*env)->NewObject(env,cls_cat, mid_cat_init,c_str_name); if (obj_cat == NULL) { return; } //-------------- 5、调用Cat父类Animal的run和getName方法 -------------- cls_animal = (*env)->FindClass(env, "com/study/jnilearn/Animal"); if (cls_animal == NULL) { return; } // 例1： 调用父类的run方法 mid_run = (*env)->GetMethodID(env, cls_animal, "run", "()V"); // 获取父类Animal中run方法的id if (mid_run == NULL) { return; } // 注意：obj_cat是Cat的实例，cls_animal是Animal的Class引用，mid_run是Animal类中的方法ID (*env)->CallNonvirtualVoidMethod(env, obj_cat, cls_animal, mid_run); // 例2：调用父类的getName方法 // 获取父类Animal中getName方法的id mid_getName = (*env)->GetMethodID(env, cls_animal, "getName", "()Ljava/lang/String;"); if (mid_getName == NULL) { return; } c_str_name = (*env)->CallNonvirtualObjectMethod(env, obj_cat, cls_animal, mid_getName); name = (*env)->GetStringUTFChars(env, c_str_name, NULL); printf("In C: Animal Name is %s\n", name); // 释放从java层获取到的字符串所分配的内存 (*env)->ReleaseStringUTFChars(env, c_str_name, name); quit: // 删除局部引用（jobject或jobject的子类才属于引用变量），允许VM释放被局部变量所引用的资源 (*env)->DeleteLocalRef(env, cls_cat); (*env)->DeleteLocalRef(env, cls_animal); (*env)->DeleteLocalRef(env, c_str_name); (*env)->DeleteLocalRef(env, obj_cat); } JNI调用性能测试及优化性能测试的结论 空方法调用，JNI的性能就要比Java内部调用慢将近5倍 查找class和ID(属性和方法ID)消耗的时间比较大-&gt;如果每次都根据名称查找class和field的话，性能要下降高达40倍，反复调用甚至能到达百万级别 消耗时间最多的就是查找class native里保存class和member id是很有必要的 class和member id在一定范围内是稳定的，但在动态加载的class loader下，保存全局的class要么可能失效使用时缓存示例：AccessCache.java`javapackage com.study.jnilearn; public class AccessCache { private String str = &quot;Hello&quot;; public native void accessField(); // 访问str成员变量 public native String newString(char[] chars, int len); // 根据字符数组和指定长度创建String对象 public static void main(String[] args) { AccessCache accessCache = new AccessCache(); accessCache.nativeMethod(); char chars[] = new char[7]; chars[0] = &#39;中&#39;; chars[1] = &#39;华&#39;; chars[2] = &#39;人&#39;; chars[3] = &#39;民&#39;; chars[4] = &#39;共&#39;; chars[5] = &#39;和&#39;; chars[6] = &#39;国&#39;; String str = accessCache.newString(chars, 6); System.out.println(str); } static { System.loadLibrary(&quot;AccessCache&quot;); } } ++AccessCache.c++ ```c // AccessCache.c #include &quot;com_study_jnilearn_AccessCache.h&quot; JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessCache_accessField (JNIEnv *env, jobject obj) { // 第一次访问时将字段存到内存数据区，直到程序结束才会释放，可以起到缓存的作用 static jfieldID fid_str = NULL; jclass cls_AccessCache; jstring j_str; const char *c_str; cls_AccessCache = (*env)-&gt;GetObjectClass(env, obj); // 获取该对象的Class引用 if (cls_AccessCache == NULL) { return; } // 先判断字段ID之前是否已经缓存过，如果已经缓存过则不进行查找 if (fid_str == NULL) { fid_str = (*env)-&gt;GetFieldID(env,cls_AccessCache,&quot;str&quot;,&quot;Ljava/lang/String;&quot;); // 再次判断是否找到该类的str字段 if (fid_str == NULL) { return; } } j_str = (*env)-&gt;GetObjectField(env, obj, fid_str); // 获取字段的值 c_str = (*env)-&gt;GetStringUTFChars(env, j_str, NULL); if (c_str == NULL) { return; // 内存不够 } printf(&quot;In C:\n str = \&quot;%s\&quot;\n&quot;, c_str); (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str); // 释放从从JVM新分配字符串的内存空间 // 修改字段的值 j_str = (*env)-&gt;NewStringUTF(env, &quot;12345&quot;); if (j_str == NULL) { return; } (*env)-&gt;SetObjectField(env, obj, fid_str, j_str); // 释放本地引用 (*env)-&gt;DeleteLocalRef(env,cls_AccessCache); (*env)-&gt;DeleteLocalRef(env,j_str); } JNIEXPORT jstring JNICALL Java_com_study_jnilearn_AccessCache_newString (JNIEnv *env, jobject obj, jcharArray j_char_arr, jint len) { jcharArray elemArray; jchar *chars = NULL; jstring j_str = NULL; static jclass cls_string = NULL; static jmethodID cid_string = NULL; // 注意：这里缓存局引用的做法是错误，这里做为一个反面教材提醒大家，下面会说到。 if (cls_string == NULL) { cls_string = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); if (cls_string == NULL) { return NULL; } } // 缓存String的构造方法ID if (cid_string == NULL) { cid_string = (*env)-&gt;GetMethodID(env, cls_string, &quot;&lt;init&gt;&quot;, &quot;([C)V&quot;); if (cid_string == NULL) { return NULL; } } printf(&quot;In C array Len: %d\n&quot;, len); // 创建一个字符数组 elemArray = (*env)-&gt;NewCharArray(env, len); if (elemArray == NULL) { return NULL; } // 获取数组的指针引用，注意：不能直接将jcharArray作为SetCharArrayRegion函数最后一个参数 chars = (*env)-&gt;GetCharArrayElements(env, j_char_arr,NULL); if (chars == NULL) { return NULL; } // 将Java字符数组中的内容复制指定长度到新的字符数组中 (*env)-&gt;SetCharArrayRegion(env, elemArray, 0, len, chars); // 调用String对象的构造方法，创建一个指定字符数组为内容的String对象 j_str = (*env)-&gt;NewObject(env, cls_string, cid_string, elemArray); // 释放本地引用 (*env)-&gt;DeleteLocalRef(env, elemArray); return j_str; } 类静态初始化缓存示例：AccessCache.java public class AccessCache { public static native void initIDs(); public native void nativeMethod(); public void callback() { System.out.println("AccessCache.callback invoked!"); } public static void main(String[] args) { AccessCache accessCache = new AccessCache(); accessCache.nativeMethod(); } static { System.loadLibrary("AccessCache"); initIDs(); } } ++AccessCache.c++ #include "com_study_jnilearn_AccessCache.h" jmethodID MID_AccessCache_callback; JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessCache_initIDs (JNIEnv *env, jclass cls) { printf("initIDs called!!!\n"); MID_AccessCache_callback = (*env)->GetMethodID(env,cls,"callback","()V"); } JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessCache_nativeMethod (JNIEnv *env, jobject obj) { printf("In C Java_com_study_jnilearn_AccessCache_nativeMethod called!!!\n"); (*env)->CallVoidMethod(env, obj, MID_AccessCache_callback); } 两种缓存方式比较使用时缓存缺点 每次都需要检查是否已经缓存该ID或Class引用 只要本地代码依赖于这个ID的值，那么这个类就不会被unload。 如果缓存发生在静态初始化时，当类被unload或reload时，ID会被重新计 JNI局部引用、全局引用和弱全局引用异常案例：Android JNI局部引用表溢出：local reference table overflow (max=512)Java 调用 // 返回count个sample相同的字符串数组，并用编号标识，如：sample1，sample2... public native String[] getStrings(int count, String sample); local_ref_overflow_test.c #include &lt;jni.h> #include &lt;stdlib.h> #include &lt;stdio.h> #include &lt;string.h> #include &lt;android/log.h> #define LOG_TAG "MainActivity" #define LOG_I(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG, __VA_ARGS__) #define LOG_E(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__) #ifdef __cplusplus extern "C" { #endif jobjectArray getStrings(JNIEnv *env, jobject obj, jint count, jstring sample) { jobjectArray str_array = NULL; jclass cls_string = NULL; jmethodID mid_string_init; jobject obj_str = NULL; const char *c_str_sample = NULL; char buff[256]; int i; // 保证至少可以创建3个局部引用（str_array，cls_string，obj_str） if ((*env)->EnsureLocalCapacity(env, 3) != JNI_OK) { return NULL; } c_str_sample = (*env)->GetStringUTFChars(env, sample, NULL); if (c_str_sample == NULL) { return NULL; } cls_string = (*env)->FindClass(env, "java/lang/String"); if (cls_string == NULL) { return NULL; } // 获取String的构造方法 mid_string_init = (*env)->GetMethodID(env, cls_string, "&lt;init>", "()V"); if (mid_string_init == NULL) { (*env)->DeleteLocalRef(env,cls_string); return NULL; } obj_str = (*env)->NewObject(env, cls_string, mid_string_init); if (obj_str == NULL) { (*env)->DeleteLocalRef(env,cls_string); return NULL; } // 创建一个字符串数组 str_array = (*env)->NewObjectArray(env, count, cls_string, obj_str); if (str_array == NULL) { (*env)->DeleteLocalRef(env,cls_string); (*env)->DeleteLocalRef(env,obj_str); return NULL; } // 给数组中每个元素赋值 for (i = 0; i &lt; count; ++i) { memset(buff, 0, sizeof(buff)); // 初始一下缓冲区 sprintf(buff, c_str_sample,i); jstring newStr = (*env)->NewStringUTF(env, buff); (*env)->SetObjectArrayElement(env, str_array, i, newStr); (*env)->DeleteLocalRef(env,newStr); // Warning: 这里如果不手动释放局部引用，很有可能造成局部引用表溢出 } // 释放模板字符串所占的内存 (*env)->ReleaseStringUTFChars(env, sample, c_str_sample); // 释放局部引用所占用的资源 (*env)->DeleteLocalRef(env, cls_string); (*env)->DeleteLocalRef(env, obj_str); return str_array; } const JNINativeMethod g_methods[] = { {"getStrings", "(ILjava/lang/String;)[Ljava/lang/String;", (void*)getStrings} }; static jclass g_cls_MainActivity = NULL; JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { LOG_I("JNI_OnLoad method call begin"); JNIEnv* env = NULL; jclass cls = NULL; if((*vm)->GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } // 查找要加载的本地方法Class引用 cls = (*env)->FindClass(env, "com/example/jni/MainActivity"); if(cls == NULL) { return JNI_ERR; } // 将class的引用缓存到全局变量中 g_cls_MainActivity = (*env)->NewWeakGlobalRef(env, cls); (*env)->DeleteLocalRef(env, cls); // 手动删除局部引用是个好习惯 // 将java中的native方法与本地函数绑定 (*env)->RegisterNatives(env, g_cls_MainActivity, g_methods, sizeof(g_methods) / sizeof(g_methods[0])); LOG_I("JNI_OnLoad method call end"); return JNI_VERSION_1_6; } JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved) { LOG_I("JNI_OnUnload method call begin"); JNIEnv *env = NULL; if((*vm)->GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_6) != JNI_OK) { return; } (*env)->UnregisterNatives(env, g_cls_MainActivity); // so被卸载的时候解除注册 (*env)->DeleteWeakGlobalRef(env, g_cls_MainActivity); } #ifdef __cplusplus } #endif 三种引用简介及区别局部引用（Local Reference） 创建: NewLocalRef 或JNI接口创建（FindClass、NewObject、GetObjectClass和NewCharArray等） 特性： 会阻止GC回收所引用的对象 不在本地函数中跨函数使用 不能跨线程使用 释放 函数返回后局部引用所引用的对象会被JVM自动释放 调用DeleteLocalRef(*env)-&gt;DeleteLocalRef(env,local_ref)jclass cls_string = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); jcharArray charArr = (*env)-&gt;NewCharArray(env, len); jstring str_obj = (*env)-&gt;NewObject(env, cls_string, cid_string, elemArray); // 通过NewLocalRef函数创建 jstring str_obj_local_ref = (*env)-&gt;NewLocalRef(env,str_obj); .... 全局引用（Global Reference） 创建： NewGlobalRef 特性： 会阻GC回收所引用的对象基于局部引用创建 可以跨方法、跨线程使用 VM不会自动释放，必须调用DeleteGlobalRef手动释放(*env)-&gt;DeleteGlobalRef(env,g_cls_string)弱全局引用（Weak Global Reference） 创建： NewWeakGlobalRef基于局部引用或全局引用创建 特性： 不会阻止GC回收所引用的对象 可以跨方法、跨线程使用 释放： 1.比如内存紧张的时候；2. 调用DeleteWeakGlobalRef手动释放(*env)-&gt;DeleteWeakGlobalRef(env,g_cls_string)static jclass g_cls_string; void TestFunc(JNIEnv* env, jobject obj) { jclass cls_string = (*env)->FindClass(env, "java/lang/String"); g_cls_string = (*env)->NewWeakGlobalRef(env,cls_string); } 局部引用误区一: 用static变量缓存局部变量（变动），造成野指针； 本地方法返回到Java层之后，如果Java层没有对返回的局部引用使用的话，局部引用就会被JVM自动释放 误区二：局部引用不用释放 Android上的JNI局部引用表最大数量是512个，一些局部引用循环可能溢出for (i = 0; i < len; i++) { jstring jstr = (*env)->GetObjectArrayElement(env, arr, i); ... /* 使用jstr */ (*env)->DeleteLocalRef(env, jstr); // 使用完成之后马上释放 } 调用JNI工具函数时，返回的引用需要手动释放 局部引用占用大资源，但是函数不能立即结束时，如：占用资源后有大量的运算；JNIEXPORT void JNICALL Java_pkg_Cls_func(JNIEnv *env, jobject this) { lref = ... /* lref引用的是一个大的Java对象 */ ... /* 在这里已经处理完业务逻辑后，这个对象已经使用完了 */ (*env)-&gt;DeleteLocalRef(env, lref); /* 及时删除这个对这个大对象的引用，GC就可以对它回收，并释放相应的资源*/ lengthyComputation(); /* 在里有个比较耗时的计算过程 */ return; /* 计算完成之后，函数返回之前所有引用都已经释放 */ } 管理局部引用 JNI提供的引用的生命周期管理EnsureLocalCapacity、NewLocalRef、PushLocalFrame、PopLocalFrame、DeleteLocalRef。 JNI函数默认只支持16个局部引用，可以调用EnsureLocalCapacity增加局部引用数量，如果创建成功则返回0，否则创建失败，并抛出OutOfMemoryError异常；/*处理函数逻辑时，确保函数能创建len个局部引用*/ if((*env)-&gt;EnsureLocalCapacity(env,len) != 0) { ... /*申请len个局部引用的内存空间失败 OutOfMemoryError*/ return; } for(i=0; i &lt; len; i++) { jstring jstr = (*env)-&gt;GetObjectArrayElement(env, arr, i); // ... 使用jstr字符串 /*这里没有删除在for中临时创建的局部引用*/ } Push/PopLocalFrame引用堆栈#define N_REFS ... /*最大局部引用数量*/ for (i = 0; i &lt; len; i++) { if ((*env)-&gt;PushLocalFrame(env, N_REFS) != 0) { ... /*内存溢出*/ } jstring jstr = (*env)-&gt;GetObjectArrayElement(env, arr, i); ... /* 使用jstr */ (*env)-&gt;PopLocalFrame(env, NULL); } 全局引用++案例++ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_AccessCache_newString (JNIEnv *env, jobject obj, jcharArray j_char_arr, jint len) { // ... jstring jstr = NULL; static jclass cls_string = NULL; if (cls_string == NULL) { jclass local_cls_string = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); if (cls_string == NULL) { return NULL; } // 将java.lang.String类的Class引用缓存到全局引用当中 cls_string = (*env)-&gt;NewGlobalRef(env, local_cls_string); // 删除局部引用 (*env)-&gt;DeleteLocalRef(env, local_cls_string); // 再次验证全局引用是否创建成功 if (cls_string == NULL) { return NULL; } } // .... return jstr; } 弱全局引用与全局引用很重要不同的一点是，弱引用不会阻止GC回收它引用的对象 如果不手动调用这个函数来释放所指向的对象，JVM仍会回收弱引用所指向的对象，但弱引用本身在引用表中所占的内存永远也不会被回收。 ++案例：++ JNIEXPORT void JNICALL Java_mypkg_MyCls_f(JNIEnv *env, jobject self) { static jclass myCls2 = NULL; if (myCls2 == NULL) { jclass myCls2Local = (*env)-&gt;FindClass(env, &quot;mypkg/MyCls2&quot;); if (myCls2Local == NULL) { return; /* 没有找到mypkg/MyCls2这个类 */ } myCls2 = NewWeakGlobalRef(env, myCls2Local); if (myCls2 == NULL) { return; /* 内存溢出 */ } } ... /* 使用myCls2的引用 */ } 引用比较jboolean isEqual = (*env)-&gt;IsSameObject(env, obj1, obj2) obj1,obj2: 不管是全局、局部还是弱全局引用 isEqual JNI_TRUE（或者1）相同，JNI_FALSE（或者0） JNI中的NULL引用指向JVM中的null对象 局部或全局引用-&gt; (*env)-&gt;IsSameObject(env, obj, NULL) 或者 obj == NUL判断 弱全局引用 (*env)-&gt;IsSameObject(env, g_obj_ref, NULL) -&gt; 引用中是否仍然指向活动对象jobject local_obj_ref = (*env)-&gt;NewObject(env, xxx_cls,xxx_mid); jobject g_obj_ref = (*env)-&gt;NewWeakGlobalRef(env, local_ref); // ... 业务逻辑处理 jboolean isEqual = (*env)-&gt;IsSameObject(env, g_obj_ref, NULL); 小Tip基于全局引用创建一个局引用返回，也同样会阻止GC回收所引用的这个对象Push/PopLocalFrame是非常方便且安全的【建议使用】jobject f(JNIEnv *env, ...) { jobject result; if ((*env)->PushLocalFrame(env, 10) &lt; 0) { /* 调用PushLocalFrame获取10个局部引用失败，不需要调用PopLocalFrame */ return NULL; } ... result = ...; // 创建局部引用result if (...) { /* 返回前先弹出栈顶的frame */ result = (*env)->PopLocalFrame(env, result); return result; } ... result = (*env)->PopLocalFrame(env, result); /* 正常返回 */ return result; } JNI异常处理JNI 异常函数列表 异常函数 相关描述 ExceptionCheck 检查是否发生了异常，若有异常返回JNI_TRUE，否则返回JNI_FALSE ExceptionOccurred 检查是否发生了异常，若用异常返回该异常的引用，否则返回NULL ExceptionDescribe 打印异常的堆栈信息 ExceptionClear 清除异常堆栈信息 ThrowNew 在当前线程触发一个异常，并自定义输出异常信息 Throw 丢弃一个现有的异常对象，在当前线程触发一个新的异常 FatalError 致命异常，用于输出一个异常信息，并终止当前VM实例（即退出程序） void (JNICALL FatalError) (JNIEnv env, const char msg);jint (JNICALL ThrowNew) (JNIEnv env, jclass clazz, const char msg);jint (JNICALL Throw) (JNIEnv env, jthrowable obj); 异常处理示例public class JNIException { public static native void doit(); public static void exceptionCallback() { int a = 20 / 0; System.out.println("--->" + a); } public static void normalCallback() { System.out.println("In Java: invoke normalCallback."); } public static void main(String[] args) { doit(); } static { System.loadLibrary("JNIException"); } } ++JNIException.c++ #include "com_study_jnilearn_JNIException.h" #include &lt;stdio.h> JNIEXPORT void JNICALL Java_com_study_jnilearn_JNIException_doit(JNIEnv *env, jclass cls) { jthrowable exc = NULL; jmethodID mid = (*env)->GetStaticMethodID(env,cls,"exceptionCallback","()V"); if (mid != NULL) { (*env)->CallStaticVoidMethod(env,cls,mid); } printf("In C: Java_com_study_jnilearn_JNIException_doit-->called!!!!"); if ((*env)->ExceptionCheck(env)) { // 检查JNI调用是否有引发异常 (*env)->ExceptionDescribe(env); (*env)->ExceptionClear(env); // 清除引发的异常，在Java层不会打印异常的堆栈信息 (*env)->ThrowNew(env,(*env)->FindClass(env,"java/lang/Exception"),"JNI抛出的异常！"); //return; } //如果不return 程序继续执行 mid = (*env)->GetStaticMethodID(env,cls,"normalCallback","()V"); if (mid != NULL) { (*env)->CallStaticVoidMethod(env,cls,mid); } } ++JNIException.c++ ExceptionOccurred 改造,作用和ExceptionCheck一样，两者的区别在于返回值不一样 // .... jthrowable exc = NULL; exc = (*env)->ExceptionOccurred(env); // 返回一个指向当前异常对象的引用 if (exc) { (*env)->ExceptionDescribe(env); // 打印Java层抛出的异常堆栈信息 (*env)->ExceptionClear(env); //清除异常信息 // 抛出我们自己的异常处理 jclass newExcCls; newExcCls = (*env)->FindClass(env,"java/lang/Exception"); if (newExcCls == NULL) { return; } (*env)->ThrowNew(env, newExcCls, "throw from C Code."); /* 注意释放局部引用 */ (*env)->DeleteLocalRef(env, newExcCls); /*异常发生后释放资源*/ } // .... 异常发生后释放资源JNIEXPORT void JNICALL Java_pkg_Cls_f(JNIEnv *env, jclass cls, jstring jstr) { const jchar *cstr = (*env)->GetStringChars(env, jstr); if (c_str == NULL) { return; } ... if ((*env)->ExceptionCheck(env)) { /* 异常检查 */ (*env)->ReleaseStringChars(env, jstr, cstr); // 发生异常后释放前面所分配的内存 return; } ... /* 正常返回 */ (*env)->ReleaseStringChars(env, jstr, cstr); } 参考 JNI/NDK开发指南（开山篇） 推荐《Pro Android C++ with the NDK》，中文版名称《Android C++高级编程 使用NDK》]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化Android App]]></title>
    <url>%2F2018%2F08%2F07%2F2018-4-14-android-optimization%2F</url>
    <content type="text"><![CDATA[学习资源博文 Background Optimizations Facebook是如何收集其Android应用性能数据的 安卓性能优化收集网站 总结性 Android客户端性能优化（魅族资深工程师毫无保留奉献） Java Performance blog 性能分析的网站 NimbleDroid 一个 Android 应用性能分析服务网站 PageSpeed Insights 能够测试网页在移动设备和桌面设备上的性能工具 APM(Application performance magic) : 应用程序性能管理 2011年时国外的APM行业 NewRelic 和 APPDynamics 国内：听云， OneAPM， 博睿(bonree) 云智慧，阿里百川码力 针对性优化图片压缩Apk体积缩小 Luban 可能是最接近微信朋友圈的图片压缩算法 Shrink Your Code and Resources 【官方教程，未看】 Android微信上的SVG PNG图片压缩对比分析 通过三次优化，我将gif加载优化了16.9% EFFICIENTLY REDUCING YOUR METHOD COUNT APK瘦身实践 突破App启动时间的极限 an Intelij Plugin for image compress using TinyPNG API Android 图片压缩工具 网络优化 Offline App Archit ecture: how to build for the next billion DevBytes: Efficient Data Transfers — YouTube Google Engineer Serials tutorial ORG Optimizing Downloads for Efficient Network Access 美团点评移动网络优化实践 内存优化 Android内存优化杂谈 Android 内存优化总结&amp;实践 速度优化 Android启动速度优化 everbook has backup, Application.registerActivityLifecycleCallbacks的运用 给 App 提速：Android 性能优化总结 优化实践 内存泄漏 Memory Analyzer（MAT） Tool Leak Suspects：内存泄露报告 Top Components：吃货报告 Histogram：每个Class占用内存 Dominator Tree：列出哪些对象占用内存最多以及谁hold住这些对象 OQL (Ctrl + F5 run) select * from instanceof android.app.Activity Mat tutorial: 1） 使用Memory Analyzer tool(MAT)分析内存泄漏2） Video youtube Google I/O 2011: Memory management for Android Apps3） MAT - Memory Analyzer Tool 使用进阶4） 从MAT数据中还原Bitmap原图Docuemnt1) eclipse.org document MemoryAnalyzer2) developer.android investigating your RAM usageBlog adb 使用 检查应用退出后Activities/Views 是否为零;adb shell dumpsys meminfo [应用包名] 多次进入退出后的占用内存TOTAL不应变化太大； onTrimMemory回调 响应此回调释放非必须内存； 验证adb shell dumpsys gfxinfo 【应用包名】-cmd trim 5adb shell dumpsys meminfo 【应用包名】查看内存大小 UI卡顿和稳定性 工作线程优先级设置为Process.THREAD_PRIORITY_BACKGROUND 卡顿常见原因1）人为在UI线程中做轻微耗时操作，导致UI线程卡顿；2） 布局Layout过于复杂，无法在16ms内完成渲染；3）同一时间动画执行的次数过多，导致CPU或GPU负载过重；4） View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；5） View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；6）内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；7） 冗余资源及逻辑等导致加载和执行缓慢；8）工作线程优先级未设置为Process.THREAD_PRIORITY_BACKGROUND导致后台线程抢占UI线程cpu时间片，阻塞渲染操作；9） ANR；卡顿分析解决的一般步骤 解决过度绘制问题1) 调试GPU过度绘制中打开调试，看对应界面是否有过度绘制，如果有先解决掉：2) 定位过渡绘制区域3) 利用Android提供的工具进行位置确认以及修改(HierarchyView , Tracer for OpenGL ES)4) 定位到具体的视图(xml文件或者View)5) 通过代码和xml文件分析过渡绘制的原因6) 结合具体情况进行优化7) 使用Lint工具进一步优化 检查是否有主线程做了耗时操作：1) Application 开启 StrictMode;public void onCreate() { if (DEVELOPER_MODE) { StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectAll() .penaltyLog() .build()); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectAll() .penaltyLog() .build()); } super.onCreate(); } 如果主线程无耗时操作，还存在卡顿，有很大可能是必须在UI线程操作的一些逻辑有问题，比如控件measure、layout耗时过多等，此时可通过Traceview以及systrace来进行分析。 Traceview：Traceview主要用做热点分析，找出最需要优化的点。 systrace：抓取trace： 使用hugo打印方法调用的时长及参数 Method Tracing 优化启动时间官网：Generate trace logs by instrumenting your appJava 代码android.os.Debug.startMethodTracing() 和 stopMethodTracing() # 启动HomePageActivity并每1s跟踪方法调用 adb shell am start -n com.runan.countprisoner/.view.activity.HomePageActivity --start-profiler /data/local/tmp/startup.trace --sampling 1000 终止跟踪 adb shell am profile stop # 拉取 .trace 文件到本机当前目录 adb pull /data/local/tmp/startup.trace . Android Studio -&gt; File -&gt; open 直接打开*.trace Glide Gif 性能优化 编译使用Android源码中的GIF图片工具包–framesequence 官方工具 Android Monitor Allocation Tracker Device Monitor Viewing Overall Memory Allocations 参考 Investigating Your RAM Usage adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d] 【难点】 对meminfo 的解读 Dalvik/ART Log Messages 【难点】解读 Testing Display Performance 十分详细的关于显示优化的介绍。 第三方工具 由腾讯出品的GT（随身调），直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug Environment)，支持iOS和Android两个手机平台,主要功能可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。还提高基础API进行开发。 LeakCanary yourkit Java Profiler, and square/leakcanary recommend to use memory leak analyzer like mat FlatBuffers：性能最高的序列化库，由 Google 游戏开发小组专为性能而设计 Parcelable API：Android 进程间传递数据，性能远优于 Java 默认序列化机制 BlockCanaryEx 加速你的Android应用 保险套项目 Note : 『保险套』是一个超轻超薄的Android工具库，将它套在Android应用工程里裸露的Context上，再传入第三方SDK（通常是其初始化方法），即可防止三方SDK损害用户体验 常用小Tips SparseArray ——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。 查看Activity启动时间adb shell am start -W com.niuwa/.activity.HomePageActivity 参考： http://blog.tingyun.com/web/article/detail/155 Android P 电量管理 Android vitals]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程控制笔记整理]]></title>
    <url>%2F2018%2F08%2F07%2F2018-8-7-remote-control%2F</url>
    <content type="text"><![CDATA[视频流播放相关相关开源库 FFmpeg Libstreaming A solution for streaming H.264, H.263, AMR, AAC using RTP on Android RemoteDroid 能运行但是链接失败 android-eye Gstreamer-Android-example EasyDarwin 高性能开源流媒体服务器，支持RTSP、HLS、HTTP直播 ————– 官网 spydroid-ipcamera A powerful and funny android app. that streams the camera and microphone of your phone to your browser or to VLC libstreaming libstreaming-examples Google开源播放器 ExoPlayer 教程 最简单的基于FFmpeg的移动端例子：Android 视频转码器 Android本地视频播放器开发–ffmpeg解码视频文件中的音频(1) java 调用 ffmpeg 进行视频转换以及截图 FFmpeg 抽取视频中的一段(视频转换) [总结]FFMPEG视音频编解码零基础学习方法 重点 GStreamer SDK Tutorials 手机Android音视频采集与直播推送，实现单兵、移动监控类应用 实践笔记积累 Wowza Streaming Engine sudo service WowzaStreamingEngine start sudo service WowzaStreamingEngineManager start 访问 http://[wowza-ip-address]:8088/enginemanager http://localhost:8088/enginemanager/#home/_defaultVHost_ 视频发布账号和密码：/usr/local/WowzaStreamingEngine/conf/publish.password 网络相关学习 Socket.io资源列举 Get Started: Chat application （基于Node.js html）炒鸡简单的例子，无需编程经验 github github.com/socket.io socket.io-android-chat engine.io-client-java Engine.IO Client Library for Java JavaApidocs socket.io-redis libjitsi Advanced Java media library for secure real-time audio/video communication. 基础知识 网络大爬虫 SSL/TLS协议运行机制的概述 SOCKET通信中TCP、UDP数据包大小的确定 关于网络编程中MTU、TCP、UDP优化配置的一些总结 Blog Introducing Socket.IO 1.0 socket-io-p2p 试验UDP打洞穿透NAT Interactive Connectivity Establishment (ICE) ice4j code .google ice4j 资源交老 https://github.com/jitsi/ice4j 比较新的资源 ice4j Javadoc rfc5245.pdf jain-sip jain-sdp 获取Sdp源码 restcomm-android-sdk Tutorial https://telestax.com/jain-sip-stack-for-android/ libnice libnice-4-android Api documentation Englis PDF Material rfc4566 SDP: Session Description Protocol rfc5928 Traversal Using Relays around NAT (TURN) Resolution Mechanism rfc5766.pdf Traversal Using Relays around NAT (TURN):Relay Extensions to Session Traversal Utilities for NAT (STUN) rfc5245 Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols UDP打洞 QQ通信原理及QQ是怎么穿透内网进行通信的 P2P技术揭秘-P2P网络技术原理与典型系统开发 教程下载 webrtc turnserverdownloadsImportant directory:/usr/local/share/examples/turnserverhttp://66.228.45.110/ 免费申请 账号的网站比较详细的turnserver.conf配置说明 Node.jsLearning resource http://nodeschool.io/#workshoppers openSource node-express-mongoose-demo Module http://samhuri.net/projects/strftime Tutorial Node.js Tutorial – Step-by-Step Guide For Getting Started Tool npm install -g node-inspector # basically `node-debug` instead of `node` $ node-debug example.js https://developers.google.com/web/tools/setup/ 数据传输数据转码 Convert bitmap array to YUV (YCbCr NV21) Appending a byte[] to the end of another byte[] Android 用MediaCodec实现视频硬解码 MediaCodec Api) 数据校验 传输数据校验算法研究 WebRTC Introduction to WebRTC on Android Android IOS WebRTC 音视频开发总结列表 https://webrtc.org/ Getting Started with WebRTC WebRTC samples 有各种Sample代码Html/js演示，并有对应Github源 码地址， 整个工程的samples Native APIs Diagram AndroidRTC 相关博文 WebRTC VideoEngine综合应用示例（一）——视频通话的基本流程 参考文章 控制相关 Android模拟产生事件 概括分析了模拟事件的三种方式，而且文章格式很喜欢 Input Technical Information Android Source 关于android devices input 的说明，偏底层 ； getevent/sendevent及 input 命令的详解 截屏相关 Android中使用代码截图的各种方法总结 视频相关 FFmpeg深入分析之零-基础 FFmpeg的Android平台移植—编译篇 Android中实时视频传输(摄像头实时视频传输)解决方案&lt;二&gt; android视频录制、另一部手机实时观看方案 重点 android视频处理相关资料 重点 资料http://www.ffmpeg.org/ffmpeg.htmlEzStreamSvr 一个流媒体传输服务器端GStreamer open source multimedia framework]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程中好用工具]]></title>
    <url>%2F2018%2F08%2F03%2F2018-8-3-coder-software%2F</url>
    <content type="text"><![CDATA[记录 terminalizer 录制终端命令行并转化成gif 画图工具 whimsical UI做得一流的流程图软件 【五星推荐】 位置工具 百度地址转经纬度]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio用Cmake方式编译NDK代码]]></title>
    <url>%2F2018%2F08%2F01%2F2018-8-1-cmake-note%2F</url>
    <content type="text"><![CDATA[基础知识1.cmake是什么？ CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。 谷歌从AndroidStudio2.2以上就添加了Cmake方式来编译NDK代码，并从NDK例子看出，默认编译的方式就是cmake方式。 创建Android studio ndk工程傻瓜式操作 新建一个工程点击如下：然后把C/Cpp代码复制到src/main/cpp下，配置 CMakeLists.txt 手动配置 在src/main下新建jni或者cpp目录， 新建CMakeLists.txt,推荐目录/src/main/jni/CMakeLists.txt, 如下为默认生成的格式： # For more information about using CMake with Android Studio, read the # documentation: https://d.android.com/studio/projects/add-native-code.html # Sets the minimum version of CMake required to build the native library. cmake_minimum_required(VERSION 3.4.1) # Creates and names a library, sets it as either STATIC # or SHARED, and provides the relative paths to its source code. # You can define multiple libraries, and CMake builds them for you. # Gradle automatically packages shared libraries with your APK. add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp ) # Searches for a specified prebuilt library and stores the path as a # variable. Because CMake includes system libraries in the search path by # default, you only need to specify the name of the public NDK library # you want to add. CMake verifies that the library exists before # completing its build. find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log ) # Specifies libraries CMake should link to your target library. You # can link multiple libraries, such as libraries you define in this # build script, prebuilt third-party libraries, or system libraries. target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. ${log-lib} ) 并在build.gradle下关联CMakeLists.txtexternalNativeBuild { cmake { //默认和build.gradle同一目录： path &quot;CMakeLists.txt&quot; path &quot;/src/main/jni/CMakeLists.txt&quot; } } 配置gradle脚本 android { compileSdkVersion 28 defaultConfig { ... externalNativeBuild { cmake { // Passes optional arguments to CMake. arguments &quot;-DCMAKE_VERBOSE_MAKEFILE=TRUE&quot; // Sets optional flags for the C compiler. cFlags &quot;-D_EXAMPLE_C_FLAG1&quot;, &quot;-D_EXAMPLE_C_FLAG2&quot; // Sets a flag to enable format macro constants for the C++ compiler. // -frtti: Runtime Type Information Support // -fexceptions : Exception Support //-std=c++14 : C++ Library Support cppFlags &quot;-D__STDC_FORMAT_MACROS&quot; //更多 arguments https://developer.android.com/ndk/guides/cmake } } ndk { // &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, //指定生成的CPU架构 Specifies the ABI configurations of your native abiFilters &#39;armeabi-v7a&#39; } } externalNativeBuild { cmake { //默认和build.gradle同一目录： path &quot;CMakeLists.txt&quot; path &quot;/src/main/jni/CMakeLists.txt&quot; } } buildTypes { ... } } 配置 CMake 构建脚本如果您的原生源文件还没有 CMake 构建脚本，则您需要自行创建一个并包含适当的 CMake 命令。CMake 构建脚本是一个纯文本文件，您必须将其命名为 CMakeLists.txt。本部分介绍了您应包含到构建脚本中的一些基本命令，用于在创建原生库时指示 CMake 应使用哪些源文件。 注：如果您的项目使用 ndk-build，则不需要创建 CMake 构建脚本。提供一个指向您的 Android.mk 文件的路径，将 Gradle 关联到您的原生库。 要创建一个可以用作 CMake 构建脚本的纯文本文件，请按以下步骤操作： 从 IDE 的左侧打开 Project 窗格并从下拉菜单中选择 Project 视图。 右键点击您的模块的根目录并选择 New &gt; File。 注：您可以在所需的任意位置创建构建脚本。不过，在配置构建脚本时，原生源文件和库的路径将与构建脚本的位置相关。 输入“CMakeLists.txt”作为文件名并点击 OK。 add_library现在，您可以添加 CMake 命令，对您的构建脚本进行配置。要指示 CMake 从原生源代码创建一个原生库，请将 cmake_minimum_required() 和 add_library() 命令添加到您的构建脚本中： # Sets the minimum version of CMake required to build your native library. # This ensures that a certain set of CMake features is available to # your build. cmake_minimum_required(VERSION 3.4.1) # Specifies a library name, specifies whether the library is STATIC or # SHARED, and provides relative paths to the source code. You can # define multiple libraries by adding multiple add.library() commands, # and CMake builds them for you. When you build your app, Gradle # automatically packages shared libraries with your APK. add_library( # Specifies the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp ) 使用 add_library() 向您的 CMake 构建脚本添加源文件或库时，Android Studio 还会在您同步项目后在 Project 视图下显示关联的标头文件。不过，为了确保 CMake 可以在编译时定位您的标头文件，您需要将 include_directories() 命令添加到 CMake 构建脚本中并指定标头的路径： add_library(...) \# Specifies a path to native header files. include_directories(src/main/cpp/include/) CMake 使用以下规范来为库文件命名： lib库名称.so 例如，如果您在构建脚本中指定“native-lib”作为共享库的名称，CMake 将创建一个名称为 libnative-lib.so 的文件。不过，在 Java 代码中加载此库时，请使用您在 CMake 构建脚本中指定的名称： static { System.loadLibrary(“native-lib”); } 注：如果您在 CMake 构建脚本中重命名或移除某个库，您需要先清理项目，Gradle 随后才会应用更改或者从 APK 中移除旧版本的库。要清理项目，请从菜单栏中选择 Build &gt; Clean Project。 Android Studio 会自动将源文件和标头添加到 Project 窗格的 cpp 组中。使用多个 add_library() 命令，您可以为 CMake 定义要从其他源文件构建的更多库。 添加 NDK APIAndroid NDK 提供了一套实用的原生 API 和库。通过将 NDK 库包含到项目的 CMakeLists.txt 脚本文件中，您可以使用这些 API 中的任意一种。 预构建的 NDK 库已经存在于 Android 平台上，因此，您无需再构建或将其封装到 APK 中。由于 NDK 库已经是 CMake 搜索路径的一部分，您甚至不需要在您的本地 NDK 安装中指定库的位置 - 只需要向 CMake 提供您希望使用的库的名称，并将其关联到您自己的原生库。 将 find_library() 命令添加到您的 CMake 构建脚本中以定位 NDK 库，并将其路径存储为一个变量。您可以使用此变量在构建脚本的其他部分引用 NDK 库。以下示例可以定位 Android 特定的日志支持库并将其路径存储在 log-lib 中： find_library( # Defines the name of the path variable that stores the # location of the NDK library. log-lib # Specifies the name of the NDK library that # CMake needs to locate. log ) 为了确保您的原生库可以在 log 库中调用函数，您需要使用 CMake 构建脚本中的 target_link_libraries() 命令关联库： find_library(...) \# Links your native library against one or more other native libraries. target_link_libraries( # Specifies the target library. native-lib # Links the log library to the target library. ${log-lib} ) NDK 还以源代码的形式包含一些库，您在构建和关联到您的原生库时需要使用这些代码。您可以使用 CMake 构建脚本中的 add_library() 命令，将源代码编译到原生库中。要提供本地 NDK 库的路径，您可以使用 ANDROID_NDK 路径变量，Android Studio 会自动为您定义此变量。 以下命令可以指示 CMake 构建 android_native_app_glue.c，后者会将 NativeActivity 生命周期事件和触摸输入置于静态库中并将静态库关联到 native-lib： add_library( app-glue STATIC ${ANDROID\_NDK}/sources/android/native\_app\_glue/android\_native\_app\_glue.c ) \# You need to link static libraries against your shared native library. target_link_libraries( native-lib app-glue ${log-lib} ) 添加其他预构建库导入so库添加预构建库与为 CMake 指定要构建的另一个原生库类似。不过，由于库已经预先构建，您需要使用 IMPORTED 标志告知 CMake 您只希望将库导入到项目中： add_library( imported-lib SHARED IMPORTED ) 然后，您需要使用 set_target_properties() 命令指定库的路径，如下所示。 某些库为特定的 CPU 架构（或应用二进制接口 (ABI)）提供了单独的软件包，并将其组织到单独的目录中。此方法既有助于库充分利用特定的 CPU 架构，又能让您仅使用所需的库版本。要向 CMake 构建脚本中添加库的多个 ABI 版本，而不必为库的每个版本编写多个命令，您可以使用 ANDROID_ABI 路径变量。此变量使用 NDK 支持的一组默认 ABI，或者您手动配置 Gradle 而让其使用的一组经过筛选的 ABI。例如： add_library(...) set_target_properties( # Specifies the target library. imported-lib # Specifies the parameter you want to define. PROPERTIES IMPORTED_LOCATION # Provides the path to the library you want to import. imported-lib/src/${ANDROID_ABI}/libimported-lib.so ) 为了确保 CMake 可以在编译时定位您的标头文件，您需要使用 include_directories() 命令，并包含标头文件的路径： include_directories( imported-lib/include/ ) 注：如果您希望封装一个并不是构建时依赖项的预构建库（例如在添加属于 imported-lib 依赖项的预构建库时），则不需要执行以下说明来关联库。 要将预构建库关联到您自己的原生库，请将其添加到 CMake 构建脚本的 target_link_libraries() 命令中： target_link_libraries( native-lib imported-lib app-glue ${log-lib} ) 在您构建应用时，Gradle 会自动将导入的库封装到 APK 中。您可以使用 APK 分析器验证 Gradle 将哪些库封装到您的 APK 中。如需了解有关 CMake 命令的详细信息，请参阅 CMake 文档。 导入.a静态库android studio cmake 配置.a连接库 实战小案例指定 C++标准externalNativeBuild { cmake { cppFlags &quot;-frtti -fexceptions -std=c++14&quot; arguments &#39;-DANDROID_STL=c++_shared&#39; } } 编译一个目录中所有源文件# aux_source_directory 方法将路径列表全部放到一个变量中 aux_source_directory(${CMAKE_HOME_DIRECTORY}/src/api SRC_LIST) aux_source_directory(${CMAKE_HOME_DIRECTORY}/src/core CORE_SRC_LIST) # 拼接到路径列表 list(APPEND SRC_LIST ${CORE_SRC_LIST}) add_library(native-lib SHARED ${SRC_LIST}) 调试 message 方法打印cmake_minimum_required(VERSION 3.4.1) message(STATUS &quot;execute CMakeLists&quot;) # 日志输出==&gt; .externalNativeBuild/cmake/debug/{abi}/cmake_build_output.txt CMakeLists.txt 改动什么时候执行sync 其他的时候只是出来缓存 测试了下，好像在 sync 的时候会执行。执行一次后会生成 makefile 的文件缓存之类的东西放在 externalNativeBuild 中。所以如果 CMakeLists.txt 中没有修改的话再次同步好像是不会重新执行的。（或者删除 .externalNativeBuild 目录）真正编译的时候好像只是读取.externalNativeBuild 目录中已经解析好的 makefile 去编译。不会再去执行 CMakeLists.txt 教程 官方7step入门教程： cmake-tutorial 【英文】 翻译： CMAKE官网教程 并有相关方法的详解 进阶Book: Mastering CMake 资料文献 CMake 手册详解（一） android ndk guides Introduction Building Architectures and CPUs Debugging and Profiling Libraries 安卓各版本提供可调用ndk库 High-Performance Audio 一些流行的底层的第三方库Simpleperf/ OpenSL ES/Vulkan/Machine Learning googlesamples/android-ndk CMake 官方文档 JNI 框架官方文档 参考 gcc程序的编译过程和链接原理 AndroidStudio用Cmake方式编译NDK代码 Android增量更新与CMake构建工具 跟我一起写 Makefile Android NDK开发扫盲及最新CMake的编译使用]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>tool</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 图片和文字开源库]]></title>
    <url>%2F2018%2F06%2F01%2F2018-6-1-font-img-tools%2F</url>
    <content type="text"><![CDATA[图片图片样式处理PloyFun 加载样式 加载样式]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>图片</tag>
        <tag>文字</tag>
        <tag>font</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇葩说娱乐笔记]]></title>
    <url>%2F2018%2F04%2F20%2F2018-4-20-entertainment-fancy-talk%2F</url>
    <content type="text"><![CDATA[奇葩说第4季分手要不要当面说 20170414刘白范甜甜 他提出不公平，最爱的人否定伤得最深； 永开 分手的理由都是不对 把爱看太重 把爱情当成婚姻一样沉重，轻松的开始轻松的结束，把感情看得太重而不会享受感情—– 反驳受众是把分手看特很重的人群（这样这个辩题才有意义） 赵大情 热恋痛离 爱情观，热烈真诚而且深刻–恋爱的代价–更加珍贵分手的痛相对于见面的心动，微信的分手不配我的爱情 邱晨 分手好好说话；不要增加分手成本搞分手纪念日烧纸，对方要分手增加成本这样你就不敢分手了分手发生的情景 真实的分手的情况，切断信号，你们想象的是盛大闭幕式的烟花表演，分手是所有的烟花散去之过后，无尽的空洞和冷漠我们要分手就是我们没有办法从爱情这所学校毕业了，现在你要求我们要进行一场退学考试，甚至是退学面试，为什么，但凡我们有一丝一毫的勇气我们能不能用来在一起，而不是用来分开上 马微微 逃过生离，逃不过死离，需直面生活渣字被你一写变狂草了，书法艺术家呀，忽悠人忽悠得这么深情款款，让我觉得没有被你甩一次是我人生的大不幸呀成年人的决定 人生必修的一堂课，叫做当面分手，教会了我们什么，教会我们学会面对，坦然面对，面对我们的失败，面对我们的不堪逃避 每次逃走留下的烂摊子，最后都会成为你人生中无法收拾的烂尾楼吗？ 成年人的决定，想象超人想象特工是一种逃避逃不过 但是人生总有逃不过的时候，体体面面的分手从此在没有相见,这是成年人的分手，面对自己，面对对方。逃得过生离，逃得过死别吗 面对不完美的结局，并体面的收拾自己的烂摊子，人生必须处处 锥心，才有真心成熟而全面的决定 感性和理想票两票 其他 爱没有公不公平，只有愿不愿意，无法回到从前 单身狗，直男脱单，难于脱贫 两票，正常人只有感谢票，还他妈看脸，撕逼后我当时怎么就蒙住了呢，不当面能更好的撕 导师总结 不再驾驭感情，而是懂得感激；什么是驾驭感情，你在设计一种模式，比如说感激应该漂漂亮亮，感激应该是轻松的。感激这个事情是两个人的事情，是两个人最后化反的最终结果，你只能懂得我想我们不需要再继续走下去了，至少我觉得有困难，你是希望当面聊一聊，你还是希望这样就好了，那我随时在这里 辩题前提是一个人想见，一个人不见，不如不见 结辩 【重点】 该做不到，交代 两个底线1.我们在一起绝不互相绑架，一定要尊重对方的意志 我们不在一起我们绝不互相伤害，我们要文明。幼稚的定义，目标既定的情况下采取的策略是错的。– 你想分就分见个面就分幼稚— 我的目标是什么， 成人的世界没有态度的该不该，我的价值观稳定情况下，我设定的目标怎样拆解成方法和行动— 我的目标是分手而且对对方的伤害降得最低— 具体比抽象更伤害越抽象越尊重越不伤害– 长大 遇到危险伴侣手刀（快速逃跑）逃跑 该不该原谅他 20170421 赵又廷撒狗粮三生三世只爱高圆圆 马贱越爱情可以战胜一切，只要你爱他，就原谅他，否则，只做单身狗，只做自己 首尔 本能和本能之间差出和谐的火花 类比吵架维持内心和谐的次序，问路大叔，半身水池 烂事和惩罚的平衡 不原谅是对自己的一种救赎，原谅伴随着你对人性弱点的接纳和妥协，这样你会只相信人性，不相信人#### 灾难来了谁都得跑； 男的站着，女的跑 中国感动是教育（灾难面前人人都平等），我们以为人类仿佛应该是这样的，如果ta没做到这样子，ta就是不对的，其实他做到这样子，你更应该感谢的。因为，我们希望我们的爱情是获得式的爱情，不是索取式的爱情，他给你了你很高兴，他没给你这也很正常。感动时刻–&gt; 这个是加分项，不是底线，ta做到了你要感谢他 不原谅，放不下。灾难来了，没有太大的价值去怀念去铭记，你既是慷他之慨，也是慷自己之慨。浙大美女学霸 双重标准，爱情观中清单不可原谅的事情上，下面该不该原谅。张爱玲和胡兰成的事情，没有守住底线。爱情双方是增值的过程。 爱情能战胜一些本能的欲望与诉求； 因为我还是对爱情有一点点底线，一点点要求的人，我不希望我别成一个爱情只对我有要求的人，我不希望我变成爱情的努力。 永开 见死不救和灾难不同 可逃不可逃，为什么这个情景我们希望对方能活下来，为什么我们心中不原谅的情绪，我们不原谅的是那一个没有办法全心全意为对方担心的自己 自己的故事，如果恨我能让你感觉舒服一点点的话那你就恨我吧，没关系的。恨他没有让我得到救赎，甚至盖过了我幸福的瞬间 这对双方都是灾难 段子医生 有判断的，心里创伤 原谅和不原谅都轻描淡写了，所有说不原谅就是不要轻易的原谅； 呼唤爱 五秒性格，决定一生太鲁莽导师结辩-]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计相关]]></title>
    <url>%2F2018%2F04%2F15%2F2018-4-15-designer%2F</url>
    <content type="text"><![CDATA[相关开源库Lottie 官方全平台使用说明： https://airbnb.io/lottie/ AE动画设计 + lottie-android 【简易的惊艳动画.必看】 lottie-web 效果预览 lottiefiles 在线data.json 预览效果 bodymovin web 效果预览 环境配置 bodymovie插件下载地址 汉化版本地址 在线编辑工具 参考博文 Android开发之Lottie动画解析库 AE的简单实用和Lottie的简单实用 附录 web 最简单Demo bodymovin web javaScript libs lottie.js lottie_light.js fack-rebound 弹性动画 有网页Demo 能大大的提高用户体验 代码开源库控件 Genius-Android Sketch插件 Renamer 多图层重命名工具 sketch-export Export Artboards in sketch to markdown or json]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用总结]]></title>
    <url>%2F2018%2F04%2F15%2F2018-4-15-android-studio-usage%2F</url>
    <content type="text"><![CDATA[常用插件Android ButterKnifeZelezny 5 星 ADB Comand 3星 GsonFormatString 解析成实体 Default Option + s(Mac), Alt + s (win) Key Promoter X 快捷键提示 AS plugin 搜索安装 codota 代码案例查找【重点】 快捷键 Shift + Alt + Space CodeGlance 代码概况 Parcelable Plugin JarFilterPlugin 修改第三方Jar并打包进应用，如可以借助 JarFilterPlugin 来修改 Retrofit 的内部代码 Java自动生成 serialVersionUID优化 dexcount-gradle-plugin 每次编译都统计Field and Method number UI android-drawable-importer android-selector Material Design Icon Generator Android-drawable-preview-plugin Android Styler 相对于AS提供的功能，这个优势在能指定style存放的文件及相对的位置； 其他 idea-multimarkdown【收费】 gradle-maven-publish-plugin 上传你的代码到所有的版本仓库中 DepSwitchPlugin aar和源码切换，开发阶段源码，稳定阶段用aar 高级Android studio 插件的开发 How to Develop Android Studio Plugin]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android studio</tag>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 常用开源库]]></title>
    <url>%2F2018%2F04%2F14%2F2018-4-14-android-open-source-tools%2F</url>
    <content type="text"><![CDATA[正在研究 SUtils 封装有许多实用的开发工具类 APKParser parceler通过注解的方式序列化对象more: Transfuse Transfuse is a Java Dependency Injection (DI) and integration library geared specifically for the Google Android API. 数据持久化 Awesome-Android-Persistence 数据持久化优秀的开源库列表 【重点】 android-sqlite-asset-helper 构建工具 MultiChannelPackageTool 快速多渠道打包工具。 开发中实用的工具 RoboGif A small utility to record Android device screen to a GIF AppUninstall Android App监听自身卸载，反馈统计 LogCollector 一个收集 app 输出日志的工具 UI AndroidDesignPreview AndroidAssetStudio Android常用图标生成Web 切图标记外挂神器 Assistor PS 介绍 动态修改App字符开源库 Philology 主题 Cyanea 显示效果 闪光 Shimmer shimmer-recyclerview-x 闪光list检测优化工具 LeakCanary Android 和 Java 内存泄露检测Tutorial ChineseEnglishphrof file path: /storage/sdcard0/Download/leakcanary/hprof-conv leakCanary apk-method-count 上传Apk，可以根据包名统计方法数量的网站，UI很友好。 battery-historian Google 官网方 针对 Api21 5.0以上系统开发的电量使用情况分析工具 功能性开发工具 card.io-Android-source 信用卡扫描ＳＤＫ reprint A simple, unified fingerprint authentication library for Android with ReactiveX extensions. DimensCodeTools 一个可以支持生成二维码，条形码和扫描的库 Permission Dexter Dexter is an Android library that simplifies the process of requesting permissions at runtime. PermissionHelper easypermissions 图片加载PicassoUniversal-ImageLoaderVolleyGlide Tutorial Chinese综合： 开源组件加载网络图片的优缺点比较 FileDownload Android-Download-Manager-Pro MultiThreadDownloader 下载 FileDownloader Multitask、Breakpoint-resume、High-concurrency、Simple to use、Single-process Once some info may show once in a new app in a update or first time install this via share sharedPreferences sore the timestamp 基础的开发工具 JavaVerbalExpressions Java regular expressions made easy. 帮助简单的实现正则表达 joda-time-android／ThreeTenABP Java8 的Date包移植到Android中来的库 MathView A library for displaying math formula in Android apps. 崩溃错误处理LoadSir 优雅地处理加载中，重试，无数据等配置: compile ‘com.kingja.loadsir:loadsir:1.3.6’ProGuard: -dontwarn com.kingja.loadsir.** -keep class com.kingja.loadsir.** {*;} YCStateLayout 特殊状态提示 状态切换，让 View 状态的切换和 Activity 彻底分离开。 YCStateLayout BufferKnifeVIEW LISTS@OnClick({ R.id.door1, R.id.door2, R.id.door3 }) @BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name }) List&lt;EditText&gt; nameViews; // The apply method allows you to act on all the views in a list at once. ButterKnife.apply(nameViews, DISABLE); ButterKnife.apply(nameViews, ENABLED, false); //Action and Setter interfaces allow specifying simple behavior. static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() { @Override public void apply(View view, int index) { view.setEnabled(false); } }; static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() { @Override public void set(View view, Boolean value, int index) { view.setEnabled(value); } }; An Android Property can also be used with the apply method.ButterKnife.apply(nameViews, View.ALPHA, 0.0f); RESOURCE BINDINGclass ExampleActivity extends Activity { @BindString(R.string.title) String title; @BindDrawable(R.drawable.graphic) Drawable graphic; @BindColor(R.color.red) int red; // int or ColorStateList field @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field // ... } automatically be cast.@OnClick(R.id.submit) public void sayHi(Button button) { button.setText(&quot;Hello!&quot;); } OPTIONAL BINDINGS@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() { // TODO ... } BINDING RESET on Fragments @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fancy_fragment, container, false); unbinder = ButterKnife.bind(this, view); // TODO Use fields... return view; } @Override public void onDestroyView() { super.onDestroyView(); unbinder.unbind(); } 模块化的开发工具 AndroidFilePicker FilePicker 是一个小巧快速的文件选择器框架，以快速集成、高自定义化和可配置化为目标不断前进]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 代码规范化笔记]]></title>
    <url>%2F2018%2F04%2F14%2F2018-4-14-android-standards%2F</url>
    <content type="text"><![CDATA[代码规范化工具Square Android Code Style 下载-&gt; install.xx -&gt; restart-&gt;Code Style -&gt; Java 代码格式快捷键： Mac Cmd + Option + L Win Ctrl + Alt + L AS Plugin checkstyle-idea 安装plugin-&gt; reatart-&gt; Setting Other Setting -&gt; 可以导入自定义检查 运行 提交代码时自动格式化 运维 基于Travis CI搭建Android持续集成以及自动打包发布流程]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密钥和证书管理工具Keytool及jarsigner的使用]]></title>
    <url>%2F2017%2F04%2F19%2F2017-04-19-keytool_signerJar%2F</url>
    <content type="text"><![CDATA[Keytool简介keytool 是JDK 1.4 后集成的密钥和证书管理工具 官网文档·英文 Window：&lt;JAVA_HOME&gt;\bin\keytool.exeMac: &lt;JAVA_HOME&gt;/Contents/Home/bin 生成keystorekeytool -genkey -alias myAlias -keyalg RSA -validity 40000 -keystore demo.keystore #说明： # -genkey 产生密钥 # -alias myAlias 别名 myAlias # -keyalg RSA 使用RSA算法对签名加密 # -validity 40000 有效期限4000天 # -keystore demo.keystore 查看 keystore签名信息keytool -list -keystore demo.keystore 输出结果： -------------- 密钥库类型: JKS 密钥库提供方: SUN 您的密钥库包含 1 个条目 myAlias, 2017-4-19, PrivateKeyEntry, 证书指纹 (SHA1): C1:4E:A3:BC:4D:C3:35:6C:F6:8A:9D:0E:EA:F3:79:4B:D9:1D:B4:C1 对apk进行签名jarsigner -verbose -keystore [demo.keystore] -signedjar demo_signed.apk demo.apk [alias] Shell脚本获取指纹 【成果】Apk签名证书MD5指纹echo.sh #/bin/sh cert_XSA=`jar tf $1 | grep SA` #获取签名文件在Apk中路径, $1为输入的apk #echo $cert_XSA jar xf $1 $cert_XSA #提取签名文件 echo -------------------------------------------------------------------------- echo 证书MD5指纹:`keytool -printcert -file $cert_XSA | grep MD5` echo -------------------------------------------------------------------------- rm -rf `dirname $cert_XSA` #删除提取的文件夹 Usage： source echo.sh demo.apk 证书文件操作 导出到证书文件keytool -export -alias myAlias -file test.crt -keystore test.keystore 将名为test.keystore的证书库中别名为test1的证书条目导出到证书文件test.crt 导入证书的信息keytool -import -keystore test_cacerts -file test.crt 将证书文件test.crt导入到名为test_cacerts的证书库中 查看证书信息`shellkeytool -printcert -file “test.crt”输出结果： 所有者: CN=test, OU=android, O=android, L=shenzhen, ST=guangdong, C=china发布者: CN=test, OU=android, O=android, L=shenzhen, ST=guangdong, C=china序列号: 6f75ebb1有效期开始日期: Wed Apr 19 12:17:14 CST 2017, 截止日期: Fri Oct 25 12:17:14 CST 2126证书指纹: MD5: E0:93:87:28:43:D9:85:12:B2:41:36:D6:E2:BC:7C:83 SHA1: C1:4E:A3:BC:4D:C3:35:6C:F6:8A:9D:0E:EA:F3:79:4B:D9:1D:B4:C1 SHA256: 51:E8:9D:ED:64:62:4C:80:D4:42:69:41:9C:0C:E4:3B:89:FE:34:E6:A4:42:47:83:FB:CF:99:BD:DA:39:DA:90 签名算法名称: SHA256withRSA 版本: 3 扩展: #1: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 2E 49 AD 2B 2D 4E D3 0D 02 FC 5B 5F EF 00 77 0F .I.+-N….[_..w.0010: 5D 91 1D 1C ]…]]`]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 高效图片加载]]></title>
    <url>%2F2017%2F04%2F17%2F2017-04-17-Optimization-Bitmap%2F</url>
    <content type="text"><![CDATA[图片加载一直是程序稳定性的重要因素，但是随着Glide，Picasso，Universal-ImageLoader等图片加载库的逐渐成熟，反而会使我们对图片加载掉以轻心，疏忽对图片加载的操作，导致内存占用过高，频繁出现OOM(OutOfMemory)异常，严重影响用户体验。 Bitmap秘籍inJustDecodeBounds取关键信息，不加载到内存加载图片之前就获取到图片的长宽值和MIME类型，不加载进内存，从而根据情况对图片进行压缩 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(getResources(), R.id.myimage, options); int imageHeight = options.outHeight; int imageWidth = options.outWidth; String imageType = options.outMimeType; Note： 最理性的加载情况是，不穿小鞋也不穿大鞋 inSampleSize等比例压缩很多情况下我们是在大脚穿小鞋的情况，例如：用相机拍照返回的原图1024x768像素，直接用来显示头像ImageView只有128x96像素，设置inSampleSize=4，从原画中每4像素提取1给像素到目标图片，这样就减少内存使用；计算出合适的inSampleSize值 public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { // 源图片的高度和宽度 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height > reqHeight || width > reqWidth) { // 计算出实际宽高和目标宽高的比率 final int heightRatio = Math.round((float) height / (float) reqHeight); final int widthRatio = Math.round((float) width / (float) reqWidth); // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高 // 一定都会大于等于目标的宽和高。 inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio; } return inSampleSize; } 合并使用先开启inJustDecodeBounds只读取获取高宽关键信息，获得合适的inSimpleSize的值，合理加载图片； public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) { // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小 final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // 调用上面定义的方法计算inSampleSize值 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 使用获取到的inSampleSize值再次解析图片 options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); } InputStream 中使用 public static Bitmap getFitSampleBitmap(InputStream inputStream, int width, int height) throws Exception { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; byte[] bytes = readStream(inputStream); //BitmapFactory.decodeStream(inputStream, null, options); BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options); options.inSampleSize = getFitInSampleSize(width, height, options); options.inJustDecodeBounds = false; // return BitmapFactory.decodeStream(inputStream, null, options); return BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options); } /* * 从inputStream中获取字节流 数组大小 * */ public static byte[] readStream(InputStream inStream) throws Exception { ByteArrayOutputStream outStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while ((len = inStream.read(buffer)) != -1) { outStream.write(buffer, 0, len); } outStream.close(); inStream.close(); return outStream.toByteArray(); } 使用内存缓存技术LruCacheLruCache 在android-support-v4的包中提供, 它的主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。 LruCache.java private LruCache&lt;String, Bitmap> mMemoryCache; @Override protected void onCreate(Bundle savedInstanceState) { // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。 // LruCache通过构造函数传入缓存值，以KB为单位。 int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 使用最大可用内存值的1/8作为缓存的大小。 int cacheSize = maxMemory / 8; mMemoryCache = new LruCache&lt;String, Bitmap>(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { // 重写此方法来衡量每张图片的大小，默认返回图片数量。 return bitmap.getByteCount() / 1024; } }; } public void addBitmapToMemoryCache(String key, Bitmap bitmap) { if (getBitmapFromMemCache(key) == null) { mMemoryCache.put(key, bitmap); } } public Bitmap getBitmapFromMemCache(String key) { return mMemoryCache.get(key); } 如上，最核心的问题是如何合理的分配LruCache的大小，关键因素：设备 应用可分配内存； 设备屏幕和分辨率 图片 尺寸和大小及对应的消耗内存； 访问的频率； 动态保持的图片数量及内存总量； Glide 图片优化根据ImageView的大小，指定请求图片大小用 resize(x,y) 调整图片大小用CenterCrop, FitCenter调整显示效果 Glide .with(context) .load(UsageExampleListViewAdapter.eatFoodyImages[0]) .override(600, 200) // resizes the image to these dimensions (in pixel) //.fitCenter() .centerCrop() // this cropping technique scales the image so that it fills the requested bounds and then crops the extra. .into(imageView); 常用方法 获得应用程序最高可用内存int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); Log.d("TAG", "Max memory is " + maxMemory + "KB"); 官方资源 Handling Bitmaps 【需翻墙】 DisplayingBitmaps.zip DisplayingBitmaps部分讲解： Android中高效的显示图片 - Bitmap的内存模型 参考 [1] ANDROID高效加载图片，有效避免程序OOM [2] Glide 系列预览]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Data Binding 详解及使用案例]]></title>
    <url>%2F2017%2F04%2F02%2F2017-04-02-Data-Binding%2F</url>
    <content type="text"><![CDATA[构建环境使用条件 支持 Android 2.1 (API level 7+). Android Plugin for Gradle 1.5.0-alpha1 或更高buildscript { ... dependencies { classpath 'com.android.tools.build:gradle:1.5.0-alpha1' } } 开启android { .... dataBinding { enabled = true } } 基本用法 （Data Binding Layout Files）绑定实体数据到指定布局（Layout）public class User { private final String firstName; private final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String getFirstName() { return this.firstName; } public String getLastName() { return this.lastName; } } 如果我需要用Layout展示用户信息 User，通常我们的做法就是 新建Layout.xml； 找到对应控件，findIdByView或 Butterknife ； 设置数据； 感觉用Butterknife已经很高大上，很高效了，看一下Data Binding的效率：main_activity.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;data> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;TextView android:layout_width="wrap_content" android:id="@+id/mFirstName" android:layout_height="wrap_content" android:text="@{user.firstName}"/> &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@{user.lastName}"/> &lt;/LinearLayout> &lt;/layout> MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); User user = new User("Test", "User"); binding.setUser(user); } 高效没看出来呀！为了让接手的下一个兄弟不骂娘，我还是选择普通写法o(╯□╰)o，那如果是这种布局呢 你用几百行的代码，DataBinding一行搞定，Boss此刻应该蹲在厕所喜极而泣，我XX我早该找一个这样的程序员。 小知识点 Fragment ,ListView,RecyclerView 中的使用// ListView RecyclerView ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); //Fragment MainFragmentBinding binding = DataBindingUtil.inflate(inflater, R.layout.main_fragment, container, false); 如果想操作对应的控件需要设置id号，如main_activity.xml, 设置android:id=&quot;@+id/mFirstName&quot; ，可以直接用binding.mFirstName 找到控件 ； 【待处理】测试中得到binding MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater()); ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false); 事件绑定（Event Handling）最简单的应用main_activity.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;data> &lt;variable name="handlers" type="com.example.MyHandlers"/> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@{user.firstName}" android:onClick="@{handlers::onClickFriend}"/> &lt;/LinearLayout> &lt;/layout> 事件处理类 public class/*也可以是接口*/ MyHandlers { public void onClickFriend(View view) { ... } } 控制代码同上，设置变量就可以binding.setHandlers(...) 带参数的事件绑定（Android Plugin for Gradle 2.0 或更高）main_activity.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;data> &lt;variable name="handlers" type="com.example.MyHandlers"/> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@{user.firstName}" android:onClick="@{() -> handlers.onSaveClick(user)}"/> &lt;/LinearLayout> &lt;/layout> 事件处理类 public class MyHandlers { public void onSaveClick(User user){} } 传入View方式 android:onClick=&quot;@{(theView) -&gt; handlers.onSaveClick(theView, user)}&quot; 或 &lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:onCheckedChanged="@{(cb, isChecked) -> handlers.completeChanged(user, isChecked)}" /> 注意：避免一些比较复杂的listeners，这样会使得Layout更易读更容易维护 Data Layout 小细节及简单语法Imports&lt;data> &lt;import type="android.text.TextUtils"/> &lt;!--静态类的使用--> &lt;import type="android.view.View"/> &lt;!--导入--> &lt;variable name="note" type="String"/>&lt;!--自动导入java.lang.*--> &lt;import type="com.example.real.estate.View" alias="Vista"/> &lt;!--别名解决同名类--> &lt;/data> &lt;TextView android:text="@{TextUtils.isEmpty(user.lastName)? "default":user.lastName }" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@{user.isAdult ? View.VISIBLE : View.GONE}"/> &lt;!-【使用】--> Note: 默认自动导入java.lang.*，常用的有Integer，String，StringBuffer，Math类 Binding Class Names 如上：MainActivityBinding 类 默认命名规则 包名+布局名去‘_’首字母大写+Binding 如： main_activity.xml ==&gt; MainActivityBinding.class 自定义的三种解释&lt;data class="ContactItem">&lt;/data> &lt;!--自定义名称--> &lt;data class=".ContactItem">&lt;/data> &lt;!--使用module包名--> &lt;data class="com.example.ContactItem">&lt;/data> &lt;!--指定包名--> IncludesData layout 复用&lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"> &lt;data> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;include layout="@layout/name" bind:user="@{user}"/> &lt;include layout="@layout/contact" bind:user="@{user}"/> &lt;/LinearLayout> &lt;/layout> 简单语法Java共同特征 Mathematical + - / * % String concatenation + Logical &amp;&amp; || Binary &amp; | ^ Unary + - ! ~ Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt; Comparison == &gt; &lt; &gt;= &lt;= instanceof Grouping () Literals - character, String, numeric, null Cast Method calls Field access Array access [] Ternary operator ?: Examples: android:text=&quot;@{String.valueOf(index + 1)}&quot; android:visibility=&quot;@{age &lt; 13 ? View.GONE : View.VISIBLE}&quot; android:transitionName=&#39;@{&quot;image_&quot; + id}&#39; android:text=&quot;@{user.displayName ?? user.lastName}&quot; 【重点】&lt;==&gt; 等价于 android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot; Resources引用 Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList Sample android:text="@{@string/nameFormat(firstName, lastName)}" android:text="@{@plurals/banana(bananaCount)}" android:padding="@{large? @dimen/largePadding : @dimen/smallPadding}" String formatting &lt;resources> &lt;string name="greeting">Hello, %s&lt;/string> &lt;/resources> &lt;TextView android:text="@{@string/greeting(user.firstName)}"/> Math in expressions &lt;TextView android:padding="@dimen/padding" android:padding="@{@dimen/padding}" android:padding="@{@dimen/padding * 2}" android:padding="@{@dimen/padding + @dimen/padding}" android:padding="@{largeScreen ? @dimen/padding * 2 : @dimen/padding}" /> 更改数据自动更新UI界面 （Data Objects）经过上的学习，有木有发现， 布局Layout中的数据variables是固定的，只有初始化的时候赋值 数据变动时（设置数据，得到数据），还需要找控件，设置参数，更改UI状态, 基本还是老套路，官方的解决方案是Observable，使用观察者模式，当数据变化时通知layout自动变化，官方提供的类： Observable Objects ； ObservableFields ； Observable Collections； Observable Objectspublic static class User extends BaseObservable { private String firstName; private String lastName; @Bindable public String getFirstName() { return this.firstName; } @Bindable public String getLastName() { return this.lastName; } public void setFirstName(String firstName) { this.firstName = firstName; notifyPropertyChanged(BR.firstName); } public void setLastName(String lastName) { this.lastName = lastName; notifyPropertyChanged(BR.lastName); } } 经过改造后的User,同上的初始化 private User user ; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); user = new User("Test", "User"); binding.setUser(user); //点击LastName触发 binding.setHandlers(new MyHandlers() { @Override public void onClickFriend(View view) { user.setFirstName("FirstName"); //布局自动更新为`FirstName` //此后常用的操作 //布局中Progress android:visibility="@{TextUtil.isEmpty(user.firstName) ? View.GONE : View.VISIBLE}" // 自动控制对应的Progress是否显示，或进行一些简单的逻辑处理 } }); } ObservableFieldsprivate static class User { public final ObservableField&lt;String> firstName = new ObservableField&lt;>(); public final ObservableField&lt;String> lastName = new ObservableField&lt;>(); public final ObservableInt age = new ObservableInt(); } // 对应的set/get user.firstName.set("Google"); int age = user.age.get(); Observable CollectionsObservableArrayMap&lt;String, Object> user = new ObservableArrayMap&lt;>(); user.put("firstName", "Google"); user.put("lastName", "Inc."); user.put("age", 17); 高阶用法在RecyclerView中的使用 （Dynamic Variables）BindingHolder.java public static class BindingHolder extends RecyclerView.ViewHolder{ //加入 ViewDataBinding setter/getter 方法 private ViewDataBinding binding ; public ViewDataBinding getBinding() { return binding; } public void setBinding(ViewDataBinding binding) { this.binding = binding; } public BindingHolder(View itemView) { super(itemView); } } MyAdapter.java private class MyAdapter extends RecyclerView.Adapter&lt;BindingHolder>{ private List&lt;User> users; public MyAdapter(List&lt;User> users) { this.users = users; } @Override public BindingHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) { //核心代码 ViewDataBinding binding = DataBindingUtil.inflate( LayoutInflater.from(viewGroup.getContext()), R.layout.list_item, viewGroup, false); BindingHolder holder = new BindingHolder(binding.getRoot()); holder.setBinding(binding); return holder; } @Override public void onBindViewHolder(BindingHolder holder, int position) { User user = users.get(position); holder.getBinding().setVariable(BR.user, user); //不等待下一帧（Frame），直接更新，这个方法必须运行在UI线程 holder.getBinding().executePendingBindings(); } @Override public int getItemCount() { return users.size(); } } 更简洁的用法 public class UserAdapter extends RecyclerView.Adapter&lt;UserAdapter.UserHolder> { private static final int USER_COUNT = 10; @NonNull private List&lt;User> mUsers; public UserAdapter() { mUsers = new ArrayList&lt;>(10); for (int i = 0; i &lt; USER_COUNT; i ++) { User user = new User(RandomNames.nextFirstName(), RandomNames.nextLastName()); mUsers.add(user); } } public static class UserHolder extends RecyclerView.ViewHolder { private UserItemBinding mBinding; public UserHolder(View itemView) { super(itemView); mBinding = DataBindingUtil.bind(itemView); } public void bind(@NonNull User user) { mBinding.setUser(user); } } @Override public UserHolder onCreateViewHolder(ViewGroup viewGroup, int i) { View itemView = LayoutInflater.from(viewGroup.getContext()) .inflate(R.layout.user_item, viewGroup, false); return new UserHolder(itemView); } @Override public void onBindViewHolder(UserHolder holder, int position) { holder.bind(mUsers.get(position)); } @Override public int getItemCount() { return mUsers.size(); } } ViewStubs使用ViewStub 是不可见的,0大小常用于惰性加载，说白了就是占给位置，在父容器的inflate时候不用处理，当在ViewStub setVisibility(int) or inflate()才会加载到布局中，应用场景：错误提示，帮助提示，用户引导等；用法： &lt;ViewStub android:id="@+id/stub" android:inflatedId="@+id/subTree" android:layout="@layout/mySubTree" android:layout_width="120dip" android:layout_height="40dip" /> ViewStub stub = (ViewStub) findViewById(R.id.stub); View inflated = stub.inflate(); Data layout &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;LinearLayout ...> &lt;!--需要增加ID--> &lt;ViewStub android:id="@+id/view_stub" android:layout="@layout/view_stub" ... /> &lt;/LinearLayout> &lt;/layout> 监听ViewStub inflate 事件 binding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() { @Override public void onInflate(ViewStub stub, View inflated) { ViewStubBinding binding = DataBindingUtil.bind(inflated); User user = new User("fee", "lang"); binding.setUser(user); } }); 自定义Setter实用小例子：设置url，控件直接加载url地址的图片attrs.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;resources> &lt;attr name="url" format="string"/> &lt;/resources> 在任意代码中加入如下： @BindingAdapter("url") public static void loadImage(final ImageView imageView, final String url){ Glide.with(imageView.getContext().getApplicationContext()) .load(url) .into(imageView); } 能得到变化的url及对应的ImageView控件 特殊说明: MasteringAndroidDataBinding中是用declare-styleable加自定义控件的方法来处理数据变化，上面的例子最能达到实践效果，在原生控件中加入自定义是属性,简洁易用； BindingAdapter进价用法观察多个属性 如： @BindingAdapter(value = {&quot;url&quot;,&quot;drawable&quot;},requireAll = false) requireAll指 布局控件中是否需要&quot;url&quot;`“drawable”` 属性都存在，默认为true；监听原生控件的属性变化，做响应的处理（重写），如：@BindingAdapter("android:paddingLeft") public static void setPaddingLeft(View view, int padding) { view.setPadding(padding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); } 获取变化的旧数据和新数据，自义定属性也能使用@BindingAdapter("android:paddingLeft") //注意：android:paddingLeft 可以改为自定义的Setter属性，如上‘url’ public static void setPaddingLeft(View view, int oldPadding, int newPadding) { if (oldPadding != newPadding) { view.setPadding(newPadding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); } } 总结: Data Binding 核心思想是把控件的属性用静态变量代表，并监听属性的变化，通过BindingAdapter来处理数据变化；如果不是很有感觉, 有兴趣进一步研究，建议看一下MVVMLight源码, 一个Data Binding 和RxJava 结合使用的库 单元测试【待实践】安卓 Data Binding 使用方法总结（姐姐篇） 学习资料实在的博客工作原理 Android Data Binding从抵触到爱不释手 比较详细，特别是有源码分析 开源库学习资料 MVVMLight源码, 一个Data Binding 和RxJava 结合使用的库 TODO-DataBinding 和MVP结合使用，Google 官方例子 附录Resource 引用对照表 Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList 常用转义表显示结果 描述 转义字符 十进制 空格 &nbsp; &#160; < 小于号 &lt; &#60; > 大于号 &gt; &#62; & 与号 &amp; &#38; " 引号 &quot; &#34; ‘ 撇号 &apos; &#39; × 乘号 &times; &#215; ÷ 除号 &divide; &#247; 引用： Data Binding Library MasteringAndroidDataBinding Data Binding in the Real World 安卓 Data Binding 使用方法总结（姐姐篇）]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本UI空控件的用方法和属性]]></title>
    <url>%2F2017%2F02%2F17%2F2017-02-17-basic-ui-study%2F</url>
    <content type="text"><![CDATA[控件使用ViewFlipper setInAnimation/setOutAnimation showNext/showPrevious getDisplayedChild() ==&gt; index ==&gt; getChildAt addView(view)/addView(view,position) AbsListView setSelector(new ColorDrawable(Color.TRANSPARENT)); GridView setNumColumns; setVerticalSpacing/setHorizontalSpacing AnimationSet = AnimationUtils.loadAnimation() Tip: 在GridView 的Adapter 内的View 设置setOnClickListener 会导致 设置的 GestureDetector.SimpleOnGestureListener.onFling返回的MotionEvent == null; EditText 显示/隐藏密码setInputType(hasShowPassword ? 129 : InputType.TYPE_TEXT_VARIATION_PASSWORD); 光标位置(定位到最后)edittext.setSelection(int) 获取焦点editText.requestFocus();//获取焦点 如果对edittext组件设置了editText.setFocusable(false);需要重新获取焦点则必须执行： editText.setFocusable(ture); editText.setFocusableInTouchMode(true); editText.requestFocus(); 注意：这种情况下，当重新点击文本框，是无法打开软键盘，必须点击第二次才能打开。 ViewPager setPageTransformer(); //设置页面切换效果 JazzyViewPager 提供11种切换效果 经常直播的效果 public class DepthPageTransformer implements PageTransformer { private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) { int pageWidth = view.getWidth(); if (position &lt; -1) { // [-Infinity,-1) ///看不到的一页 * // This page is way off-screen to the left. view.setAlpha(0); } else if (position &lt;= 0) { // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); } else if (position &lt;= 1) { // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); } else { // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); } } } ListView List内容平滑的移动到指定的位置 smoothScrollToPosition(position); PopupWindow 一定要设置的：View contentView，int width, int height;//构造方法： public PopupWindow (Context context) public PopupWindow(View contentView) public PopupWindow(View contentView, int width, int height) public PopupWindow(View contentView, int width, int height, boolean focusable) //常用的初始化 View contentView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popuplayout, null); PopupWindow popWnd = PopupWindow (context); popWnd.setContentView(contentView); popWnd.setWidth(ViewGroup.LayoutParams.WRAP_CONTENT); popWnd.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT); 显示//相对某个控件的位置（正左下方），无偏移 showAsDropDown(View anchor)： //相对某个控件的位置，有偏移;xoff表示x轴的偏移，正值表示向左，负值表示向右；yoff表示相对y轴的偏移，正值是向下，负值是向上； showAsDropDown(View anchor, int xoff, int yoff)： //相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移 showAtLocation(View parent, int gravity, int x, int y)： 添加动画mPopWindow.setAnimationStyle(R.style.contextMenuAnim);contextMenuAnim.xml &lt;style name="contextMenuAnim" parent="@android:style/Animation.Activity"> &lt;item name="android:windowEnterAnimation">@anim/context_menu_enter&lt;/item> &lt;item name="android:windowExitAnimation">@anim/context_menu_exit&lt;/item> &lt;/style> context_menu_exit.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;set xmlns:android="http://schemas.android.com/apk/res/android" > &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="100%p" /> &lt;/set> setFocusable EditText 是否点击后可编辑 mPopWindow.setBackgroundDrawable(new BitmapDrawable()) 的作用 setOutsideTouchable（）才会生效 PopupWindow才会对手机的返回按钮有响应 API &gt;= 23 setEnterTransition(Transition) or setExitTransition(Transition) 参考： PopupWindow才会对手机的返回按钮有响应 常用的UI方法获取xml属性 // Calculate ActionBar height TypedValue tv = new TypedValue(); if (context.getTheme().resolveAttribute( android.R.attr.actionBarSize, tv, true)) { mActionBarHeight = TypedValue.complexToDimensionPixelSize( tv.data, context.getResources().getDisplayMetrics()); }]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>support</tag>
        <tag>UI</tag>
        <tag>Basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout入门体验]]></title>
    <url>%2F2017%2F02%2F07%2F2017-02-07-ConstraintLayout-study%2F</url>
    <content type="text"><![CDATA[ConstraintLayout 核心思想：平面内确定一点]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Design</tag>
        <tag>support</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc学习笔记]]></title>
    <url>%2F2017%2F02%2F05%2F2017-02-05-java-doc%2F</url>
    <content type="text"><![CDATA[官方学习文档 How to Write Doc Comments for the Javadoc Tool 常用的HTML标签 标签 含义 &lt;strong&gt;&lt;/strong&gt; 字体加粗 &lt;p&gt; 换行 &lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt; 图片引用 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 超链接内容 加粗 strong&lt;strong&gt;Strong&lt;/strong&gt; 超链接 href&lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;Rx Design Guidelines (PDF)&lt;/a&gt; 换行/** &lt;p> * **/ 图片引用&lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/create.png&quot; alt=&quot;&quot;&gt; 常用的格式 标题加粗换行 /** * &lt;dl> * &lt;dt>&lt;b>Backpressure:&lt;/b>&lt;/dt> * &lt;dd>The {@code OnSubscribe} instance provided is responsible to be backpressure-aware or * document the fact that the consumer of the returned {@code Observable} has to apply one of * the {@code onBackpressureXXX} operators.&lt;/dd> * &lt;dt>&lt;b>Scheduler:&lt;/b>&lt;/dt> * &lt;dd>{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd> * &lt;/dl> **/]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 学习笔记]]></title>
    <url>%2F2017%2F02%2F01%2F2017-02-01-rx-learning-note%2F</url>
    <content type="text"><![CDATA[为什么要学RxJava 最大的好处在于,很优雅处理各种线程切换,能使整个代码块的逻辑连贯,易于阅读和维护; 提供丰富的操作符, 能使很多复杂的操作简单几步搞定; 运用响应式编程,使整个编程更流畅简洁; 开源库 RxJava&nbsp;&nbsp;&nbsp;&nbsp; RxAndroid Rx Sample RxUi Implementation of pure functional concept of talking to Android View layer in a Reactive way ReactiveCache Android-RxJava-samples Rex-weather Android animations powered by RxJava Rx 相关的开源工具库 RxAnimations RxBinding rx-preferences Reactive SharedPreferences for Android requery 支持RxJava Kotlin / Android ORM库 RxLifecycle 处理由Activity 或 Fragment生命周期，导致没有完成的订阅（subscriptions）触发的内存泄露 Frodo 模仿Jake Wharton’s Hugo，使用Java切面编程的Android 日志工具库 RxIAPv3 一个用Rx封装后的 Android App内购支付库，提供几个购买、消费和商品清单列表的Rx方法。 RxFile RxCamera RxJava style API for android camera RxPermissions Android runtime permissions powered by RxJava Resource Homepage http://reactivex.io/ RxJava 操作符动画效果演示 http://rxmarbles.com/ Testing asynchronous RxJava code using Mockito RxRecipes: Wrap your way to Rx 主要讲 fromCallable() fromAction() 替换Rx中的接口； Rxify : The Anti Cache-then-Network OR Network-then-Cache Problem 使用RX concat onErrorResumeNext onErrorReturn 处理访问网络失败后返回本地缓存的机制。 Book: RxJavaEssentials.pdf 【英文】 RxJava Essentials 中文翻译版 官方文档 Doc for operators (操作符相关文档) Scheduler官方文档 【待研究】 RxJava Wiki 文档 Implementing Your Own Operators 【实现自己的操作符】【重点】 翻译文档 ReactiveX/RxJava文档中文版 一些高质量学习资源 Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#0 【重点】 Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#1【重点】 给 Android 开发者的 RxJava 详解 使用RxJava构造Android清晰框架 Awesome-RxJava 一些RxJava的资料集合 【最爱】 Grokking RxJava, Part 1: The Basics 【英文】 操作符 操作符相关文章 木水川的博客 【强力推荐】 throttleFirst():RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) FlatMap无序，concatMap有序排列FlatMap应用场景： 1. 抽取对象的集合并逐个输出； 2. 嵌套回调解决回调地狱的问题； Student[] students = ...; Subscriber&lt;Course> subscriber = new Subscriber&lt;Course>() { @Override public void onNext(Course course) { Log.d(tag, course.getName()); } ... }; Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course>>() { @Override public Observable&lt;Course> call(Student student) { return Observable.from(student.getCourses()); } }) .subscribe(subscriber); first() vs. takeFirst() The difference between the two calls is that first() will throw a NoSuchElementException if none of the sources emits valid data, whereas takeFirst() will simply complete without exception. .groupBy()一旦产生的Observable被订阅，分组产生的GroupedObservable就开始缓存，没有被订阅（处理）的GroupedObservable可能会引起内存泄露，故，对不想处理的GroupedObservable，使用take(0)释放缓存； combineLatest 笔记操作符分类 合并型 combineLatest join merge mergeDelayError switchOnNext操作符是把一组Observable转换成一个Observable zip操作符是把两个observable提交的结果，严格按照顺序进行合并 截取添加分类型 startWith buffer debounce window groupBy distinct elementAt filter ofType first last single sample skip skipLast take 错误处理 onErrorReturn onErrorResumeNext return Observerable onExceptionResumeNext 改变流程走向 retry retryWhen 其他 concatMap cast scan ignoreElements操作符忽略所有源Observable产生的结果，只把Observable的onCompleted和onError事件通知给订阅者 进价问题研究 线程控制 Scheduler在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn() vs observeOn() 对事情线程的影响； subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() { @Override public void call() { progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 } }) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); Backpressure 【待研究】 生产速度比消费快,抛出MissingBackpressureException的异常官方对Backpressure的介绍及对应的解决方案 使用案例 省略subscribeOn()和observeOn()在切换线程时在Android开发的时候频繁使用subscribeOn()和observeOn()，后台线程和UI线程切换这可以可以抽离出来（文章：避免打断链式结构：使用.compose( )操作符） &lt;T> Transformer&lt;T, T> applySchedulers() { return new Transformer&lt;T, T>() { @Override public Observable&lt;T> call(Observable&lt;T> observable) { return observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); } }; } 使用debounce做textSearch用简单的话讲就是当N个结点发生的时间太靠近（即发生的时间差小于设定的值T），debounce就会自动过滤掉前N-1个结点。解决频繁改变，导致的多余的网络访问（场景举例：删除多余信息） RxTextView.textChangeEvents(inputEditText) .debounce(400, TimeUnit.MILLISECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;TextViewTextChangeEvent>() { @Override public void onCompleted() { log.d("onComplete"); } @Override public void onError(Throwable e) { log.d("Error"); } @Override public void onNext(TextViewTextChangeEvent onTextChangeEvent) { log.d(format("Searching for %s", onTextChangeEvent.text().toString())); } }); RxJava代替EventBus，Otto：RxBus 用RxJava实现事件总线(Event Bus) Implementing an Event Bus With RxJava - RxBus 延迟Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Long>() { @Override public void onCompleted() { log.d ("completed"); } @Override public void onError(Throwable e) { log.e("error"); } @Override public void onNext(Long number) { log.d ("hello world"); } }); schedulePeriodically轮询Observable.create(new Observable.OnSubscribe&lt;String>() { @Override public void call(final Subscriber&lt;? super String> observer) { Schedulers.newThread().createWorker() .schedulePeriodically(new Action0() { @Override public void call() { observer.onNext(doNetworkCallAndGetStringResult()); } }, INITIAL_DELAY, POLLING_INTERVAL, TimeUnit.MILLISECONDS); } }).subscribe(new Action1&lt;String>() { @Override public void call(String s) { log.d("polling….”)); } }) 使用RxJava处理复杂的Url操作query("Hello, world!") .flatMap(urls -> Observable.from(urls)) //拆分List .flatMap(url -> getTitle(url)) // 获取网站头名称 .filter(title -> title != null) // 过滤掉title == null .take(5) // 取前5个 .doOnNext(title -> saveTitle(title)) // 在得到结果前保存标题到Disk里 .subscribe(title -> System.out.println(title)); 按顺序从内存–&gt;文件–&gt;网络获取资源,成功程序停止final Observable&lt;String> memory = Observable.create(new Observable.OnSubscribe&lt;String>() { @Override public void call(Subscriber&lt;? super String> subscriber) { if (memoryCache != null) { subscriber.onNext(memoryCache); } else { subscriber.onCompleted(); } } }); Observable.concat(memory, disk, network) .first() .subscribeOn(Schedulers.newThread()) .subscribe(s -> { memoryCache = "memory"; System.out.println("--------------subscribe: " + s); }); 多个异步并发处理完，再更新 Observable.merge(observable1, observable2) .subscribeOn(Schedulers.newThread()) .subscribe(System.out::println); flatMap处理异步嵌套异步（Callback Hell）NetworkService.getToken("username", "password") .flatMap(s -> NetworkService.getMessage(s)) .subscribe(s -> { System.out.println("message: " + s); }); 按钮防抖RxView.clicks(findViewById(R.id.btn_throttle)) .throttleFirst(1, TimeUnit.SECONDS) .subscribe(aVoid -> { System.out.println("click"); }); 响应式的界面勾选了某个checkbox，自动更新对应的preference SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this); RxSharedPreferences rxPreferences = RxSharedPreferences.create(preferences); Preference&lt;Boolean> checked = rxPreferences.getBoolean("checked", true); CheckBox checkBox = (CheckBox) findViewById(R.id.cb_test); RxCompoundButton.checkedChanges(checkBox) .subscribe(checked.asAction()); Fragment 旋转缓存【待研究】 @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); /*.cache()操作符： 当第一个subscribe订阅的时候，才会连接原始Observable，缓存事件, 重发给后续订阅的subscribe 值得注意的事， 它和使用了.replay().publish()操作符的ConnectableObservable的不同。 另外，为了避免内存开销，不建议缓存大量事件*/ setRetainInstance(true); cacheObservable = weatherManager.getWeather().cache(); } @Override public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); cacheObservable.subscribe(/*your subscribe*/); } 测试调试 【待研究】 Unit Testing RxJava Observables and Subscriptions Debugging RxJava on Android 实战笔记 RxJava-Android-SamplesRetrofitFragment.javaObservable.zip / Observable.just gist code DebounceSearchEmitterFragment.javaRxTextView.textChangeEvents gitst code BufferDemoFragment.java RxView.clickEvents/ .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 private Subscription _getBufferedSubscription() { return RxView.clickEvents(_tapBtn) .map(new Func1&lt;ViewClickEvent, Integer>() { @Override public Integer call(ViewClickEvent onClickEvent) { Timber.d("--------- GOT A TAP"); _log("GOT A TAP"); return 1; } }) .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;Integer>>() {} ）； PublishSubject PublishSubject&lt;Float> _resultEmitterSubject = PublishSubject.create(); _subscription = _resultEmitterSubject.asObservable().subscribe(new Action1&lt;Float>() { @Override public void call(Float aFloat) { _result.setText(String.valueOf(aFloat)); } }); _resultEmitterSubject.onNext(num1 + num2); @OnTextChanged PollingFragment.javaCompositeSubscription / interval /doOnSubscribe /repeatWhen /Observable.timer _subscriptions.add(// Observable.just(1) .repeatWhen(new RepeatWithDelay(pollCount, pollingInterval)) .subscribe(new Action1&lt;Object>() { @Override public void call(Object o) { _log(String.format(Locale.US, "Executing polled task now time : [xx:%02d]", _getSecondHand())); } }, new Action1&lt;Throwable>() { @Override public void call(Throwable e) { Timber.d(e, "arrrr. Error"); } }) ); _subscriptions.add(// Observable.interval(INITIAL_DELAY, POLLING_INTERVAL, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String>() { @Override public String call(Long heartBeat) { return _doNetworkCallAndGetStringResult(heartBeat); } }).take(pollCount) .doOnSubscribe(new Action0() { @Override public void call() { _log(String.format("Start simple polling - %s", _counter)); } }) .subscribe(new Action1&lt;String>() { @Override public void call(String taskName) { _log(String.format(Locale.US, "Executing polled task [%s] now time : [xx:%02d]", taskName, _getSecondHand())); } }) ); public class RepeatWithDelay implements Func1&lt;Observable&lt;? extends Void>, Observable&lt;?>> { private final int _repeatLimit; private final int _pollingInterval; private int _repeatCount = 1; RepeatWithDelay(int repeatLimit, int pollingInterval) { _pollingInterval = pollingInterval; _repeatLimit = repeatLimit; } // this is a notificationhandler, all we care about is // the emission "type" not emission "content" // only onNext triggers a re-subscription @Override public Observable&lt;?> call(Observable&lt;? extends Void> inputObservable) { // it is critical to use inputObservable in the chain for the result // ignoring it and doing your own thing will break the sequence return inputObservable.flatMap(new Func1&lt;Void, Observable&lt;?>>() { @Override public Observable&lt;?> call(Void blah) { if (_repeatCount >= _repeatLimit) { // terminate the sequence cause we reached the limit _log("Completing sequence"); return Observable.empty(); } // since we don't get an input // we store state in this handler to tell us the point of time we're firing _repeatCount++; return Observable.timer(_repeatCount * _pollingInterval, TimeUnit.MILLISECONDS); } }); } } RxBusDemoFragment.javaConnectableObservable / SerializedSubjectgist代码 private final Subject&lt;Object, Object> _bus = new SerializedSubject&lt;>(PublishSubject.create()); _bus.onNext(object); _bus.hasObservers(); ConnectableObservable&lt;Object> tapEventEmitter = _rxBus.toObserverable().publish(); _subscriptions// .add(tapEventEmitter.subscribe(new Action1&lt;Object>() { @Override public void call(Object event) { if (event instanceof RxBusDemoFragment.TapEvent) { _showTapText(); } } })); stream.buffer(stream.debounce(1, TimeUnit.SECONDS)); _subscriptions.add(tapEventEmitter.connect()); FormValidationCombineLatestFragment.java private Observable&lt;CharSequence> _numberChangeObservable = RxTextView.textChanges(_email_editText).skip(1); _subscription = Observable.combineLatest(_emailChangeObservable, _passwordChangeObservable, _numberChangeObservable, new Fun3...) PseudoCacheMergeFragment.javaObservable.merge();TimingDemoFragment.java Observable.timer(2, TimeUnit.SECONDS)// //.just(1).delay(2, TimeUnit.SECONDS)// //.interval(1, TimeUnit.SECONDS)// //.interval(0, 1, TimeUnit.SECONDS)// //.interval(3, TimeUnit.SECONDS).take(5)// ExponentialBackoffFragment.java Observable// .error(new RuntimeException("testing")) // always fails .retryWhen(new RetryWithDelay(5, 1000)) //当错误时调用，适用于错误处理 //1-4 指数的递增延迟 Observable.range(1, 4)// .delay(new Func1&lt;Integer, Observable&lt;Integer>>() { @Override public Observable&lt;Integer> call(final Integer integer) { // Rx-y way of doing the Fibonnaci :P return MathObservable// .sumInteger(Observable.range(1, integer)) .flatMap(new Func1&lt;Integer, Observable&lt;Integer>>() { @Override public Observable&lt;Integer> call(Integer targetSecondDelay) { return Observable.just(integer) .delay(targetSecondDelay, TimeUnit.SECONDS); } }); } })// RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 其他 RxJS RxJS The Reactive Extensions for JavaScript http://reactivex.io Big list of functions 常用函数的例子 Creating Observables 产生Observable的方法 The introduction to Reactive Programming you’ve been missing 对应的 Demo 参考 RxJava使用场景小结 使用RxJava构造Android清晰框架]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 学习积累]]></title>
    <url>%2F2017%2F01%2F08%2F2017-01-08-gradle-note%2F</url>
    <content type="text"><![CDATA[基础 Gradle Guides Creating New Gradle Builds 命令 # 多任务顺序执行 gradlew clean jar Groovy 基本D:\workspace\project\gradle\basic-demo\build.gradle Gradle Task 语法 D:\workspace\project\gradle\basic-demo\build.gradle task create task dependon myTask.doFirst 依赖管理1. 查看当前依赖关系gradlew :sample:dependencies +--- project :jobslibs | +--- com.android.support:appcompat-v7:27.1.1 | | +--- com.android.support:support-annotations:27.1.1 | | +--- com.android.support:support-core-utils:27.1.1 | | | +--- com.android.support:support-annotations:27.1.1 | | | \--- com.android.support:support-compat:27.1.1 | | | +--- com.android.support:support-annotations:27.1.1 | | | \--- android.arch.lifecycle:runtime:1.1.0 | | | +--- android.arch.lifecycle:common:1.1.0 | | | \--- android.arch.core:common:1.1.0 | | +--- com.android.support:support-fragment:27.1.1 | | | +--- com.android.support:support-compat:27.1.1 (*) 2. 排除传递依赖参考：Gradle依赖项学习总结 指定某个模块 dependencies { compile ('org.codehaus.cargo:cargo-ant:1.3.1') { exclude group: 'xml-apis', module: 'xml-apis' } compile 'xml-apis:xml-apis:2.0.2' } 中断引用库的依赖，不引用引用的引用 dependencies { compile ('org.codehaus.cargo:cargo-ant:1.3.1') { transitive=false } } 版本冲突 Force强制使用某个模块 configurations.all { resolutionStrategy { force 'org.hamcrest:hamcrest-core:1.3' } } dependencies { androidTestCompile('com.android.support.test:runner:0.2') androidTestCompile('com.android.support.test:rules:0.2') androidTestCompile('com.android.support.test.espresso:espresso-core:2.1') } 配置相关强制刷新依赖 gradlew --refresh-dependencies assemble 调试查看属性(ext)设置属性 gradle.properties description = "A trivial Gradle build" version = "1.0" 查看 ./gradlew properties 任务调试./gradlew task_cmd --scan 打印堆栈信息 # --stacktrace ./gradlew task_cmd -s # --full-stacktrace ./gradlew task_cmd -S 自定义日志级别输出 # out quiet > level log gradle -q task_cmd # out info > level log gradle -i task_cmd 使用gradle内置 logger 日志 task logTask { doLast { println 'Hello world!' logger.quiet('quiet log ...') logger.error('error log ...') logger.lifecycle('lifecycle log info ...') logger.info('info log...') logger.debug('debug ... ') } } 获取Task命令的命令选项，例如： gradlew help --task init 输出如下： > Task :help Detailed task information for init Path :init Type InitBuild (org.gradle.buildinit.tasks.InitBuild) Options --dsl Set alternative build script DSL to be used. Available values are: groovy kotlin --test-framework Set alternative test framework to be used. Available values are: spock testng --type Set type of build to create. Available values are: basic groovy-application groovy-library java-application java-library pom scala-library Description Initializes a new Gradle build. Group Build Setup 附录博客 构建工具-Gradle Gradle 完整指南（Android） android Gradle 基础的使用看 Gradle实战及学习建议 Gradle for android 的一些学习资源的罗列 Writing Custom Plugins gradle官方文档，自定义插件拿到Project类，就可以拿到几乎所有工程配置的属性和方法，然后发挥想象控制你的工程。 资料 Chapter 23. Dependency Management 【待研究】 Chapter 45. The Java Plugin DependencyHandler Gradle Plugin User Guide Android Studio 官网提供的Gradle实用教程 Android Plugin DSL Reference build.gradle android{….} API GoogleAndroid Studio Project Site Gradle Plugin User Guide Android BuildType的可配置属性 插件 hugo JakeWharton 不必介绍了。项目中使用Gradle plugin 和自定义Task 顺便学习一些Process Annotation. https://plugins.gradle.org/ plugins gradle plugin确定 开源插件 gradle-android-junit-jacoco-plugin可以生成代码单元测试覆盖率报告的 Gradle 插件。 gradle-android-javadoc-plugin可以生成 java doc 的 Gradle 插件。 gradle-android-apk-size-plugin可以将 Apk 大小记录到 CSV 文件的 Gradle 插件。 android-fat-aar Gradle script that allows you to merge and embed dependencies in generted aar file. ProperDroid simplifies the way that config different variant on your project. dexcount-gradle-plugin A Gradle plugin to report the number of method references in your APK on every build. 使用案例 建立企业内部maven服务器并使用Android Studio发布公共项目。 Android 将Android项目打包成aar文件并在其他项目中引用,打包成jar包 问题解决 依赖更新项目依赖的远程包如果有更新，会有提醒或者自动更新吗？ 不会的，需要你手动设置changing标记为true，这样gradle会每24小时检查更新，通过更改resolutionStrategy可以修改检查周期。 configurations.all { // check for updates every build resolutionStrategy.cacheChangingModulesFor 0, 'seconds' } dependencies { compile group: "group", name: "projectA", version: "1.1-SNAPSHOT", changing: true } 之前上传aar同一版本到maven仓库，但依赖却没有更新，该怎么办呢?可以直接删除本地缓存，缓存在~/.gradle/caches目录下，删除缓存后，下次运行就会自动重新下载远程依赖了。 Gradle下载慢5个解决方案 原因: 由于 services.gradle.org 国内下载速度很慢(一般为45kb/s), 而每个gradle-xx.xx.-all.zip 版本至少60MB, 也就正常是需要40分钟左右,花都谢了 #Mon Oct 22 23:20:47 CST 2018 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists #把*4.6-all.zip 改为4.6-bin.zip 需要下载的更小 distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip # 解决Gradle下载慢的问题 #方案一：使用本地缓存，修改.. distributions/gradle-4.6-all.zip 为本地已经有的版本 #方案二 1.把下载好的 gradle-x.x.x-all.zip 如：gradle-4.6-all.zip # 1.1直接复制到 gradle-wrapper.properties 同在目录 # 1.2 如下： #distributionUrl=gradle-4.6-all.zip #方案三：引用本地文件地址 #1. Window #distributionUrl=file:///E://software//2.coder//env//gradle-4.6-all.zip #2. Unix #distributionUrl=file\:/tmp/gradle-2.2.1-all.zip #方案四：手动（国内或者浏览器）下载一般比较快，解压到gradle缓存目录 # 参考：https://www.cnblogs.com/rainboy2010/p/7062279.html # 1. 缓存目录 # 1.1 window默认 : C:\Users\xxx(用户名)\.gradle\wrapper\dists\gradle-3.3-all\55gk2rcmfc6p2dg9u9ohc3hw9 # 1.2 unix默认： ~/.gradle/... # 2. 获取base36值，参考FileTest#getDistMD5方法 #messageDigest = MessageDigest.getInstance("MD5"); #messageDigest.update(distributionUrl.getBytes()); #String str = new BigInteger(1, messageDigest.digest()).toString(36); # 3. 在dist\gradle-3.3-all\ 下 # 3.1 新建文件，名为获取base36值 # 3.2 拷贝下载好的gradle-x.x.x-all.zip 到新建的文件，并解压 #方案五： 直接更改 distributionUrl的下载路径为国内服务器，例如：http://mirrors.flysnow.org/ #如：distributionUrl=http\://mirrors.flysnow.org/gradle/gradle-4.1-bin.zip #注意 1. 镜像网站有指定版本；2. 不要设置代理 #如果你在 gradle.properties 配置了代理，请添加一个不走代理的配置，否则 gralde 无法安装 #systemProp.http.proxyHost=mirrors.neusoft.edu.cn #systemProp.http.proxyPort=80 ## 添加不走代理的 host，会影响 package 的安装 #systemProp.http.nonProxyHosts=172.1.1.227|localhost|mirrors.flysnow.org 依赖下载慢，使用阿里云国内镜像单个项目生效 buildscript { repositories { maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } maven{ url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'} } dependencies { classpath 'com.android.tools.build:gradle:2.2.3' } } allprojects { repositories { maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } maven{ url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'} } } 对所有项目生效，在USER_HOME/.gradle/下创建init.gradle文件 allprojects{ repositories { def ALIYUN_REPOSITORY_URL = 'http://maven.aliyun.com/nexus/content/groups/public' def ALIYUN_JCENTER_URL = 'http://maven.aliyun.com/nexus/content/repositories/jcenter' all { ArtifactRepository repo -> if(repo instanceof MavenArtifactRepository){ def url = repo.url.toString() if (url.startsWith('https://repo1.maven.org/maven2')) { project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL." remove repo } if (url.startsWith('https://jcenter.bintray.com/')) { project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL." remove repo } } } maven { url ALIYUN_REPOSITORY_URL url ALIYUN_JCENTER_URL } } } gradle &lt;=&gt; maven1. gradle -&gt; mavenbuild.gradle apply plugin: 'java' apply plugin: 'maven' group = 'com.101tec' version = '0.7-dev' sourceCompatibility = 1.6 task writeNewPom < { pom { project { inceptionYear '2008' licenses { license { name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' distribution 'repo' } } } }.writeTo("$buildDir/pom.xml") }]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 架构相关笔记]]></title>
    <url>%2F2016%2F12%2F27%2F2016-12-27-Archtecture-for-Android%2F</url>
    <content type="text"><![CDATA[学习资源 Google 官方 android-architecture-components Google I/O Android App The Google I/O Android App Data Binding Guide Android Architecture Blueprints 【重点】 其他 Android Boilerplate 一些常用开源框架的集合 【重点】 Android Guidelines Architecture and code guidelines 2000+【重点】 常用的架构及教程 Google官方MVP+Dagger2架构详解 Android-CleanArchitectureRelative blog Architecting-android-the-clean-way EffectiveAndroidUI Retrofit2 Retrofit2 使用注意点总结 Tutorial Getting Started and Creating an Android Client 深入浅出 Retrofit，这么牛逼的框架你们还不来看看？ Dagger2 https://google.github.io/dagger/ Providing test doubles with Dagger 1 and Dagger 2 Dagger2 Example 简明清晰的Dagger2教程 ColorfulNews Dagger2 项目 Dagger2 Android 告别Dagger2模板代码：Dagger Android使用详解 官方网址 Android - Dagger2使用详解 Sample_dagger2 图片加载 Glide 谷歌官方推荐使用 Glide 使用的详解教程 英文版 Glide 系列预览中文版 Picasso square 开源 12000+ star Picasso学习笔记 Fresco-Source-Analysis FluxFacebook 华人工程师提出的一种软件架构 Tutorial：Flux Architecture on Android Flux Architecture on Android 使用Otto在Android上简单是实现Demo Facebook官网对flux的介绍 【需要翻墙】 MVP MVP 简单的介绍, 及下面介绍推荐相关MVP教程 MVP Wiki 【英文】 Android中的MVP模式，带实例 MVP Android Example github 3700+ star Google Sample: Android Architecture Blueprints 之 MVP MVVM MVVM wiki 官方学习资料Data Binding Guide MVVMLight 对DataBind库进行优化，使MVVM用起来更加的简洁。 【推荐】 Approaching Android with MVVM 【英文】 开源工具库 truetime-android 一个可以在不同App,不同设备得到唯一的时间掺照物的库，IOS也有相同的库； Mortar 【待研究】 Scoop 【待研究】 任务处理 Android-Job Android library to handle jobs in the background. 页面关系的处理 alibaba/ARouter 典型应用场景 :从外部URL映射到内部页面，以及参数传递与解析跨模块页面跳转，模块间解耦拦截跳转过程，处理登陆、埋点等逻辑跨模块API调用，模块间解耦(注册ARouter服务的形式，通过接口互相调用) 阿里ARouter路由实现模块化开发流程 Cicerone 一个Activity/fragment/ViewGroup的路由库 系列文章问答 Android 开发有什么好的架构么? 【经典】 博客架构工具使用 不容错过，最全的安卓架构合集【从零开始搭建android框架系列（2）】 对应的Github地址 AndroidArchitectureCollection RxJava+Retrofit+OkHttp 懒人方式使用一 Google官方MVP+Dagger2架构详解 实战项目架构经验 The Making of Falcon Pro 3 三周开发，发布20天没有推广，安装量6000的经验介绍 【英文】 从360手机卫士的开发历程看如何实施大型移动应用开发 从整体上讲述软件开发流程及管理，清晰而且基本每个例子都很经典。看了第二次还是有很多收货。【重点】 英语流利说 Android 架构演进 逻辑条理清晰。 Android Application Architecture 译文 Architecting Android…The evolution 很经典的安卓架构文章，惊叹其架构层级之清晰，解耦之精妙，但是很难吃透不适合入门，会是整个软件架构很复杂 【英文】 从零开始的Android新项目1 - 架构搭建篇 简洁的概括了Android依赖库分层 开源项目线上商用项目 【重点研读】 Kickstarter for Android 一个用视频推销产品的电商APP，同时开源IOS，github 3300+ star官网：https://www.kickstarter.com/mobile Telegram 开源的Android聊天应用,有IOS,WP开源代码多平台Star 7000+ plaid 12279 start 加星项目 Timber Material Design Music Player github star 2200+【整体框架过了一遍，很多细节需要深入看】 Notes Material Design Notes App WordPress-Android Google 开源 Topeka for Android Material Design 的演示 APP 源代码 Google Santa Tracker for Android Features: A beautiful materially designed village 6 exciting games 2 interactive Android Wear watchfaces (with sound!) Videos, animations and more. 有用的功能性项目 Rox-Android一个基于Foursquare，根据位置信息及个人和朋友的喜好，推荐可能感兴趣的地方并提供导航 tickerCamera 这是一款集成了相机,图片裁剪,给图片贴贴图打标签的APP。 Tabby 手机App跳转到Chrome，设置样式及对应的菜单选项 用户引导帮助开源库 Highlight Ahoy-onboarding 其他Douya开源的 Material Design 豆瓣客户端（A Material Design app for douban.com） MusicStreamer mr-mantou-android 简单的架构及集合了国内一些第三方服务 扩展学习 Google首席软件工程师Joshua Bloch谈如何设计一款优秀的API【附PPT】]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推送实践]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-jpush-note%2F</url>
    <content type="text"><![CDATA[极光推送介绍极光推送自动集成官方 Android SDK 集成指南集成实践详细步骤注册极光账号 并配置Android 程序包名配置了jcenter支持buildscript { repositories { jcenter() } } allprojects { repositories { jcenter() } } 集成依赖android { defaultConfig { applicationId &quot;com.xxx.xxx&quot; //JPush上注册的包名. ndk { //选择要添加的对应cpu类型的.so库。 abiFilters &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;armeabi-v8a&#39; // 还可以添加 &#39;x86&#39;, &#39;x86_64&#39;, &#39;mips&#39;, &#39;mips64&#39; } manifestPlaceholders = [ JPUSH_PKGNAME : applicationId, JPUSH_APPKEY : &quot;你的appkey&quot;, //JPush上注册的包名对应的appkey. JPUSH_CHANNEL : &quot;developer-default&quot;, //暂时填写默认值即可. ] } } dependencies { compile &#39;cn.jiguang.sdk:jpush:3.0.0&#39; // 此处以JPush 3.0.0 版本为例。 compile &#39;cn.jiguang.sdk:jcore:1.0.0&#39; // 此处以JCore 1.0.0 版本为例。 } Manifest自定义广播设置 &lt;!-- ************************************* --> &lt;!-- The begin setting of JPush --> &lt;!-- ************************************* --> &lt;!-- User defined. 用户自定义的广播接收器--> &lt;receiver android:name=".broadcast.JPushReceive" android:enabled="true"> &lt;intent-filter> &lt;!--Required 用户注册SDK的intent--> &lt;action android:name="cn.jpush.android.intent.REGISTRATION" /> &lt;!--Required 用户接收SDK消息的intent--> &lt;action android:name="cn.jpush.android.intent.MESSAGE_RECEIVED" /> &lt;!--Required 用户接收SDK通知栏信息的intent--> &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_RECEIVED" /> &lt;!--Required 用户打开自定义通知栏的intent--> &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_OPENED" /> &lt;!-- 接收网络变化 连接/断开 since 1.6.3 --> &lt;action android:name="cn.jpush.android.intent.CONNECTION" /> &lt;category android:name="${JPUSH_PKGNAME}" /> &lt;/intent-filter> &lt;/receiver> &lt;!-- ************************************* --> &lt;!-- The end setting of JPush --> &lt;!-- ************************************* --> 自定义广播接收器官方Demo代码 JPushReceive.java 初始化public class ExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); JPushInterface.setDebugMode(true); JPushInterface.init(this); } } 测试API集成是否成功 启动应用程序，出现如下日志，说明SDK运行正常[JPushInterface] action:init - sdkVersion:3.0.0, buildId:319 pushcore I/JIGUANG-JCore: [ConnectingHelper] Login succeed 运行App，到控制台发送测试推送 【重点-填坑】如果没有收到推送重启手机， 日志会打印某些jni调用的代码未找到； 经验集成SDK，配置完成后需等待一段时间，功能才会见效； 进价别名与标签把绑定关系保存到 JPush 服务器端 使用案例： 动态标签 根据角色和地域等相关的信息动态设置标签和别名，从而区分收到推送的客户；相关方法JPushInterface.setAlias(Context context,String alias, TagAliasCallback CallBack); JPushInterface.setTags(Context ctx,Set&lt;String&gt; tags, TagAliasCallback CallBack); JPushInterface.setAliasAndTags(getApplicationContext(), null, (Set&lt;String&gt;) msg.obj, mTagsCallback); 温馨提示 设置标签别名请注意处理call back结果。只有call back 返回值为 0 才设置成功，才可以向目标推送。否则服务器 API 会返回1011错误。 RegistrationID把绑定关系保存到开发者应用服务器中 客户端设置通知栏样式 铃声、震动显示图标替换默认的通知栏样式。 自定义通知栏样式 /** * 设置通知提示方式 - 基础属性 */ private void setStyleBasic() { BasicPushNotificationBuilder builder = new BasicPushNotificationBuilder(PushSetActivity.this); builder.statusBarDrawable = R.drawable.ic_launcher; builder.notificationFlags = Notification.FLAG_AUTO_CANCEL; //设置为点击后自动消失 builder.notificationDefaults = Notification.DEFAULT_SOUND; //设置为铃声（ Notification.DEFAULT_SOUND）或者震动（ Notification.DEFAULT_VIBRATE） JPushInterface.setPushNotificationBuilder(1, builder); Toast.makeText(PushSetActivity.this, &quot;Basic Builder - 1&quot;, Toast.LENGTH_SHORT).show(); } /** * 设置通知栏样式 - 定义通知栏Layout */ private void setStyleCustom() { CustomPushNotificationBuilder builder = new CustomPushNotificationBuilder(PushSetActivity.this, R.layout.customer_notitfication_layout, R.id.icon, R.id.title, R.id.text); builder.layoutIconDrawable = R.drawable.ic_launcher; builder.developerArg0 = &quot;developerArg2&quot;; JPushInterface.setPushNotificationBuilder(2, builder); Toast.makeText(PushSetActivity.this, &quot;Custom Builder - 2&quot;, Toast.LENGTH_SHORT).show(); } private void setAddActionsStyle() { MultiActionsNotificationBuilder builder = new MultiActionsNotificationBuilder(PushSetActivity.this); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;first&quot;, &quot;my_extra1&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;second&quot;, &quot;my_extra2&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;third&quot;, &quot;my_extra3&quot;); JPushInterface.setPushNotificationBuilder(10, builder); Toast.makeText(PushSetActivity.this, &quot;AddActions Builder - 10&quot;, Toast.LENGTH_SHORT).show(); } 错误处理gradle.properties 增加 android.useDeprecatedNdk=true 使用旧版本的ndk集成方式,不添加会报错: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin.]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>第三方SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Tutorial]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-hexo-tutorial%2F</url>
    <content type="text"><![CDATA[Hexo 相关教程 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hexo安装环境准备 Git / Node.js hexo官方教程两个初始化命令hexo init 类似git init 需要新建目录保存博文信息； 执行命令会在当前目录下生产如下文件：├── _config.yml #全局配置文件 ├── node_modules #Hexo插件（Node.js 插件默认安装目录） ├── package.json #Node 工程的依赖和基本信息 ├── scaffolds #模板 ├── source #博客正文源文件 └── themes 【重点】如果你有配置，会覆盖你原来的配置；npm install #安装package.json 下面的依赖包hexo http://localhost:4000/ 检查是否安装成功测试hexo是否正确安装hexo init cd folder npm install npm install hexo-server --save hexo server # 访问是否正常显示 http://localhost:4000/ hexo 配置hexo-theme-next主题的配置 最强主题基本上所有的配置信息都能满足,优雅,文档齐全 安装 Next主题 基本和教程走一边,就可以得到一个很牛的网站了 三种主题样式的选择： hexo/themes/next/_config.xml 搜索 scheme 网站logo设置 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。next主题：将图片放在next主题source/images目录下在next主题配置文件中添加：favicon: images/favicon.ico 设置首页是否为摘录（不显示所有内容）{your-hexo-dir}/themes/next/_config.yml auto_excerpt true 注册云存储存储图片防止图片链接失效,和在博客迁移过程中导致的图片获取异常,丢失. 统一管理文章中的图片 七牛 域名绑定 设置域名的指向的地址 在源文件中增加github page 的设置文件 source/CNAME 并增加你的域名,不带www的,例如:’taobao.com’Hexo 显示访问次数代码高亮 hexo-prism-plugin$hexo_dir/_config.yml Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sitesMore info: Deployment $ hexo deploy 常用的方法命令简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 一般的发布步骤hexo clean #删除产生的文件和缓存 hexo (g)generate # 生成静太文件 hexo (d)deploy # 发布网页 日常维护命令npm update -g hexo #hexo 更新 cd /{you-blog-dir}/theme/next git pull #更新主题代码 npm update # 更新插件 高级玩法添加网易云音乐由于markdown支持HTML, 打开网页版网易云音乐–&gt; 点击生成外链播放器 –&gt; 直接粘贴网易云音乐的外链接iframe代码 添加high一下效果整个页面渐进式摇摆,摇摆 复制header.swig的代码到{your-hexo-dir}/themes/next/layout/_custom/header.swig 本地刷新在菜单栏附近出现High一下 点击查看效果 问题解决 ERROR Plugin load failed: hexo-server 解决: npm install hexo-server ERROR Deployer not found: Git 解决： npm install hexo-deployer-git –save Cannot GET 解决 npm install 参考 GitHub Pages 绑定来自阿里云的域名 手把手教你建github技术博客 hexo下新建页面下如何放多个文章？ 博客推广——提交搜索引擎 动动手指，不限于NexT主题的Hexo优化（SEO篇）]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android测试资源集合,测试工具,测试开源项目]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-android-test%2F</url>
    <content type="text"><![CDATA[测试第三方服务 国内 https://bugly.qq.com/v2/ 腾讯的bugly 免费, 而且相当好用 腾讯优测云 提供真机测试和漏洞分析 Testin MTC 易测云 国外 TestCloud Testdroid Nimbledroid Automated performance analysis website Test bird APP和手游测试 kobiton 免费的在线真机测试 第三方性能采集SDK OneAPM 听云 自动化测试 CircleCI 一个基于Github的自动化测试，单元测试工具，提供一个免费的私有仓库。 Google官方学习资料 Best Practices for Testing 【最新/重点】 Android Testing Support library (ATSL) 【重点】相关视频： Android Testing (Android Dev Summit 2015) youtube 2015年视频 Developer API Testing Concepts 优秀博客 Java 测试 Leveraging product flavors in Android Studio for hermetic testing 与之对应的 codelab学习地址笔记： Just Say No to More End-to-End Tests two JUnit Rules @rule will be launched before @Before. The ActivityTestRule is a rule that provides functional testing of a single Activity. Test coverage report for Android application 使用jacoco-android plugin in a build.gradle进行测试覆盖率报告 Android单元测试在蘑菇街支付金融部门的实践 很详细介绍了单元测试在实践操作中的使用 RxJava Test Unit Testing RxJava Observables and Subscriptions Unit Testing RxJava Observables Unit Testing with RxJava UI测试 小心！做UI自动化一定要跨过这些坑 【待看】 测试框架 Unit Testing Junit4 Github A programmer-oriented testing framework for Java.http://junit.org/junit4/ Mockito Tasty mocking framework for unit tests in Java JMockit An automated testing toolkit for Java对比： mockito不能mock static method和final class、final method，JMockit可以；对比Mockito和JMockit的文章 PowerMock 一个可以Mock静态类的开源库 Tools for UI Testing: Robotium, Appium, Calabash, Robolectric. UI Testing Espresso Android 官方推荐使用的UI测试库 UIAutomator 可以夸应用进行测试 Robolectric is a unit test framework that de-fangs the Android SDK jar so you can test-drive the development of your Android app. Tests run inside the JVM on your workstation in seconds More RoboSpock Github A testing framework which brings powers of Spock and Groovy to Android app testing http://robospock.org Hamcrest matchersWhat is Hamcrest?Hamcrest is a library of matchers, which can be combined in to create flexible expressions of intent in tests. They’ve also been used for other purposes. Calabash 特点: 支持多种平台，代码复用性强:代码同时支持Android 和iOS, Web也有一定的支持; 语法更接近自然语音,易懂也易维护; 纯黑盒测试。 开源库 Collection awesome-android-testing collection of android test info 【重点】 Sample android-gradle-java-template Gradle + Android Studio + Robolectric + Espresso + Mockito + EasyMock/PowerMock + JaCoCo Demo Android-Clean-Testing Android Testing Sample Project robotium-showcase This example shows how to use Robotium with ActvitityTestRule and @Test annotation, it means in Google’s Espresso way. Google Sample android-testing-templates android-testing A collection of samples demonstrating different frameworks and techniques for automated testing Tools 测试工具Spector Android/IOS 调试工具 漂亮的UIsquare/spoon在adb devices 检测到的设备跑测试程序，并提供截屏，文件，数据库操作：最最重要的是生成简单明了的测试报告： Android Studio 2.2 Preview new feature: Espresso Test Recorder 菜单/run/Recorder Expresso Test 选项可以记录你的操作并转化为Espresso 的测试代码 APK Analyzer 菜单/build/Analyzer APK 提供APK大小分析工具，清楚的知道代码体积变换的趋势。 screengrab 当UI Tests 时自动化截屏STF 远程控制，一台电脑控制测试多个测试设openstf.github.io Control and manage Android devices from your browser Vysor 用Chrome浏览器控制你的Android手机 Vysor让你在电脑上完全控制android手机屏幕镜像 Vysor 情怀玩法 （番外篇） 开发时的调试工具stethoFacebook开源，很强大的Android网络和数据库调试工具,能像调试WebApp一样调试Android原生应用。借助Stetho在Chrome上调试Android网络&amp;数据库常用配置: 初始化public class MyApplication extends Application { public void onCreate() { super.onCreate(); Stetho.initializeWithDefaults(this); } } Chrome浏览器打开chrome://inspect/#devices 进阶增加网络拦截 Dependency 增加依赖环境compile 'com.facebook.stetho:stetho:1.3.1' compile 'com.facebook.stetho:stetho-okhttp3:1.3.1' compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4' compile 'com.squareup.okhttp3:okhttp:3.2.0' compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4' 向OkHttpClient增加网络拦截OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); databases 相关 Android-Debug-Database 比较漂亮的UI调试数据库 augmented-traffic-controlFackbook开源项目模拟移动网络，对App的调试及网络优化有很大的帮助，主要参数有： 网络带宽（bandwidth） 延迟（latency） 丢包率（packet loss） 错包率（corrupted packets） 乱序率（packets ordering） GT（随身调） 腾讯开源的测试套件能Android设备上安装,进行移动调试,确保测试数据的真实有效性开源地址: https://github.com/TencentOpen/GT官网地址 使用GT APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。 一. 基本功能测试 1. CPU占有率; 2 jiffes（CPU时间片）; 3. 内存PSS值稳定在36M; 4. 网络上行流量和下行流量; 5. "数据存档" 二. 电量测试 再启动电流监控观察，1分钟后平均电流是220mA 三. crash - 保存了抓包文件后; - Logcat查看界面，立即把手机缓存的Logcat日志保存下来; 四. Net - 系统提供的流量查看也包括局域网socket的流量,而且不能分时段统计; - tcpdump抓包(需要手机root) + Wiresharek 抓包分析; 疑问点: 1. 激活FPS（帧率）的监测; 应用开发助手 Google Play、应用宝搜索“开发助手”下载， 或Download 屏幕分辨率、CPU 核数、IP 及 Mac 地址、so 类型、系统版本。 频繁切换“严格模式”； 多次启停“显示布局边界”； 测试被系统回收来回切换“不保留活动”； Android Debug Drawer 查看设备信息 安卓日志工具 XLog github微信mars 的高性能日志模块 xlog Pidcat Timber jakewharton 出品 compile 'com.jakewharton.timber:timber:4.5.1' // 初始化 if (BuildConfig.DEBUG) { Timber.plant(new Timber.DebugTree()); } else { Timber.plant(new CrashReportingTree()); } //发布后程序（Release.apk），崩溃日志上报 /** A tree which logs important information for crash reporting. */ private static class CrashReportingTree extends Timber.Tree { @Override protected void log(int priority, String tag, String message, Throwable t) { if (priority == Log.ERROR) { String msg = message + (t == null ? "" : t.getMessage()); MobclickAgent.reportError(mContext, String.format("TAG=%s, msg=%s, Throwable=%s", tag, message, t == null ? "" : t.getMessage())); //友盟错误上传 // Crashlytics.log(priority, tag, msg);// Fabric 错误上传 } } } Hugo 用注解的方式日志打印方法传入的参数 Annotation-triggered method call logging for your debug builds. Pury like Hugo But Android library for measuring time between multiple independentevents. KLog 这是一个Android专用的LogCat工具，主要功能为打印行号、函数调用、Json解析、XML解析、点击跳转、Log信息保存等功能 ViewInspector 查看View绘制层级，参数等View Inspection Toolbar for Android Development Purchase UI Tool (付费工具) Robotium Recorder 优化和分析工具Quality-Tools-for-Androidvb-android-app-qualityAndroidCodeQuality每次打包时都进行一次 checkstyle,pmd,findbugs验证 AndroidDevMetricsPerformance metrics library for Android development AndroidPerformanceMonitor一个对ANR（UI线程block）的监控工具 A transparent ui-block detection library for Android. (known as BlockCanary)]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native for Android]]></title>
    <url>%2F2016%2F11%2F20%2F2016-11-20-React-Native-for-Android%2F</url>
    <content type="text"><![CDATA[入门 React Native for Android 入门老虎problem solution: when “brew install watchman” ==&gt;&gt; configure: error: You need a C++ compiler for C++ support ==&gt; sudo apt-get install build-essential2. brew install flow ==&gt;&gt; bnpm install flow-bin –global Android开发技术周报特刊之React Native 【经典教程】 Facebook.org react react-native React-Native 的优化进阶之旅 进阶 构建 F8 App / React Native 开发指南 【ReactNative For Android】框架启动核心路径剖析 印象笔记有备份 携程 React Native 实践与性能优化 相关开源项目 DoubanMovie-React-Native create-react-app Create React apps with no build configuration. Learning material react-native-guide React-Native指南汇集了react-native学习资源与各类开源app CodePush 大微软推出的一套可以为用 React Native 和 Cordova 开发的 App 提供代码热更新的方案。 React Native Training (中文) 视频 介绍 InfoQ: 探索 React 生态圈 Atom官网安装 sudo add-apt-repository ppa:webupd8team/atom sudo apt-get update sudo apt-get install atom /opt/atom/atom Proxy setting from apm github Using a proxy? If you are using a HTTP(S) proxy you can configure apm to use it by running: apm config set https-proxy https://127.0.0.1:1080 You can run apm config get https-proxy to verify it has been set correctly. plugincp the plugin.zip to ~/.atom/packages or $ apm install color-picker emmet-atom browser-plus highlight-selected atom-api-blueprint-preview Read.md previewjshint：检查 JavaScript 的语法，支持 JSX （需要在插件设置中开启 Support Linting JSX）；emmet：用 emmet （Zen Coding）方式快速编写页面；save-session：让 Atom 记住上一次打开的会话；browser-plus：在 Atom 中内嵌一个浏览器窗口，方便页面调试（其实 Atom 本身就是一个浏览器）；minimap：如果你对 Sublime Text 的 minimap 念念不忘；atomic-emacs：Emacs 键盘布局，适合 Emacs 用户使用；vim-mode：Vim 键盘布局，适合 Vim 用户使用。 待处理 atom-space-pen-views atom-html-preview 教程Atom 使用教程]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>facebook</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据处理资源总汇]]></title>
    <url>%2F2016%2F09%2F08%2F2016-09-08-Android-database-note%2F</url>
    <content type="text"><![CDATA[数据格式 gson Gson Json Annotations Example stag-java Speedy Type Adapter Generation fastjson 序列化 Parcelable Parcelable AutoValue使用 Google AutoValue 自动生成代码 Dependencies dependencies { provided &#39;com.google.auto.value:auto-value:1.2&#39; apt &#39;com.google.auto.value:auto-value:1.2&#39; apt &#39;com.ryanharter.auto.value:auto-value-parcel:0.2.1&#39; } Sample @AutoValue public abstract class Story implements Parcelable{ public abstract int id(); public abstract String title(); public static Story create(int id, String title){ new AutoValue_Story(id,title); } } Android 状态保存 android-state public class MainActivity extends Activity { @State public int mValue; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); StateSaver.restoreInstanceState(this, savedInstanceState); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); StateSaver.saveInstanceState(this, outState); } } 笔记 Sqlite 批量处理 SQLite批量插入和其他一些使用心得 android SQLite 批量插入数据慢的解决方案 Tutorial sqlite-tutorial Android 保存图片到SQLite,读出SQLite中的图片 sqlite 官方教程 CREATE TRIGGER Sqlite learnning Course SQL语句 Inner join/ union 的学习 select f.name ,count(1) as sum, d.value as url from Favorite f inner join data d on d.key==f.name group by f.name 笔记好滴博文 5个Android ORM框架 Android 主流ORM（对象关系数据映射）简介 常用的SQL语句 DROP TABLE IF EXISTS t_student CREATE TALBE IF NOT EXISTS t_student (id iteger primary key autoincrement, name text, age integer, score real ); INSERT INTO t_student (name,age) values ('jack',22) update t_student set name='jack' ,id =1 select * from t_student where score >= 60 order by score asc, age asc; limit 分页查询 limit 0,5 limit 5,5 约束 not null, unique, default 外键—— create table t_student (id integer primary key autoincrement,name text, class_id integer, constraint fk_t_student_class_id_t_class_id foreign key (class_id) references t_class(id) ) Awesome Repositories Repository Description ActiveAndroid Active record style SQLite persistence for Android. Android-sqlite-asset-helper An Android helper class to manage database creation and version management using an application’s raw asset files. Android-lite-orm A fast, small, powerful ORM framework for Android. Android-database-sqlcipher Android SQLite API based on SQLCipher. Android Storage Create, read, delete, append, encrypt files and more, on internal or external disk spaces with a really simple API. Conceal Conceal provides easy Android APIs for performing fast encryption and authentication of data. Couchbase-lite-android Lightweight, embedded, syncable NoSQL database engine for Android. ConserveORM A library for storing your Java/Scala/Kotlin objects in a database. DBFlow A blazing fast, powerful, and very simple ORM android database library that writes database code for you. EncryptedPreferences AES-256 encrypted SharedPreferences for Android. GreenDao greenDAO is a light &amp; fast ORM solution for Android that maps objects to SQLite databases. Hawk Secure, simple key-value storage for Android. Kotpref Android SharedPreferences delegation library for Kotlin. LitePal An Android library that makes developers use SQLite database extremely easy. ObjectBox ObjectBox is a superfast mobile database for objects. Ormlite-android ORMLite Android functionality used in conjunction with ormlite-core. Paper Paper is a fast NoSQL-like storage for Java/Kotlin objects on Android with automatic schema migration support. PreferenceRoom Manage your android project’s SharedPreferences more efficiently. PersistentCookieJar A persistent CookieJar implementation for OkHttp 3 based on SharedPreferences. Realm Realm is a mobile database: a replacement for SQLite &amp; ORMs. Room Persistence The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. Requery Modern SQL based query &amp; persistence for Java / Kotlin / Android. Rx-preferences Reactive SharedPreferences for Android. Rxkprefs A small, Rx-powered shared preferences library for Kotlin. Store Android Library for Async Data Loading and Caching. Storio Reactive API for SQLiteDatabase and ContentResolver. Sugar Insanely easy way to work with Android Database. Squidb SquiDB is a SQLite database library for Android and iOS. Sqlite-android Android SQLite support library. Secured-Preference-Store A cryptography library and a SharedPreferences wrapper for Android that encrypts the content with 256 bit AES encryption. The Encryption key is securely stored in device’s KeyStore. Tray A SharedPreferences replacement for Android with multiprocess support. No Sql RxPaper Like below Paper Rx-preferences Reactive SharedPreferences for Android http://f2prateek.com/2015/10/05/rx-preferences/ Leveldb is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values. Paper save/restore Java objects by using efficient Kryo serialization and handling data structure changes automatically. Iron Fast and easy to use NoSQL data storage 轻量 轻量对原生方法的封装（Origin API Extension） Favor A easy way to use android sharepreference SQLite ORM LitePal Android数据库高手秘籍 greendao Home page, documentation, and support links: http://greenrobot.org/greendao/ Chinese tutorial requery 又一轻量ORM库 What is a good tutorial for using ORMLite with SQLite and Android Improve SQLiteOpenHelper and ContentResolverSquare 出品 Sqlbrite A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.http://square.github.io/sqlbrite/ sqldelight Generates Java models from CREATE TABLE statements.（从sql语句生成Java模式 ）能把sql统一管理 Delightful-SQLBrite sqldelight 和 SQLBrite 例子 Qit Storio Beautiful API for SQLiteDatabase and ContentResolver Android InstanceIcepick Android Instance State made easy It works for Activities, Fragments or any object that needs to serialize its state on a Bundle Tools(工具) android_dbinspector 优化 WeChat Sqliste 微信ANDROID客户端-会话速度提升70%的背后 protocol buffer (protobuf) 问题处理Sqlite3 sqlite3 not foundblog: sqlite3 not found的解决办法 cant-remount-system-in-rw Nexus5使用有效果的命令：mount -o remount,rw /system chmod 4755 /system/xbin/sqlite3 sqlite3 robot.db ==&gt; error: only position independent executables (PIE) are supported.]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>数据库</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 相关的新技术]]></title>
    <url>%2F2016%2F08%2F04%2F2016-08-04-New-trend-for-Android%2F</url>
    <content type="text"><![CDATA[Dynamic Loading 360 出品 DroidPlugin A plugin framework on android,Run any third-party apk without installation, modification or repackage Like web app release version ==&gt;open source Nuwa 女娲（Nuwa），可以热修复Android应用，可以加快编译 Dynamic-loading Alibabadexposed AOP (Aspect-oriented Programming) framework for Android app developmentAndFix C++ Android App 线上热修复方案 Android平台免Root无侵入AOP框架Dexposed使用详解 【翻译】Android中的AOP编程 Alibaba-Dexposed框架在线热补丁修复的使用 weex 阿里开源,类似React Native基于JS开源夸平台开源库 携程插件框架DynamicAPK Solution to implement multi apk dynamic loading and hot fixing for Android App. (实现Android App多apk插件化和动态加载，支持资源分包和热修复) 如何实现携程动态加载插件中对aapt的改造 Samll 做最轻巧的跨平台插件化框架。支持平台：Android API 15(4.0.3)+ iOS 7.0+ 敬请期待。 Xposed 用黑客思维做测试——神器 Xposed 框架介绍 官网教程: Development-tutorial tinker github 微信热更新方案 Tinker_imitator 微信热更新方案实践 博文介绍 微信Tinker的一切都在这里，包括源码(一) tinker-manager 微信tinker补丁管理，后端代码+客户端sdk 博文讲解Android插件化原理解析——Hook机制之Binder Hook Weex阿里开源基于JS开源夸平台开源库,类似React Native但是更轻量，学习成本低。 Weex 官网 阿里无线11.11 ： Weex——关于移动端动态性的思考、实现和未来 Kotlin Weekly Kotlin 资源合集 org.website Tutorial Online Compile Tutorial command-line reference Examples Kotlin语言1.0Beta发布，JetBrain介绍其设计理念 Kotlin 1.0都出了还没看过肿么办？不怕！来看我整理的Kotlin学习资源 相关开源库： AdvancedRecyclerView Flutter Flutter「发布预览版 2」让 iOS 应用至臻完美 Flutter 1.0 正式版: Google 的便携 UI 工具包 Flutter跨平台Hybrid实践 做了2个多月的设计和编码，我梳理了Flutter动态化的方案对比及最佳实现 Flutter学习指南：封装 API 插件 开源库 flutter-go flutter 开发者帮助 APP，包含 flutter 常用 140+ 组件的demo 演示与中文文档 ARCore Google 的增强现实构建平台 从小白到上手 ARCore，这一篇技术贴请收好 RxAndroidReading Grokking RxJava, Part 4: Reactive Android Rxlint compile &#39;nl.littlerobots.rxlint:rxlint:1.0 优化 redex 通过对字节码进行优化，以减小 Android Apk 大小，同时提高 App 启动速度。Facebook App 优化工具 ReDex 优化的 6 点及未优化的一大方面 统一开发 Multi-OS Engine Create Android and iOS apps using Java Coding 一个能用Android Studio统一开发 IOS Android Window 应用的引擎。 开源库 android-ocr optical character recognition (OCR) 文字识别 谷歌新开源库jetpackhttps://developer.android.com/jetpack/ AndroidX LiveData + ViewModel + Room ViewModel+LiveData+DataBinding]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>New Trench</tag>
        <tag>Android</tag>
        <tag>新技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design]]></title>
    <url>%2F2016%2F07%2F29%2F2016-07-29-Material-Design%2F</url>
    <content type="text"><![CDATA[前言一、设计阶段Material Design 提供了跨设备和 Web 的一致性用户体验。它的四项原则： 有型的外观(Tangible surface)：应用像现实中的实物一样。 仿印刷品的设计(Print-like design)：内容醒目、形象生动、意图明确。 有意义的运动效果(Meaningful motion)：吸引用户的兴趣，在应用状态切换时保持连续性。 自适应设计(Adaptive deisgn)：用户在手机、平板、Android TV、Android Wear、Android Auto 等不同设备上都能感到熟悉、一致，而不需要重新适应应用。 文档官方API The Transitions Framework Support Library 官方博客 [1]Android Design Support Library Android Support Library 23.2 使用须知 剥茧抽丝做 UI 动效，其实很简单 开源库 Awesome-MaterialDesign 【重点】 Material design icons by Google Animation: Jump-through【待研究】【重点】 An Introduction to Icon Animation Techniques 非常详尽的介绍并附有代码例子讲解 【重点】 Animate all the things. Transitions in Android一个关于transitions-everywhere Motion Material 兼容库的介绍的博客 Music Player: From UI Proposal to Code 一个介绍Material Transitions 的例子，但是没有兼容低版本 App Bar layout smooth-app-bar-layout StatusBarCompat Api &gt;= 19 Material Design 新特性 Codelab for Android Design Support Library used in I/O Rewind Bangkok session 介绍Material Design 新特性很详细的文章 对应的代码Github SVG An Introduction to Icon Animation Techniques 【超级经典·必读】 SVG Path reference. Animating Vector Drawables. PathMorphing with AnimatedVectorDrawables in Android ColoredVector-Android VectorDrawable 和 AnimatedVectorDrawable 的兼容性问题 工具 SVG的编辑器 Inkscape 跨平台SVG编辑器 转化 SvgToVectorDrawableConverter svg2android 相关博文 Android Vector曲折的兼容之路 TV Docs http://developer.android.com/tv/index.html androidtv-Leanback ToolbarToolBar详解 TabLayout TabLayout：另一种Tab的实现方式 如下代码，Tab间隔转换会有更好的动画效果。Method animateToTab = clz.getDeclaredMethod("animateToTab", new Class[]{int.class}); animateToTab.setAccessible(true); animateToTab.invoke(tabLayout, new Object[]{5}); 与ViewPager结合标准代码@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.ac_tab_layout); // 获取ViewPager ViewPager viewPager = (ViewPager) findViewById(R.id.ac_tab_vp); // 构造一个TabPagerAdapter对象 TabPagerAdapter adapter = new TabPagerAdapter(); // 获取ViewPager TabLayout tabLayout = (TabLayout) findViewById(R.id.ac_tab_layout); // 设置TabLayout模式 tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE); // 设置ViewPager的适配器 viewPager.setAdapter(adapter); // 设置ViewPager tabLayout.setupWithViewPager(viewPager); } Design库-TabLayout属性详解 Bottom NavigationDependence compile 'com.android.support:appcompat-v7:25.0.0' compile 'com.android.support:design:25.0.0' Tutorial：Now you can use the Bottom Navigation View in the Design Support Library TextInputLayout codelabs constraint-layout [good] Creating a Login Screen Using TextInputLayout MaterialEditText 抛物线【RxJava经典入门教程的博主】ConstraintLayout Using ConstraintLayout to design your views ConstraintLayout API Build a Responsive UI with ConstraintLayout ConstraintLayout – Part 1 Script To convert an existing layout to a constraint layoutDesign -&gt; component Tree -&gt; Convert layout to ConstraintLayout CardView android.support.v7.widget.CardView NestedScrollView图片文字资源资源 Demos the new Android Design library github star 6300+ MaterialDrawer The flexible, easy to use, all in one drawer library for your Android project CircularAnim Android水波动画帮助类，一行代码实现View显示/隐藏/startActivity特效。(对 ViewAnimationUtils.createCircularReveal() 方法的封装) 字体和图片相关 Material Icon Library Github 1800+ star主要特点： 包含1500+ 的矢量图标（大小: 200kb）； 支持API&gt;=4； 可以转化为Drawable，可以menu.xml 中使用， 可以在Toolbar menu中使用 使用：1. 在https://materialdesignicons.com找矢量图； 2.集成库使用； Android-Iconics 【推荐】主要特点： 提供了三个矢量图库； 可以在原生控件上使用； 支持字体和矢量图片的自定义； Material Animation 动画 Material-Animations Android-Material-Examples New Feature 新的特性 material-tip Theme 主题 Android-Material-Themes-Demo 设置相关 material-about-library 原生控件的包装 Atelier A fast and clean way of using Palette in lists material-code-input material-dialogs 兼容开源库 ActSwitchAnimTool ActSwitchAnimTool make the Animation easy to implements, and it compat the version of Android 4.0 or above. RippleDrawable support 14+ WaveCompat fab-transformation nice-spinner support 14+ ToggleDrawable CircularReveal RevealEffect support 2.3 Transitions-Everywhere API compatible with Android 2.2+ MaterialStyledDialogs API 11+ required. vector-compat vector 兼容库开源资源 Material Design 参考资料 Android 开发设计 http://developer.android.com/design/ Material Design 示范应用 和 获奖应用 Google Design 网站 https://design.google.com/ Material Design 设计规范 http://www.google.com/design/spec/material-design/introduction.html Icons Tool https://design.google.com/icons/ Devices Tool https://design.google.com/devices/ Udacity 免费设计课程：Material Design for Android Developers]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌官网之硬件加速 【译】]]></title>
    <url>%2F2016%2F06%2F02%2F2016-06-02-Google-Api-hareware-acc%2F</url>
    <content type="text"><![CDATA[硬件加速 Android 3.0 (API level 11)开始，Android 2D渲染管道支持硬件加速。API level &gt;=14的Android系统默认开启硬件加速。由于硬件加速并不支持所有的2D绘制操作，所以开启硬件加速，可能会导致自定义view中部分元素看不到，程序抛出异常，或者错误的像素渲染等问题。 开启/关闭硬件加速 Application&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; Activity&lt;application android:hardwareAccelerated="true"> &lt;activity ... /> &lt;activity android:hardwareAccelerated="false" /> &lt;/application> Window 级别只能开启硬件加速getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View 关闭硬件加速myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null); View硬件加速的判断两个方法： View.isHardwareAccelerated()) Canvas.isHardwareAccelerated()) 你必须在你绘制代码（drawing code）内检测，使用前者而不是后者，因为有可能View虽然依附于一个硬件加速的窗口，但它依然可以在一个没有硬件加速的Canvas上绘制，列如：为了缓存的目的把view绘制到一个bitmap上。 Android 软加速/硬加速 绘制模式基于软件的绘制模式绘制步骤：无效从下到上的View，然后重新绘制。问题： 没有改变的大量上层的View需要重新绘制。 Android重绘view的过程，有可能没有绘制发生改变的view，此时你只能依赖其他view包含恰好的重绘行为。 硬件加速的绘制模式绘制步骤： 无效从下到上的View 记录和更新显示列表（display lists） 绘制显示列表 优点： 使用display lists能有针对性的更新改变的View 不支持的绘制操作Canvas Scaling View LayersOff-screen buffers a view’s drawing cache Canvas.saveLayer()) 所有的Android版本都支持对Off-screen buffers进行渲染。 你会获得更好的性能，当做复杂view的动画或者应用合成效果时。列如，当你实现淡出效果时，你可以使用Canvas.saveLayer()，暂存渲染的view到layer中，然后用透明度合成，使它返回屏幕达到淡出效果。 View.setLayerType()) LAYER_TYPE_NONE 不使用 off-screen buffer 【默认】 LAYER_TYPE_HARDWARE LAYER_TYPE_SOFTWARE 选择技巧 Performance: 使用硬件加速时，一旦一个view渲染进如layer中，只有调用invalidate())是绘制的代码才会被执行。一些动画，列如透明度动画，可以直接用于layer中，这使用GPU去执行是非常高效的。 Compatibility: Use a software layer type to force a view to be rendered in software. View layers and animations如果你在你的应用中跑的动画没有达到，你想要的流程结果，你可以考虑启动硬件加速。 以下的属性，使用合成来作用于layer，使用的是优化的invalidation及不需要重绘目标view，过程更高效。 alpha: Changes the layer’s opacity x, y, translationX, translationY: Changes the layer’s position scaleX, scaleY: Changes the layer’s size rotation, rotationX, rotationY: Changes the layer’s orientation in 3D space pivotX, pivotY: Changes the layer’s transformations origin demo： View.setLayerType(View.LAYER_TYPE_HARDWARE, null); ObjectAnimator animator = ObjectAnimator.ofFloat(view, "rotationY", 180); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { view.setLayerType(View.LAYER_TYPE_NONE, null); } }); animator.start(); 提示和技巧 减少view的数量 避免过度绘制A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!). 不创建渲染类在绘制代码中：如在onDraw中 new Paint 或者 Path。 不频繁的改变形状Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive. 不频繁的修改bitmap 谨慎使用alpha，当应用alpha属性到很大的views时，考虑使用 LAYER_TYPE_HARDWARE。.]]></content>
      <categories>
        <category>translate</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>google</tag>
      </tags>
  </entry>
</search>
