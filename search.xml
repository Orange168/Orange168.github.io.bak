<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JNI/NDK开发指南学习笔记]]></title>
    <url>%2F2018%2F08%2F15%2F2018-8-15-jni-note%2F</url>
    <content type="text"><![CDATA[[TOC] JNI开发流程及HelloWorld基础知识：不同平台的动态库（windows：*.dll，linux/unix：*.so，mac os x：*.jnilib） JNI开发主要流程 第一步、并新建一个HelloWorld.java源文件 package com.study.jnilearn; public class HelloWorld { public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现 public static void main(String[] args) { String text = sayHello("yangxin"); // 3.调用本地函数 System.out.println(text); } static { System.loadLibrary("HelloWorld"); // 2.加载实现了native函数的动态库，只需要写动态库的名字 } } 用javac命令将.java源文件编译成.class字节码文件//-d 指定目录 javac src/com/study/jnilearn/HelloWorld.java -d ./bin 生成.h头文件javah -jni -classpath ./bin -d ./jni com.study.jnilearn.HelloWorld 实现.h头文件中的函数com_study_jnilearn_HelloWorld.h： /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h> /* Header for class com_study_jnilearn_HelloWorld */ #ifndef _Included_com_study_jnilearn_HelloWorld #define _Included_com_study_jnilearn_HelloWorld #ifdef __cplusplus extern "C" { #endif /* * Class: com_study_jnilearn_HelloWorld * Method: sayHello * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello (JNIEnv *, jclass, jstring); #ifdef __cplusplus } #endif #endif 将C/C++代码编译成本地动态库文件#-I 包含头文件 # -fPIC： 编译成与位置无关的独立代码 # -shared：编译成动态库 # -o 指定输出 gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so 运行Java程序 so库加载及相关配置如果手上有动态库； win: libHelloWorld.dll，linux/unix：libHelloWorld.so，mac os x：libHelloWorld.jnilib 加载方式 //1. 不需要加lib前缀，也不要加.so、.dll和.jnilib后缀 System.loadLibrary("HelloWorld"); //2. 指定动态库的绝对路径名，需要加上前缀和后缀 System.load("/Users/yangxin/Desktop/libHelloWorld.jnilib"); 加载方式1的配置 //1. 将动态链接库拷贝到java.library.path目录 String libraryDirs = System.getProperty("java.library.path"); System.out.println(libraryDirs); // 输出结果如下： /Users/yangxin/Library/Java/Extensions:/Library/Java/Extensions: // 2. 指定系统属性java.library.path的值 java -Djava.library.path=/Users/yangxin/Desktop // 3. 指定库的搜索目录: Linux/Unix环境下可以通过设置LD_LIBRARY_PATH环境变量。 JNI数据类型// HelloWorld.java public static native void test(short s, int i, long l, float f, double d, char c, boolean z, byte b, String str, Object obj, MyClass p, int[] arr); // HelloWorld.h JNIEXPORT void JNICALL Java_com_study_jnilearn_HelloWorld_test (JNIEnv *env, jclass cls, jshort s, jint i, jlong l, jfloat f, jdouble d, jchar c, jboolean z, jbyte b, jstring j_str, jobject jobj1, jobject job2, jintArray j_int_arr) 主要类型： 数组： 其他JNIEnv和jclass jobject C++ and C 不同C++ 和Java一样面向对象 所有引用类型自jobject派生 class _jobject {}; class _jclass : public _jobject {}; class _jstring : public _jobject {}; class _jarray : public _jobject {}; class _jbooleanArray : public _jarray {}; class _jbyteArray : public _jarray {}; ... C 使用typedef重新定义，如：typedef jobject jstring jvalue typedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l; } jvalue; 字符串处理基础知识 JNI把Java中的所有对象当作一个C指针传递到本地方法中，这个指针指向JVM中的内部数据结构，而内部的数据结构在内存中的存储方式是不可见的。只能从JNIEnv指针指向的函数表中选择合适的JNI函数来操作JVM中的数据结构 Java默认使用Unicode编码，而C/CPP默认使用UTF编码；GetXXUTFXX/ReleaseXXUTFXX 用于C/CPP 字符三部曲 GET -&gt; Release -&gt; Newconst char *c_str = NULL; char buff[128] = {0}; jboolean isCopy; // 返回JNI_TRUE表示原字符串的拷贝，返回JNI_FALSE表示返回原字符串的指针 c_str = (*env)->GetStringUTFChars(env, j_str, &amp;isCopy); printf("C_str: %s \n", c_str); sprintf(buff, "hello %s", c_str); (*env)->ReleaseStringUTFChars(env, j_str, c_str); return (*env)->NewStringUTF(env,buff); GetStringUTFChars(env, j_str, &amp;isCopy) 说明： isCopy 默认为NULL就好 JNI_TRUE Jvm中j_str复制一份; JNI_FALSE 返回源字符串的内容，不推荐； UTF Java默认使用Unicode编码，而C/C++默认使用UTF编码，GetStringUTFChars可以把一个jstring指针（指向JVM内部的Unicode字符序列）转换成一个UTF-8格式的C字符串 异常检查 因为JVM需要为新诞生的字符串分配内存空间，当内存空间不够分配的时候，会导致调用失败，失败后GetStringUTFChars会返回NULL，并抛出一个OutOfMemoryError异常。JNI的异常不会停止而是继续往下，留下一个空指针。 if(GetStringUTFChars == NULL ) return ; 释放字符串 GetStringUTFChars 会分配内存需释放 同理： GETXX就必须调用ReleaseXXX NewStringUTFgraph LR NewStringUTF --&gt; JVM新建java.lang.String; JVM新建java.lang.String --&gt; 没有内存; 没有内存--&gt; OutOfMemoryError ; 其他函数 Get和ReleaseStringChars(Unicode)vs Get/ReleaseStringUTFChars(UTF-8) GetStringLength/GetStringUTFLength 由于UTF-8编码的字符串以’\0’结尾，而Unicode字符串不是。 Get/ReleaseStringCritical：提高JVM返回源字符串直接指针的可能性 当字符1M左右，较大时使用 两个代码间，不可以执行导致阻塞的调用或为新对象在JVM中分配内存，否则，JVM有可能死锁。JNIEXPORT jstring JNICALL Java_com_study_jnilearn_Sample_sayHello (JNIEnv *env, jclass cls, jstring j_str) { const jchar* c_str= NULL; char buff[128] = "hello "; char* pBuff = buff + 6; /* * 在GetStringCritical/RealeaseStringCritical之间是一个关键区。 * 在这关键区之中,绝对不能呼叫JNI的其他函数和会造成当前线程中断或是会让当前线程等待的任何本地代码， * 否则将造成关键区代码执行区间垃圾回收器停止运作，任何触发垃圾回收器的线程也会暂停。 * 其他触发垃圾回收器的线程不能前进直到当前线程结束而激活垃圾回收器。 */ c_str = (*env)->GetStringCritical(env,j_str,NULL); // 返回源字符串指针的可能性 if (c_str == NULL) // 验证是否因为字符串拷贝内存溢出而返回NULL { return NULL; } while(*c_str) { *pBuff++ = *c_str++; } (*env)->ReleaseStringCritical(env,j_str,c_str); return (*env)->NewStringUTF(env,buff); } GetStringRegion和GetStringUTFRegion 源字符串复制到一个预先分配的缓冲区内【不分配内存】，UTF越界 会报StringIndexOutOfBoundsException; 【推荐使用】 缓冲区可以被编译器提前分配，而且永远不会产生内存溢出的异常 提供了一个开始索引和子字符串的长度值 复制少量字符串的消耗非常小jsize len = (*env)->GetStringLength(env,j_str); // 获取unicode字符串的长度 printf("str_len:%d\n",len); char buff[128] = "hello "; char* pBuff = buff + 6; // 将JVM中的字符串以utf-8编码拷入C缓冲区,该函数内部不会分配内存空间 (*env)->GetStringUTFRegion(env,j_str,0,len,pBuff); return (*env)->NewStringUTF(env,buff); Crash错误定位sdk\ndk-bundle\toolchains选择出分析对应CPU架构的so文件 Toolchain Location arm $TOOLCHAIN/arm-linux-androideabi/lib/ arm64 $TOOLCHAIN/aarch64-linux-android/lib/ x86 $TOOLCHAIN/i686-linux-android/lib/ x86_64 $TOOLCHAIN/x86_64-linux-android/lib/ #02 pc 0000242f /data/app/com.hard.dev.spiproject-C3PjhijiVGgyqX2M1fK3KQ==/lib/arm/libspi-lib.so (will_crash+30) #03 pc 0000245b /data/app/com.hard.dev.spiproject-C3PjhijiVGgyqX2M1fK3KQ==/lib/arm/libspi-lib.so (JNI_OnLoad+18) 两位数字 pc”开头的都是backtrace日志 0000242f 0000245b为 arm-linux-androideabi-addr2line 定位出错位置 adb pull /data/app/com.hard.dev.spiproject-C3PjhijiVGgyqX2M1fK3KQ==/lib/arm/libspi-lib.so arm-linux-androideabi-addr2line -e libspi-lib.so 0000242f 0000245b 使用arm-linux-androideabi-objdump 定位出错的函数信息arm-linux-androideabi-objdump -S -D libspi-lib.so &gt; dump.log ndk-stackadb logcat &gt; /tmp/foo.txt #其中$PROJECT_PATH/obj/local/armeabi-v7a 指定生成的so库路径 $NDK/ndk-stack -sym $PROJECT_PATH/obj/local/armeabi-v7a -dump foo.txt 输出 Routine后有指明保存源码位置Stack frame #05 pc 00000d1c /data/app-lib/com.example.hellojni-1/libhello-jni.so (JNI_OnLoad+20):Routine JNI_OnLoad at /samples/hello-jni/jni/hello-jni.c:15 访问数组（基本类型数组与对象数组）GetIntArrayRegion 【小量的、固定大小的数组】返回Int型数组的和例子 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h> /* Header for class com_study_jnilearn_IntArray */ #ifndef _Included_com_study_jnilearn_IntArray #define _Included_com_study_jnilearn_IntArray #ifdef __cplusplus extern "C" { #endif /* * Class: com_study_jnilearn_IntArray * Method: sumArray * Signature: ([I)I */ JNIEXPORT jint JNICALL Java_com_study_jnilearn_IntArray_sumArray (JNIEnv *, jobject, jintArray); #ifdef __cplusplus } #endif #endif // IntArray.c #include "com_study_jnilearn_IntArray.h" #include &lt;string.h> #include &lt;stdlib.h> /* * Class: com_study_jnilearn_IntArray * Method: sumArray * Signature: ([I)I */ JNIEXPORT jint JNICALL Java_com_study_jnilearn_IntArray_sumArray (JNIEnv *env, jobject obj, jintArray j_array) { jint i, sum = 0; jint *c_array; jint arr_len; //1. 获取数组长度 arr_len = (*env)->GetArrayLength(env,j_array); //2. 根据数组长度和数组元素的数据类型申请存放java数组元素的缓冲区 c_array = (jint*)malloc(sizeof(jint) * arr_len); //3. 初始化缓冲区 memset(c_array,0,sizeof(jint)*arr_len); printf("arr_len = %d ", arr_len); //4. 拷贝Java数组中的所有元素到缓冲区中 (*env)->GetIntArrayRegion(env,j_array,0,arr_len,c_array); for (i = 0; i &lt; arr_len; i++) { sum += c_array[i]; //5. 累加数组元素的和 } free(c_array); //6. 释放存储数组元素的缓冲区 return sum; } 优化GetIntArrayElementsJNIEXPORT jint JNICALL Java_com_study_jnilearn_IntArray_sumArray2 (JNIEnv *env, jobject obj, jintArray j_array) { jint i, sum = 0; jint *c_array; jint arr_len; // 可能数组中的元素在内存中是不连续的，JVM可能会复制所有原始数据到缓冲区，然后返回这个缓冲区的指针 c_array = (*env)->GetIntArrayElements(env,j_array,NULL); // NULL JNI_TRUE 缓冲区数组指针 JNI_FALSE 原始 if (c_array == NULL) { return 0; // JVM复制原始数据到缓冲区失败 } arr_len = (*env)->GetArrayLength(env,j_array); printf("arr_len = %d\n", arr_len); for (i = 0; i &lt; arr_len; i++) { sum += c_array[i]; } (*env)->ReleaseIntArrayElements(env,j_array, c_array, 0); // 释放可能复制的缓冲区 return sum; } GetIntArrayElements 缺点 有可能在申请开辟临时缓冲区内存空间时，会内存不足导致申请失败，返回NULL GC占用对象锁，导致本地线程一直堵塞 Get/ReleasePrimitiveArrayCritical 暂停GC 特点：地代码在访问数组对象时会暂停GC线程 注意：两个函数期间不能调用任何会让线程阻塞或等待JVM中其它线程的本地函数或JNI函数 对象数组Get/SetObjectArrayElement案例：ObjectArray.java package com.study.jnilearn; public class ObjectArray { private native int[][] initInt2DArray(int size); public static void main(String[] args) { ObjectArray obj = new ObjectArray(); int[][] arr = obj.initInt2DArray(3); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { System.out.format("arr[%d][%d] = %d\n", i, j, arr[i][j]); } } } static { System.loadLibrary("ObjectArray"); } } C语言 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h> /* Header for class com_study_jnilearn_ObjectArray */ #ifndef _Included_com_study_jnilearn_ObjectArray #define _Included_com_study_jnilearn_ObjectArray #ifdef __cplusplus extern "C" { #endif /* * Class: com_study_jnilearn_ObjectArray * Method: initInt2DArray * Signature: (I)[[I */ JNIEXPORT jobjectArray JNICALL Java_com_study_jnilearn_ObjectArray_initInt2DArray (JNIEnv *, jobject, jint); #ifdef __cplusplus } #endif #endif // ObjectArray.c #include "com_study_jnilearn_ObjectArray.h" /* * Class: com_study_jnilearn_ObjectArray * Method: initInt2DArray * Signature: (I)[[I */ JNIEXPORT jobjectArray JNICALL Java_com_study_jnilearn_ObjectArray_initInt2DArray (JNIEnv *env, jobject obj, jint size) { jobjectArray result; jclass clsIntArray; jint i,j; // 1.获得一个int型二维数组类的引用 clsIntArray = (*env)->FindClass(env,"[I"); //"[I" JNI class descript if (clsIntArray == NULL) { return NULL; } // 2.创建一个数组对象（里面每个元素用clsIntArray表示） // 说明： 函数NewObjectArray只能分配第一维，JVM没有与多维数组相对应的数据结构，JNI也没有提供类似的函数来创建二维数组 result = (*env)->NewObjectArray(env,size,clsIntArray,NULL); if (result == NULL) { return NULL; } // 3.为数组元素赋值 for (i = 0; i &lt; size; ++i) { jint buff[256]; jintArray intArr = (*env)->NewIntArray(env,size); if (intArr == NULL) { return NULL; } for (j = 0; j &lt; size; j++) { buff[j] = i + j; } //把buff[]缓冲中的内容复制到新分配的一维数组中 (*env)->SetIntArrayRegion(env,intArr, 0,size,buff); (*env)->SetObjectArrayElement(env,result, i, intArr); //避免在循环内创建大量的JNI局部引用，造成JNI引用表溢出 (*env)->DeleteLocalRef(env,intArr); } return result; } JVM引用 在JNI中，只有jobject以及子类属于引用变量，会占用引用表的空间，jint，jfloat，jboolean等都是基本类型变量，不会占用引用表空间，即不需要释放。引用表最大空间为512个，如果超出这个范围，JVM就会挂掉。 C/C++访问Java实例方法和静态方法实战案例AccessMethod.java package com.study.jnilearn; /** * AccessMethod.java * 本地代码访问类的实例方法和静态方法 * @author yangxin */ public class AccessMethod { public static native void callJavaStaticMethod(); public static native void callJavaInstaceMethod(); public static void main(String[] args) { callJavaStaticMethod(); callJavaInstaceMethod(); } static { System.loadLibrary(&quot;AccessMethod&quot;); } } ClassMethod.java package com.study.jnilearn; /** * ClassMethod.java * 用于本地代码调用 * @author yangxin */ public class ClassMethod { private static void callStaticMethod(String str, int i) { System.out.format(&quot;ClassMethod::callStaticMethod called!--&gt;str=%s,&quot; + &quot; i=%d\n&quot;, str, i); } private void callInstanceMethod(String str, int i) { System.out.format(&quot;ClassMethod::callInstanceMethod called!--&gt;str=%s, &quot; + &quot;i=%d\n&quot;, str, i); } } Jni 源码 // AccessMethod.c #include &quot;com_study_jnilearn_AccessMethod.h&quot; /* * Class: com_study_jnilearn_AccessMethod * Method: callJavaStaticMethod * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaStaticMethod (JNIEnv *env, jclass cls) { jclass clazz = NULL; jstring str_arg = NULL; jmethodID mid_static_method; // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象 clazz =(*env)-&gt;FindClass(env,&quot;com/study/jnilearn/ClassMethod&quot;); if (clazz == NULL) { return; } // 2、从clazz类中查找callStaticMethod方法 mid_static_method = (*env)-&gt;GetStaticMethodID(env,clazz,&quot;callStaticMethod&quot;,&quot;(Ljava/lang/String;I)V&quot;); if (mid_static_method == NULL) { printf(&quot;找不到callStaticMethod这个静态方法。&quot;); return; } // 3、调用clazz类的callStaticMethod静态方法 str_arg = (*env)-&gt;NewStringUTF(env,&quot;我是静态方法&quot;); (*env)-&gt;CallStaticVoidMethod(env,clazz,mid_static_method, str_arg, 100); // 删除局部引用 (*env)-&gt;DeleteLocalRef(env,clazz); (*env)-&gt;DeleteLocalRef(env,str_arg); } /* * Class: com_study_jnilearn_AccessMethod * Method: callJavaInstaceMethod * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod (JNIEnv *env, jclass cls) { jclass clazz = NULL; jobject jobj = NULL; jmethodID mid_construct = NULL; jmethodID mid_instance = NULL; jstring str_arg = NULL; // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象 clazz = (*env)-&gt;FindClass(env, &quot;com/study/jnilearn/ClassMethod&quot;); if (clazz == NULL) { printf(&quot;找不到&#39;com.study.jnilearn.ClassMethod&#39;这个类&quot;); return; } // 2、获取类的默认构造方法ID mid_construct = (*env)-&gt;GetMethodID(env,clazz, &quot;&lt;init&gt;&quot;,&quot;()V&quot;); if (mid_construct == NULL) { printf(&quot;找不到默认的构造方法&quot;); return; } // 3、查找实例方法的ID mid_instance = (*env)-&gt;GetMethodID(env, clazz, &quot;callInstanceMethod&quot;, &quot;(Ljava/lang/String;I)V&quot;); if (mid_instance == NULL) { return; } // 4、创建该类的实例 jobj = (*env)-&gt;NewObject(env,clazz,mid_construct); if (jobj == NULL) { printf(&quot;在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法&quot;); return; } // 5、调用对象的实例方法 str_arg = (*env)-&gt;NewStringUTF(env,&quot;我是实例方法&quot;); (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,200); // 删除局部引用 (*env)-&gt;DeleteLocalRef(env,clazz); (*env)-&gt;DeleteLocalRef(env,jobj); (*env)-&gt;DeleteLocalRef(env,str_arg); } callJavaStaticMethod静态方法实现说明++void (JNICALL CallStaticVoidMethod)(JNIEnv env, jclass cls, jmethodID methodID, …);++ env：JNI函数表指针 cls：调用该静态方法的Class对象 methodID：方法唯一ID … 参数4：方法实参列表 其他方法 CallStaticXXXMethod CallStaticIntMethod、CallStaticFloatMethod、CallStaticShortMethod、CallStaticObjectMethod callInstanceMethod实例方法实现说明++void (JNICALL CallVoidMethod) (JNIEnv env, jobject obj, jmethodID methodID, …);++ env：JNI函数表指针 obj：调用该方法的实例 【于上不同】 methodID：方法唯一ID … 参数4：方法实参列表 相关的函数CallXXXMethod （CallXXXMethod），如：CallIntMethod、CallFloatMethod、CallObjectMethod等 方法签名fadfaf 方法签名的格式 基本类型映射关系 小结 获取构造方法ID，方法名称使用”“ C/C++访问Java实例Field和static Field C/C++代码中可以访问任意Java类中的属性 实战DemoAccessField.java package com.study.jnilearn; /** * C/C++访问类的实例变量和静态变量 * @author yangxin */ public class AccessField { private native static void accessInstanceField(ClassField obj); private native static void accessStaticField(); public static void main(String[] args) { ClassField obj = new ClassField(); obj.setNum(10); obj.setStr("Hello"); // 本地代码访问和修改ClassField为中的静态属性num accessStaticField(); accessInstanceField(obj); // 输出本地代码修改过后的值 System.out.println("In Java--->ClassField.num = " + obj.getNum()); System.out.println("In Java--->ClassField.str = " + obj.getStr()); } static { System.loadLibrary("AccessField"); } } ClassField.java package com.study.jnilearn; /** * ClassField.java * 用于本地代码访问和修改该类的属性 * @author yangxin * */ public class ClassField { private static int num; private String str; public int getNum() { return num; } public void setNum(int num) { ClassField.num = num; } public String getStr() { return str; } public void setStr(String str) { this.str = str; } } Native 代码 // AccessField.c #include "com_study_jnilearn_AccessField.h" /* * Class: com_study_jnilearn_AccessField * Method: accessInstanceField * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessField_accessInstanceField (JNIEnv *env, jclass cls, jobject obj) { jclass clazz; jfieldID fid; jstring j_str; jstring j_newStr; const char *c_str = NULL; // 1.获取AccessField类的Class引用 clazz = (*env)->GetObjectClass(env,obj); if (clazz == NULL) { return; } // 2. 获取AccessField类实例变量str的属性ID fid = (*env)->GetFieldID(env,clazz,"str", "Ljava/lang/String;"); if (clazz == NULL) { return; } // 3. 获取实例变量str的值 j_str = (jstring)(*env)->GetObjectField(env,obj,fid); // 4. 将unicode编码的java字符串转换成C风格字符串 c_str = (*env)->GetStringUTFChars(env,j_str,NULL); if (c_str == NULL) { return; } printf("In C--->ClassField.str = %s\n", c_str); (*env)->ReleaseStringUTFChars(env, j_str, c_str); // 5. 修改实例变量str的值 j_newStr = (*env)->NewStringUTF(env, "This is C String"); if (j_newStr == NULL) { return; } (*env)->SetObjectField(env, obj, fid, j_newStr); // 6.删除局部引用 (*env)->DeleteLocalRef(env, clazz); (*env)->DeleteLocalRef(env, j_str); (*env)->DeleteLocalRef(env, j_newStr); } /* * Class: com_study_jnilearn_AccessField * Method: accessStaticField * Signature: ()V */ JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessField_accessStaticField (JNIEnv *env, jclass cls) { jclass clazz; jfieldID fid; jint num; //1.获取ClassField类的Class引用 clazz = (*env)->FindClass(env,"com/study/jnilearn/ClassField"); if (clazz == NULL) { // 错误处理 return; } //2.获取ClassField类静态变量num的属性ID fid = (*env)->GetStaticFieldID(env, clazz, "num", "I"); if (fid == NULL) { return; } // 3.获取静态变量num的值 num = (*env)->GetStaticIntField(env,clazz,fid); printf("In C--->ClassField.num = %d\n", num); // 4.修改静态变量num的值 (*env)->SetStaticIntField(env, clazz, fid, 80); // 删除属部引用 (*env)->DeleteLocalRef(env,clazz); } 访问实例FieldGetXXField GetIntField，GetFloatField，GetDoubleField，GetBooleanField等 jobject (JNICALL *GetObjectField) (JNIEnv *env, jobject obj, jfieldID fieldID); env是JNI函数表指针 obj是实例变量所属的对象 fieldID是变量的ID 类比Java反射 public static void main(String[] args) throws Exception { ClassField obj = new ClassField(); obj.setStr("YangXin"); // 获取ClassField字节码对象的Class引用 Class&lt;?> clazz = obj.getClass(); // 获取str属性 Field field = clazz.getDeclaredField("str"); // 取消权限检查，因为Java语法规定，非public属性是无法在外部访问的 field.setAccessible(true); // 获取obj对象中的str属性的值 String str = (String)field.get(obj); System.out.println("str = " + str); } Jni的步骤 clazz = (*env)-&gt;GetObjectClass(env,obj); fid = (*env)-&gt;GetFieldID(env,clazz,&quot;str&quot;, &quot;Ljava/lang/String;&quot;); j_str = (jstring)(*env)-&gt;GetObjectField(env,obj,fid); //修改实例属性的值为j_newStr (*env)-&gt;SetObjectField(env, obj, fid, j_newStr); ++SetObjectField++ 类似的有SetIntField、SetDoubleField、SetBooleanField等 访问静态变量// 3.获取静态变量num的值 num = (*env)-&gt;GetStaticIntField(env,clazz,fid); // 4.修改静态变量num的值 (*env)-&gt;SetStaticIntField(env, clazz, fid, 80); 调用构造方法和父类实例方法实例Java代码 // Animal.java package com.study.jnilearn; public class Animal { protected String name; public Animal(String name) { this.name = name; System.out.println(&quot;Animal Construct call...&quot;); } public String getName() { System.out.println(&quot;Animal.getName Call...&quot;); return this.name; } public void run() { System.out.println(&quot;Animal.run...&quot;); } } // Cat.java package com.study.jnilearn; public class Cat extends Animal { public Cat(String name) { super(name); System.out.println(&quot;Cat Construct call....&quot;); } @Override public String getName() { return &quot;My name is &quot; + this.name; } @Override public void run() { System.out.println(name + &quot; Cat.run...&quot;); } } // AccessSuperMethod.java package com.study.jnilearn; public class AccessSuperMethod { public native static void callSuperInstanceMethod(); public static void main(String[] args) { callSuperInstanceMethod(); } static { System.loadLibrary(&quot;AccessSuperMethod&quot;); } } AccessSuperMethod.c // AccessSuperMethod.c #include "com_study_jnilearn_AccessSuperMethod.h" JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessSuperMethod_callSuperInstanceMethod (JNIEnv *env, jclass cls) { jclass cls_cat; jclass cls_animal; jmethodID mid_cat_init; jmethodID mid_run; jmethodID mid_getName; jstring c_str_name; jobject obj_cat; const char *name = NULL; // 1、获取Cat类的class引用 cls_cat = (*env)->FindClass(env, "com/study/jnilearn/Cat"); if (cls_cat == NULL) { return; } // 2、获取Cat的构造方法ID(构造方法的名统一为：&lt;init>) mid_cat_init = (*env)->GetMethodID(env, cls_cat, "&lt;init>", "(Ljava/lang/String;)V"); if (mid_cat_init == NULL) { return; // 没有找到只有一个参数为String的构造方法 } // 3、创建一个String对象，作为构造方法的参数 c_str_name = (*env)->NewStringUTF(env, "汤姆猫"); if (c_str_name == NULL) { return; // 创建字符串失败（内存不够） } // 4、创建Cat对象的实例(调用对象的构造方法并初始化对象) obj_cat = (*env)->NewObject(env,cls_cat, mid_cat_init,c_str_name); if (obj_cat == NULL) { return; } //-------------- 5、调用Cat父类Animal的run和getName方法 -------------- cls_animal = (*env)->FindClass(env, "com/study/jnilearn/Animal"); if (cls_animal == NULL) { return; } // 例1： 调用父类的run方法 mid_run = (*env)->GetMethodID(env, cls_animal, "run", "()V"); // 获取父类Animal中run方法的id if (mid_run == NULL) { return; } // 注意：obj_cat是Cat的实例，cls_animal是Animal的Class引用，mid_run是Animal类中的方法ID (*env)->CallNonvirtualVoidMethod(env, obj_cat, cls_animal, mid_run); // 例2：调用父类的getName方法 // 获取父类Animal中getName方法的id mid_getName = (*env)->GetMethodID(env, cls_animal, "getName", "()Ljava/lang/String;"); if (mid_getName == NULL) { return; } c_str_name = (*env)->CallNonvirtualObjectMethod(env, obj_cat, cls_animal, mid_getName); name = (*env)->GetStringUTFChars(env, c_str_name, NULL); printf("In C: Animal Name is %s\n", name); // 释放从java层获取到的字符串所分配的内存 (*env)->ReleaseStringUTFChars(env, c_str_name, name); quit: // 删除局部引用（jobject或jobject的子类才属于引用变量），允许VM释放被局部变量所引用的资源 (*env)->DeleteLocalRef(env, cls_cat); (*env)->DeleteLocalRef(env, cls_animal); (*env)->DeleteLocalRef(env, c_str_name); (*env)->DeleteLocalRef(env, obj_cat); } JNI调用性能测试及优化性能测试的结论 空方法调用，JNI的性能就要比Java内部调用慢将近5倍 查找class和ID(属性和方法ID)消耗的时间比较大-&gt;如果每次都根据名称查找class和field的话，性能要下降高达40倍，反复调用甚至能到达百万级别 消耗时间最多的就是查找class native里保存class和member id是很有必要的 class和member id在一定范围内是稳定的，但在动态加载的class loader下，保存全局的class要么可能失效使用时缓存示例：AccessCache.java`javapackage com.study.jnilearn; public class AccessCache { private String str = &quot;Hello&quot;; public native void accessField(); // 访问str成员变量 public native String newString(char[] chars, int len); // 根据字符数组和指定长度创建String对象 public static void main(String[] args) { AccessCache accessCache = new AccessCache(); accessCache.nativeMethod(); char chars[] = new char[7]; chars[0] = &#39;中&#39;; chars[1] = &#39;华&#39;; chars[2] = &#39;人&#39;; chars[3] = &#39;民&#39;; chars[4] = &#39;共&#39;; chars[5] = &#39;和&#39;; chars[6] = &#39;国&#39;; String str = accessCache.newString(chars, 6); System.out.println(str); } static { System.loadLibrary(&quot;AccessCache&quot;); } } ++AccessCache.c++ ```c // AccessCache.c #include &quot;com_study_jnilearn_AccessCache.h&quot; JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessCache_accessField (JNIEnv *env, jobject obj) { // 第一次访问时将字段存到内存数据区，直到程序结束才会释放，可以起到缓存的作用 static jfieldID fid_str = NULL; jclass cls_AccessCache; jstring j_str; const char *c_str; cls_AccessCache = (*env)-&gt;GetObjectClass(env, obj); // 获取该对象的Class引用 if (cls_AccessCache == NULL) { return; } // 先判断字段ID之前是否已经缓存过，如果已经缓存过则不进行查找 if (fid_str == NULL) { fid_str = (*env)-&gt;GetFieldID(env,cls_AccessCache,&quot;str&quot;,&quot;Ljava/lang/String;&quot;); // 再次判断是否找到该类的str字段 if (fid_str == NULL) { return; } } j_str = (*env)-&gt;GetObjectField(env, obj, fid_str); // 获取字段的值 c_str = (*env)-&gt;GetStringUTFChars(env, j_str, NULL); if (c_str == NULL) { return; // 内存不够 } printf(&quot;In C:\n str = \&quot;%s\&quot;\n&quot;, c_str); (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str); // 释放从从JVM新分配字符串的内存空间 // 修改字段的值 j_str = (*env)-&gt;NewStringUTF(env, &quot;12345&quot;); if (j_str == NULL) { return; } (*env)-&gt;SetObjectField(env, obj, fid_str, j_str); // 释放本地引用 (*env)-&gt;DeleteLocalRef(env,cls_AccessCache); (*env)-&gt;DeleteLocalRef(env,j_str); } JNIEXPORT jstring JNICALL Java_com_study_jnilearn_AccessCache_newString (JNIEnv *env, jobject obj, jcharArray j_char_arr, jint len) { jcharArray elemArray; jchar *chars = NULL; jstring j_str = NULL; static jclass cls_string = NULL; static jmethodID cid_string = NULL; // 注意：这里缓存局引用的做法是错误，这里做为一个反面教材提醒大家，下面会说到。 if (cls_string == NULL) { cls_string = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); if (cls_string == NULL) { return NULL; } } // 缓存String的构造方法ID if (cid_string == NULL) { cid_string = (*env)-&gt;GetMethodID(env, cls_string, &quot;&lt;init&gt;&quot;, &quot;([C)V&quot;); if (cid_string == NULL) { return NULL; } } printf(&quot;In C array Len: %d\n&quot;, len); // 创建一个字符数组 elemArray = (*env)-&gt;NewCharArray(env, len); if (elemArray == NULL) { return NULL; } // 获取数组的指针引用，注意：不能直接将jcharArray作为SetCharArrayRegion函数最后一个参数 chars = (*env)-&gt;GetCharArrayElements(env, j_char_arr,NULL); if (chars == NULL) { return NULL; } // 将Java字符数组中的内容复制指定长度到新的字符数组中 (*env)-&gt;SetCharArrayRegion(env, elemArray, 0, len, chars); // 调用String对象的构造方法，创建一个指定字符数组为内容的String对象 j_str = (*env)-&gt;NewObject(env, cls_string, cid_string, elemArray); // 释放本地引用 (*env)-&gt;DeleteLocalRef(env, elemArray); return j_str; } 类静态初始化缓存示例：AccessCache.java public class AccessCache { public static native void initIDs(); public native void nativeMethod(); public void callback() { System.out.println("AccessCache.callback invoked!"); } public static void main(String[] args) { AccessCache accessCache = new AccessCache(); accessCache.nativeMethod(); } static { System.loadLibrary("AccessCache"); initIDs(); } } ++AccessCache.c++ #include "com_study_jnilearn_AccessCache.h" jmethodID MID_AccessCache_callback; JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessCache_initIDs (JNIEnv *env, jclass cls) { printf("initIDs called!!!\n"); MID_AccessCache_callback = (*env)->GetMethodID(env,cls,"callback","()V"); } JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessCache_nativeMethod (JNIEnv *env, jobject obj) { printf("In C Java_com_study_jnilearn_AccessCache_nativeMethod called!!!\n"); (*env)->CallVoidMethod(env, obj, MID_AccessCache_callback); } 两种缓存方式比较使用时缓存缺点 每次都需要检查是否已经缓存该ID或Class引用 只要本地代码依赖于这个ID的值，那么这个类就不会被unload。 如果缓存发生在静态初始化时，当类被unload或reload时，ID会被重新计 JNI局部引用、全局引用和弱全局引用异常案例：Android JNI局部引用表溢出：local reference table overflow (max=512)Java 调用 // 返回count个sample相同的字符串数组，并用编号标识，如：sample1，sample2... public native String[] getStrings(int count, String sample); ++local_ref_overflow_test.c++ #include #include #include #include #include #define LOG_TAG "MainActivity" #define LOG_I(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG, __VA_ARGS__) #define LOG_E(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__) #ifdef __cplusplus extern "C" { #endif jobjectArray getStrings(JNIEnv *env, jobject obj, jint count, jstring sample) { jobjectArray str_array = NULL; jclass cls_string = NULL; jmethodID mid_string_init; jobject obj_str = NULL; const char *c_str_sample = NULL; char buff[256]; int i; // 保证至少可以创建3个局部引用（str_array，cls_string，obj_str） if ((*env)->EnsureLocalCapacity(env, 3) != JNI_OK) { return NULL; } c_str_sample = (*env)->GetStringUTFChars(env, sample, NULL); if (c_str_sample == NULL) { return NULL; } cls_string = (*env)->FindClass(env, "java/lang/String"); if (cls_string == NULL) { return NULL; } // 获取String的构造方法 mid_string_init = (*env)->GetMethodID(env, cls_string, "", "()V"); if (mid_string_init == NULL) { (*env)->DeleteLocalRef(env,cls_string); return NULL; } obj_str = (*env)->NewObject(env, cls_string, mid_string_init); if (obj_str == NULL) { (*env)->DeleteLocalRef(env,cls_string); return NULL; } // 创建一个字符串数组 str_array = (*env)->NewObjectArray(env, count, cls_string, obj_str); if (str_array == NULL) { (*env)->DeleteLocalRef(env,cls_string); (*env)->DeleteLocalRef(env,obj_str); return NULL; } // 给数组中每个元素赋值 for (i = 0; i < count; ++i) { memset(buff, 0, sizeof(buff)); // 初始一下缓冲区 sprintf(buff, c_str_sample,i); jstring newStr = (*env)->NewStringUTF(env, buff); (*env)->SetObjectArrayElement(env, str_array, i, newStr); (*env)->DeleteLocalRef(env,newStr); // Warning: 这里如果不手动释放局部引用，很有可能造成局部引用表溢出 } // 释放模板字符串所占的内存 (*env)->ReleaseStringUTFChars(env, sample, c_str_sample); // 释放局部引用所占用的资源 (*env)->DeleteLocalRef(env, cls_string); (*env)->DeleteLocalRef(env, obj_str); return str_array; } const JNINativeMethod g_methods[] = { {"getStrings", "(ILjava/lang/String;)[Ljava/lang/String;", (void*)getStrings} }; static jclass g_cls_MainActivity = NULL; JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { LOG_I("JNI_OnLoad method call begin"); JNIEnv* env = NULL; jclass cls = NULL; if((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } // 查找要加载的本地方法Class引用 cls = (*env)->FindClass(env, "com/example/jni/MainActivity"); if(cls == NULL) { return JNI_ERR; } // 将class的引用缓存到全局变量中 g_cls_MainActivity = (*env)->NewWeakGlobalRef(env, cls); (*env)->DeleteLocalRef(env, cls); // 手动删除局部引用是个好习惯 // 将java中的native方法与本地函数绑定 (*env)->RegisterNatives(env, g_cls_MainActivity, g_methods, sizeof(g_methods) / sizeof(g_methods[0])); LOG_I("JNI_OnLoad method call end"); return JNI_VERSION_1_6; } JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved) { LOG_I("JNI_OnUnload method call begin"); JNIEnv *env = NULL; if((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) { return; } (*env)->UnregisterNatives(env, g_cls_MainActivity); // so被卸载的时候解除注册 (*env)->DeleteWeakGlobalRef(env, g_cls_MainActivity); } #ifdef __cplusplus } #endif 三种引用简介及区别局部引用（Local Reference） 创建: NewLocalRef 或JNI接口创建（FindClass、NewObject、GetObjectClass和NewCharArray等） 特性： 会阻止GC回收所引用的对象 不在本地函数中跨函数使用 不能跨线程使用 释放 函数返回后局部引用所引用的对象会被JVM自动释放 调用DeleteLocalRef(*env)-&gt;DeleteLocalRef(env,local_ref)jclass cls_string = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); jcharArray charArr = (*env)-&gt;NewCharArray(env, len); jstring str_obj = (*env)-&gt;NewObject(env, cls_string, cid_string, elemArray); // 通过NewLocalRef函数创建 jstring str_obj_local_ref = (*env)-&gt;NewLocalRef(env,str_obj); .... 全局引用（Global Reference） 创建： NewGlobalRef 特性： 会阻GC回收所引用的对象基于局部引用创建 可以跨方法、跨线程使用 VM不会自动释放，必须调用DeleteGlobalRef手动释放(*env)-&gt;DeleteGlobalRef(env,g_cls_string)弱全局引用（Weak Global Reference） 创建： NewWeakGlobalRef基于局部引用或全局引用创建 特性： 不会阻止GC回收所引用的对象 可以跨方法、跨线程使用 释放： 1.比如内存紧张的时候；2. 调用DeleteWeakGlobalRef手动释放(*env)-&gt;DeleteWeakGlobalRef(env,g_cls_string)static jclass g_cls_string; void TestFunc(JNIEnv* env, jobject obj) { jclass cls_string = (*env)->FindClass(env, "java/lang/String"); g_cls_string = (*env)->NewWeakGlobalRef(env,cls_string); } 局部引用误区一: 用static变量缓存局部变量（变动），造成野指针； 本地方法返回到Java层之后，如果Java层没有对返回的局部引用使用的话，局部引用就会被JVM自动释放 误区二：局部引用不用释放 Android上的JNI局部引用表最大数量是512个，一些局部引用循环可能溢出for (i = 0; i < len; i++) { jstring jstr = (*env)->GetObjectArrayElement(env, arr, i); ... /* 使用jstr */ (*env)->DeleteLocalRef(env, jstr); // 使用完成之后马上释放 } 调用JNI工具函数时，返回的引用需要手动释放 局部引用占用大资源，但是函数不能立即结束时，如：占用资源后有大量的运算；JNIEXPORT void JNICALL Java_pkg_Cls_func(JNIEnv *env, jobject this) { lref = ... /* lref引用的是一个大的Java对象 */ ... /* 在这里已经处理完业务逻辑后，这个对象已经使用完了 */ (*env)-&gt;DeleteLocalRef(env, lref); /* 及时删除这个对这个大对象的引用，GC就可以对它回收，并释放相应的资源*/ lengthyComputation(); /* 在里有个比较耗时的计算过程 */ return; /* 计算完成之后，函数返回之前所有引用都已经释放 */ } 管理局部引用 JNI提供的引用的生命周期管理EnsureLocalCapacity、NewLocalRef、PushLocalFrame、PopLocalFrame、DeleteLocalRef。 JNI函数默认只支持16个局部引用，可以调用EnsureLocalCapacity增加局部引用数量，如果创建成功则返回0，否则创建失败，并抛出OutOfMemoryError异常；/*处理函数逻辑时，确保函数能创建len个局部引用*/ if((*env)-&gt;EnsureLocalCapacity(env,len) != 0) { ... /*申请len个局部引用的内存空间失败 OutOfMemoryError*/ return; } for(i=0; i &lt; len; i++) { jstring jstr = (*env)-&gt;GetObjectArrayElement(env, arr, i); // ... 使用jstr字符串 /*这里没有删除在for中临时创建的局部引用*/ } Push/PopLocalFrame引用堆栈#define N_REFS ... /*最大局部引用数量*/ for (i = 0; i &lt; len; i++) { if ((*env)-&gt;PushLocalFrame(env, N_REFS) != 0) { ... /*内存溢出*/ } jstring jstr = (*env)-&gt;GetObjectArrayElement(env, arr, i); ... /* 使用jstr */ (*env)-&gt;PopLocalFrame(env, NULL); } 全局引用++案例++ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_AccessCache_newString (JNIEnv *env, jobject obj, jcharArray j_char_arr, jint len) { // ... jstring jstr = NULL; static jclass cls_string = NULL; if (cls_string == NULL) { jclass local_cls_string = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); if (cls_string == NULL) { return NULL; } // 将java.lang.String类的Class引用缓存到全局引用当中 cls_string = (*env)-&gt;NewGlobalRef(env, local_cls_string); // 删除局部引用 (*env)-&gt;DeleteLocalRef(env, local_cls_string); // 再次验证全局引用是否创建成功 if (cls_string == NULL) { return NULL; } } // .... return jstr; } 弱全局引用与全局引用很重要不同的一点是，弱引用不会阻止GC回收它引用的对象 如果不手动调用这个函数来释放所指向的对象，JVM仍会回收弱引用所指向的对象，但弱引用本身在引用表中所占的内存永远也不会被回收。 ++案例：++ JNIEXPORT void JNICALL Java_mypkg_MyCls_f(JNIEnv *env, jobject self) { static jclass myCls2 = NULL; if (myCls2 == NULL) { jclass myCls2Local = (*env)-&gt;FindClass(env, &quot;mypkg/MyCls2&quot;); if (myCls2Local == NULL) { return; /* 没有找到mypkg/MyCls2这个类 */ } myCls2 = NewWeakGlobalRef(env, myCls2Local); if (myCls2 == NULL) { return; /* 内存溢出 */ } } ... /* 使用myCls2的引用 */ } 引用比较jboolean isEqual = (*env)-&gt;IsSameObject(env, obj1, obj2) obj1,obj2: 不管是全局、局部还是弱全局引用 isEqual JNI_TRUE（或者1）相同，JNI_FALSE（或者0） JNI中的NULL引用指向JVM中的null对象 局部或全局引用-&gt; (*env)-&gt;IsSameObject(env, obj, NULL) 或者 obj == NUL判断 弱全局引用 (*env)-&gt;IsSameObject(env, g_obj_ref, NULL) -&gt; 引用中是否仍然指向活动对象jobject local_obj_ref = (*env)-&gt;NewObject(env, xxx_cls,xxx_mid); jobject g_obj_ref = (*env)-&gt;NewWeakGlobalRef(env, local_ref); // ... 业务逻辑处理 jboolean isEqual = (*env)-&gt;IsSameObject(env, g_obj_ref, NULL); 小Tip基于全局引用创建一个局引用返回，也同样会阻止GC回收所引用的这个对象Push/PopLocalFrame是非常方便且安全的【建议使用】jobject f(JNIEnv *env, ...) { jobject result; if ((*env)->PushLocalFrame(env, 10) &lt; 0) { /* 调用PushLocalFrame获取10个局部引用失败，不需要调用PopLocalFrame */ return NULL; } ... result = ...; // 创建局部引用result if (...) { /* 返回前先弹出栈顶的frame */ result = (*env)->PopLocalFrame(env, result); return result; } ... result = (*env)->PopLocalFrame(env, result); /* 正常返回 */ return result; } JNI异常处理JNI 异常函数列表 异常函数 相关描述 ExceptionCheck 检查是否发生了异常，若有异常返回JNI_TRUE，否则返回JNI_FALSE ExceptionOccurred 检查是否发生了异常，若用异常返回该异常的引用，否则返回NULL ExceptionDescribe 打印异常的堆栈信息 ExceptionClear 清除异常堆栈信息 ThrowNew 在当前线程触发一个异常，并自定义输出异常信息 Throw 丢弃一个现有的异常对象，在当前线程触发一个新的异常 FatalError 致命异常，用于输出一个异常信息，并终止当前VM实例（即退出程序） void (JNICALL FatalError) (JNIEnv env, const char msg);jint (JNICALL ThrowNew) (JNIEnv env, jclass clazz, const char msg);jint (JNICALL Throw) (JNIEnv env, jthrowable obj); 异常处理示例public class JNIException { public static native void doit(); public static void exceptionCallback() { int a = 20 / 0; System.out.println("--->" + a); } public static void normalCallback() { System.out.println("In Java: invoke normalCallback."); } public static void main(String[] args) { doit(); } static { System.loadLibrary("JNIException"); } } ++JNIException.c++ #include "com_study_jnilearn_JNIException.h" #include &lt;stdio.h> JNIEXPORT void JNICALL Java_com_study_jnilearn_JNIException_doit(JNIEnv *env, jclass cls) { jthrowable exc = NULL; jmethodID mid = (*env)->GetStaticMethodID(env,cls,"exceptionCallback","()V"); if (mid != NULL) { (*env)->CallStaticVoidMethod(env,cls,mid); } printf("In C: Java_com_study_jnilearn_JNIException_doit-->called!!!!"); if ((*env)->ExceptionCheck(env)) { // 检查JNI调用是否有引发异常 (*env)->ExceptionDescribe(env); (*env)->ExceptionClear(env); // 清除引发的异常，在Java层不会打印异常的堆栈信息 (*env)->ThrowNew(env,(*env)->FindClass(env,"java/lang/Exception"),"JNI抛出的异常！"); //return; } //如果不return 程序继续执行 mid = (*env)->GetStaticMethodID(env,cls,"normalCallback","()V"); if (mid != NULL) { (*env)->CallStaticVoidMethod(env,cls,mid); } } ++JNIException.c++ ExceptionOccurred 改造,作用和ExceptionCheck一样，两者的区别在于返回值不一样 // .... jthrowable exc = NULL; exc = (*env)->ExceptionOccurred(env); // 返回一个指向当前异常对象的引用 if (exc) { (*env)->ExceptionDescribe(env); // 打印Java层抛出的异常堆栈信息 (*env)->ExceptionClear(env); //清除异常信息 // 抛出我们自己的异常处理 jclass newExcCls; newExcCls = (*env)->FindClass(env,"java/lang/Exception"); if (newExcCls == NULL) { return; } (*env)->ThrowNew(env, newExcCls, "throw from C Code."); /* 注意释放局部引用 */ (*env)->DeleteLocalRef(env, newExcCls); /*异常发生后释放资源*/ } // .... 异常发生后释放资源JNIEXPORT void JNICALL Java_pkg_Cls_f(JNIEnv *env, jclass cls, jstring jstr) { const jchar *cstr = (*env)-&gt;GetStringChars(env, jstr); if (c_str == NULL) { return; } ... if ((*env)-&gt;ExceptionCheck(env)) { /* 异常检查 */ (*env)-&gt;ReleaseStringChars(env, jstr, cstr); // 发生异常后释放前面所分配的内存 return; } ... /* 正常返回 */ (*env)-&gt;ReleaseStringChars(env, jstr, cstr); } 参考 JNI/NDK开发指南（开山篇） 推荐《Pro Android C++ with the NDK》，中文版名称《Android C++高级编程 使用NDK》]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化Android App]]></title>
    <url>%2F2018%2F08%2F07%2F2018-4-14-android-optimization%2F</url>
    <content type="text"><![CDATA[学习资源博文 Background Optimizations Facebook是如何收集其Android应用性能数据的 安卓性能优化收集网站 总结性 Android客户端性能优化（魅族资深工程师毫无保留奉献） Java Performance blog 性能分析的网站 NimbleDroid 一个 Android 应用性能分析服务网站 PageSpeed Insights 能够测试网页在移动设备和桌面设备上的性能工具 APM(Application performance magic) : 应用程序性能管理 2011年时国外的APM行业 NewRelic 和 APPDynamics 国内：听云， OneAPM， 博睿(bonree) 云智慧，阿里百川码力 针对性优化图片压缩Apk体积缩小 Luban 可能是最接近微信朋友圈的图片压缩算法 Shrink Your Code and Resources 【官方教程，未看】 Android微信上的SVG PNG图片压缩对比分析 通过三次优化，我将gif加载优化了16.9% EFFICIENTLY REDUCING YOUR METHOD COUNT APK瘦身实践 突破App启动时间的极限 an Intelij Plugin for image compress using TinyPNG API Android 图片压缩工具 网络优化 Offline App Archit ecture: how to build for the next billion DevBytes: Efficient Data Transfers — YouTube Google Engineer Serials tutorial ORG Optimizing Downloads for Efficient Network Access 美团点评移动网络优化实践 内存优化 Android内存优化杂谈 Android 内存优化总结&amp;实践 速度优化 Android启动速度优化 everbook has backup, Application.registerActivityLifecycleCallbacks的运用 给 App 提速：Android 性能优化总结 优化实践 内存泄漏 Memory Analyzer（MAT） Tool Leak Suspects：内存泄露报告 Top Components：吃货报告 Histogram：每个Class占用内存 Dominator Tree：列出哪些对象占用内存最多以及谁hold住这些对象 OQL (Ctrl + F5 run) select * from instanceof android.app.Activity Mat tutorial: 1） 使用Memory Analyzer tool(MAT)分析内存泄漏2） Video youtube Google I/O 2011: Memory management for Android Apps3） MAT - Memory Analyzer Tool 使用进阶4） 从MAT数据中还原Bitmap原图Docuemnt1) eclipse.org document MemoryAnalyzer2) developer.android investigating your RAM usageBlog adb 使用 检查应用退出后Activities/Views 是否为零;adb shell dumpsys meminfo [应用包名] 多次进入退出后的占用内存TOTAL不应变化太大； onTrimMemory回调 响应此回调释放非必须内存； 验证adb shell dumpsys gfxinfo 【应用包名】-cmd trim 5adb shell dumpsys meminfo 【应用包名】查看内存大小 UI卡顿和稳定性 工作线程优先级设置为Process.THREAD_PRIORITY_BACKGROUND 卡顿常见原因1）人为在UI线程中做轻微耗时操作，导致UI线程卡顿；2） 布局Layout过于复杂，无法在16ms内完成渲染；3）同一时间动画执行的次数过多，导致CPU或GPU负载过重；4） View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；5） View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；6）内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；7） 冗余资源及逻辑等导致加载和执行缓慢；8）工作线程优先级未设置为Process.THREAD_PRIORITY_BACKGROUND导致后台线程抢占UI线程cpu时间片，阻塞渲染操作；9） ANR；卡顿分析解决的一般步骤 解决过度绘制问题1) 调试GPU过度绘制中打开调试，看对应界面是否有过度绘制，如果有先解决掉：2) 定位过渡绘制区域3) 利用Android提供的工具进行位置确认以及修改(HierarchyView , Tracer for OpenGL ES)4) 定位到具体的视图(xml文件或者View)5) 通过代码和xml文件分析过渡绘制的原因6) 结合具体情况进行优化7) 使用Lint工具进一步优化 检查是否有主线程做了耗时操作：1) Application 开启 StrictMode;public void onCreate() { if (DEVELOPER_MODE) { StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectAll() .penaltyLog() .build()); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectAll() .penaltyLog() .build()); } super.onCreate(); } 如果主线程无耗时操作，还存在卡顿，有很大可能是必须在UI线程操作的一些逻辑有问题，比如控件measure、layout耗时过多等，此时可通过Traceview以及systrace来进行分析。 Traceview：Traceview主要用做热点分析，找出最需要优化的点。 systrace：抓取trace： 使用hugo打印方法调用的时长及参数 Method Tracing 优化启动时间官网：Generate trace logs by instrumenting your appJava 代码android.os.Debug.startMethodTracing() 和 stopMethodTracing() # 启动HomePageActivity并每1s跟踪方法调用 adb shell am start -n com.runan.countprisoner/.view.activity.HomePageActivity --start-profiler /data/local/tmp/startup.trace --sampling 1000 终止跟踪 adb shell am profile stop # 拉取 .trace 文件到本机当前目录 adb pull /data/local/tmp/startup.trace . Android Studio -&gt; File -&gt; open 直接打开*.trace 官方工具 Android Monitor Allocation Tracker Device Monitor Viewing Overall Memory Allocations 参考 Investigating Your RAM Usage adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d] 【难点】 对meminfo 的解读 Dalvik/ART Log Messages 【难点】解读 Testing Display Performance 十分详细的关于显示优化的介绍。 第三方工具 由腾讯出品的GT（随身调），直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug Environment)，支持iOS和Android两个手机平台,主要功能可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。还提高基础API进行开发。 LeakCanary yourkit Java Profiler, and square/leakcanary recommend to use memory leak analyzer like mat FlatBuffers：性能最高的序列化库，由 Google 游戏开发小组专为性能而设计 Parcelable API：Android 进程间传递数据，性能远优于 Java 默认序列化机制 BlockCanaryEx 加速你的Android应用 保险套项目 Note : 『保险套』是一个超轻超薄的Android工具库，将它套在Android应用工程里裸露的Context上，再传入第三方SDK（通常是其初始化方法），即可防止三方SDK损害用户体验 常用小Tips SparseArray ——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。 查看Activity启动时间adb shell am start -W com.niuwa/.activity.HomePageActivity 参考： http://blog.tingyun.com/web/article/detail/155 Android P 电量管理 Android vitals]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程控制笔记整理]]></title>
    <url>%2F2018%2F08%2F07%2F2018-8-7-remote-control%2F</url>
    <content type="text"><![CDATA[视频流播放相关相关开源库 FFmpeg Libstreaming A solution for streaming H.264, H.263, AMR, AAC using RTP on Android RemoteDroid 能运行但是链接失败 android-eye Gstreamer-Android-example EasyDarwin 高性能开源流媒体服务器，支持RTSP、HLS、HTTP直播 ————– 官网 spydroid-ipcamera A powerful and funny android app. that streams the camera and microphone of your phone to your browser or to VLC libstreaming libstreaming-examples Google开源播放器 ExoPlayer 教程 最简单的基于FFmpeg的移动端例子：Android 视频转码器 Android本地视频播放器开发–ffmpeg解码视频文件中的音频(1) java 调用 ffmpeg 进行视频转换以及截图 FFmpeg 抽取视频中的一段(视频转换) [总结]FFMPEG视音频编解码零基础学习方法 重点 GStreamer SDK Tutorials 手机Android音视频采集与直播推送，实现单兵、移动监控类应用 实践笔记积累 Wowza Streaming Engine sudo service WowzaStreamingEngine start sudo service WowzaStreamingEngineManager start 访问 http://[wowza-ip-address]:8088/enginemanager http://localhost:8088/enginemanager/#home/_defaultVHost_ 视频发布账号和密码：/usr/local/WowzaStreamingEngine/conf/publish.password 网络相关学习 Socket.io资源列举 Get Started: Chat application （基于Node.js html）炒鸡简单的例子，无需编程经验 github github.com/socket.io socket.io-android-chat engine.io-client-java Engine.IO Client Library for Java JavaApidocs socket.io-redis libjitsi Advanced Java media library for secure real-time audio/video communication. 基础知识 网络大爬虫 SSL/TLS协议运行机制的概述 SOCKET通信中TCP、UDP数据包大小的确定 关于网络编程中MTU、TCP、UDP优化配置的一些总结 Blog Introducing Socket.IO 1.0 socket-io-p2p 试验UDP打洞穿透NAT Interactive Connectivity Establishment (ICE) ice4j code .google ice4j 资源交老 https://github.com/jitsi/ice4j 比较新的资源 ice4j Javadoc rfc5245.pdf jain-sip jain-sdp 获取Sdp源码 restcomm-android-sdk Tutorial https://telestax.com/jain-sip-stack-for-android/ libnice libnice-4-android Api documentation Englis PDF Material rfc4566 SDP: Session Description Protocol rfc5928 Traversal Using Relays around NAT (TURN) Resolution Mechanism rfc5766.pdf Traversal Using Relays around NAT (TURN):Relay Extensions to Session Traversal Utilities for NAT (STUN) rfc5245 Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols UDP打洞 QQ通信原理及QQ是怎么穿透内网进行通信的 P2P技术揭秘-P2P网络技术原理与典型系统开发 教程下载 webrtc turnserverdownloadsImportant directory:/usr/local/share/examples/turnserverhttp://66.228.45.110/ 免费申请 账号的网站比较详细的turnserver.conf配置说明 Node.jsLearning resource http://nodeschool.io/#workshoppers openSource node-express-mongoose-demo Module http://samhuri.net/projects/strftime Tutorial Node.js Tutorial – Step-by-Step Guide For Getting Started Tool npm install -g node-inspector # basically `node-debug` instead of `node` $ node-debug example.js https://developers.google.com/web/tools/setup/ 数据传输数据转码 Convert bitmap array to YUV (YCbCr NV21) Appending a byte[] to the end of another byte[] Android 用MediaCodec实现视频硬解码 MediaCodec Api) 数据校验 传输数据校验算法研究 WebRTC Introduction to WebRTC on Android Android IOS WebRTC 音视频开发总结列表 https://webrtc.org/ Getting Started with WebRTC WebRTC samples 有各种Sample代码Html/js演示，并有对应Github源 码地址， 整个工程的samples Native APIs Diagram AndroidRTC 相关博文 WebRTC VideoEngine综合应用示例（一）——视频通话的基本流程 参考文章 控制相关 Android模拟产生事件 概括分析了模拟事件的三种方式，而且文章格式很喜欢 Input Technical Information Android Source 关于android devices input 的说明，偏底层 ； getevent/sendevent及 input 命令的详解 截屏相关 Android中使用代码截图的各种方法总结 视频相关 FFmpeg深入分析之零-基础 FFmpeg的Android平台移植—编译篇 Android中实时视频传输(摄像头实时视频传输)解决方案&lt;二&gt; android视频录制、另一部手机实时观看方案 重点 android视频处理相关资料 重点 资料http://www.ffmpeg.org/ffmpeg.htmlEzStreamSvr 一个流媒体传输服务器端GStreamer open source multimedia framework]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程中好用工具]]></title>
    <url>%2F2018%2F08%2F03%2F2018-8-3-coder-software%2F</url>
    <content type="text"><![CDATA[记录 terminalizer 录制终端命令行并转化成gif]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio用Cmake方式编译NDK代码]]></title>
    <url>%2F2018%2F08%2F01%2F2018-8-1-cmake-note%2F</url>
    <content type="text"><![CDATA[基础知识1.cmake是什么？ CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。 谷歌从AndroidStudio2.2以上就添加了Cmake方式来编译NDK代码，并从NDK例子看出，默认编译的方式就是cmake方式。 创建Android studio ndk工程傻瓜式操作 新建一个工程点击如下：然后把C/Cpp代码复制到src/main/cpp下，配置 CMakeLists.txt 手动配置 在src/main下新建jni或者cpp目录， 新建CMakeLists.txt,推荐目录/src/main/jni/CMakeLists.txt,如下为默认生成的格式：`For more information about using CMake with Android Studio, read thedocumentation: https://d.android.com/studio/projects/add-native-code.html Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1) Creates and names a library, sets it as either STATICor SHARED, and provides the relative paths to its source code.You can define multiple libraries, and CMake builds them for you.Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp ) Searches for a specified prebuilt library and stores the path as avariable. Because CMake includes system libraries in the search path bydefault, you only need to specify the name of the public NDK libraryyou want to add. CMake verifies that the library exists beforecompleting its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log ) Specifies libraries CMake should link to your target library. Youcan link multiple libraries, such as libraries you define in thisbuild script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. ${log-lib} ) 3. 并在build.gradle下关联CMakeLists.txt externalNativeBuild { cmake { //默认和build.gradle同一目录： path “CMakeLists.txt” path “/src/main/jni/CMakeLists.txt” } } 4. 配置gradle脚本 android { compileSdkVersion 28 defaultConfig { … externalNativeBuild { cmake { // Passes optional arguments to CMake. arguments &quot;-DCMAKE_VERBOSE_MAKEFILE=TRUE&quot; // Sets optional flags for the C compiler. cFlags &quot;-D_EXAMPLE_C_FLAG1&quot;, &quot;-D_EXAMPLE_C_FLAG2&quot; // Sets a flag to enable format macro constants for the C++ compiler. // -frtti: Runtime Type Information Support // -fexceptions : Exception Support //-std=c++14 : C++ Library Support cppFlags &quot;-D__STDC_FORMAT_MACROS&quot; //更多 arguments https://developer.android.com/ndk/guides/cmake } } ndk { // &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, //指定生成的CPU架构 Specifies the ABI configurations of your native abiFilters &#39;armeabi-v7a&#39; } } externalNativeBuild { cmake { //默认和build.gradle同一目录： path “CMakeLists.txt” path “/src/main/jni/CMakeLists.txt” } } buildTypes { … }} ### 配置 CMake 构建脚本 如果您的原生源文件还没有 CMake 构建脚本，则您需要自行创建一个并包含适当的 CMake 命令。CMake 构建脚本是一个纯文本文件，您必须将其命名为 `CMakeLists.txt`。本部分介绍了您应包含到构建脚本中的一些基本命令，用于在创建原生库时指示 CMake 应使用哪些源文件。 **注**：如果您的项目使用 ndk-build，则不需要创建 CMake 构建脚本。提供一个指向您的 [`Android.mk`](https://developer.android.google.cn/ndk/guides/android_mk.html) 文件的路径，[将 Gradle 关联到您的原生库](https://developer.android.google.cn/studio/projects/add-native-code.html#link-gradle)。 要创建一个可以用作 CMake 构建脚本的纯文本文件，请按以下步骤操作： 1. 从 IDE 的左侧打开 **Project** 窗格并从下拉菜单中选择 **Project** 视图。 2. 右键点击**您的模块**的根目录并选择 **New &gt; File**。 **注**：您可以在所需的任意位置创建构建脚本。不过，在配置构建脚本时，原生源文件和库的路径将与构建脚本的位置相关。 3. 输入“CMakeLists.txt”作为文件名并点击 **OK**。 #### add_library 现在，您可以添加 CMake 命令，对您的构建脚本进行配置。要指示 CMake 从原生源代码创建一个原生库，请将 [`cmake_minimum_required()`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html) 和 [`add_library()`](https://cmake.org/cmake/help/latest/command/add_library.html) 命令添加到您的构建脚本中： ```shell # Sets the minimum version of CMake required to build your native library. # This ensures that a certain set of CMake features is available to # your build. cmake_minimum_required(VERSION 3.4.1) # Specifies a library name, specifies whether the library is STATIC or # SHARED, and provides relative paths to the source code. You can # define multiple libraries by adding multiple add.library() commands, # and CMake builds them for you. When you build your app, Gradle # automatically packages shared libraries with your APK. add_library( # Specifies the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp ) 使用 add_library() 向您的 CMake 构建脚本添加源文件或库时，Android Studio 还会在您同步项目后在 Project 视图下显示关联的标头文件。不过，为了确保 CMake 可以在编译时定位您的标头文件，您需要将 include_directories() 命令添加到 CMake 构建脚本中并指定标头的路径： add_library(...) \# Specifies a path to native header files. include_directories(src/main/cpp/include/) CMake 使用以下规范来为库文件命名： lib库名称.so 例如，如果您在构建脚本中指定“native-lib”作为共享库的名称，CMake 将创建一个名称为 libnative-lib.so 的文件。不过，在 Java 代码中加载此库时，请使用您在 CMake 构建脚本中指定的名称： static { System.loadLibrary(“native-lib”); } 注：如果您在 CMake 构建脚本中重命名或移除某个库，您需要先清理项目，Gradle 随后才会应用更改或者从 APK 中移除旧版本的库。要清理项目，请从菜单栏中选择 Build &gt; Clean Project。 Android Studio 会自动将源文件和标头添加到 Project 窗格的 cpp 组中。使用多个 add_library() 命令，您可以为 CMake 定义要从其他源文件构建的更多库。 添加 NDK APIAndroid NDK 提供了一套实用的原生 API 和库。通过将 NDK 库包含到项目的 CMakeLists.txt 脚本文件中，您可以使用这些 API 中的任意一种。 预构建的 NDK 库已经存在于 Android 平台上，因此，您无需再构建或将其封装到 APK 中。由于 NDK 库已经是 CMake 搜索路径的一部分，您甚至不需要在您的本地 NDK 安装中指定库的位置 - 只需要向 CMake 提供您希望使用的库的名称，并将其关联到您自己的原生库。 将 find_library() 命令添加到您的 CMake 构建脚本中以定位 NDK 库，并将其路径存储为一个变量。您可以使用此变量在构建脚本的其他部分引用 NDK 库。以下示例可以定位 Android 特定的日志支持库并将其路径存储在 log-lib 中： find_library( # Defines the name of the path variable that stores the # location of the NDK library. log-lib # Specifies the name of the NDK library that # CMake needs to locate. log ) 为了确保您的原生库可以在 log 库中调用函数，您需要使用 CMake 构建脚本中的 target_link_libraries() 命令关联库： find_library(...) \# Links your native library against one or more other native libraries. target_link_libraries( # Specifies the target library. native-lib # Links the log library to the target library. ${log-lib} ) NDK 还以源代码的形式包含一些库，您在构建和关联到您的原生库时需要使用这些代码。您可以使用 CMake 构建脚本中的 add_library() 命令，将源代码编译到原生库中。要提供本地 NDK 库的路径，您可以使用 ANDROID_NDK 路径变量，Android Studio 会自动为您定义此变量。 以下命令可以指示 CMake 构建 android_native_app_glue.c，后者会将 NativeActivity 生命周期事件和触摸输入置于静态库中并将静态库关联到 native-lib： add_library( app-glue STATIC ${ANDROID\_NDK}/sources/android/native\_app\_glue/android\_native\_app\_glue.c ) \# You need to link static libraries against your shared native library. target_link_libraries( native-lib app-glue ${log-lib} ) 添加其他预构建库导入so库添加预构建库与为 CMake 指定要构建的另一个原生库类似。不过，由于库已经预先构建，您需要使用 IMPORTED 标志告知 CMake 您只希望将库导入到项目中： add_library( imported-lib SHARED IMPORTED ) 然后，您需要使用 set_target_properties() 命令指定库的路径，如下所示。 某些库为特定的 CPU 架构（或应用二进制接口 (ABI)）提供了单独的软件包，并将其组织到单独的目录中。此方法既有助于库充分利用特定的 CPU 架构，又能让您仅使用所需的库版本。要向 CMake 构建脚本中添加库的多个 ABI 版本，而不必为库的每个版本编写多个命令，您可以使用 ANDROID_ABI 路径变量。此变量使用 NDK 支持的一组默认 ABI，或者您手动配置 Gradle 而让其使用的一组经过筛选的 ABI。例如： add_library(...) set_target_properties( # Specifies the target library. imported-lib # Specifies the parameter you want to define. PROPERTIES IMPORTED_LOCATION # Provides the path to the library you want to import. imported-lib/src/${ANDROID_ABI}/libimported-lib.so ) 为了确保 CMake 可以在编译时定位您的标头文件，您需要使用 include_directories() 命令，并包含标头文件的路径： include_directories( imported-lib/include/ ) 注：如果您希望封装一个并不是构建时依赖项的预构建库（例如在添加属于 imported-lib 依赖项的预构建库时），则不需要执行以下说明来关联库。 要将预构建库关联到您自己的原生库，请将其添加到 CMake 构建脚本的 target_link_libraries() 命令中： target_link_libraries( native-lib imported-lib app-glue ${log-lib} ) 在您构建应用时，Gradle 会自动将导入的库封装到 APK 中。您可以使用 APK 分析器验证 Gradle 将哪些库封装到您的 APK 中。如需了解有关 CMake 命令的详细信息，请参阅 CMake 文档。 导入.a静态库android studio cmake 配置.a连接库 实战小案例指定 C++标准externalNativeBuild { cmake { cppFlags &quot;-frtti -fexceptions -std=c++14&quot; arguments &#39;-DANDROID_STL=c++_shared&#39; } } 编译一个目录中所有源文件# aux_source_directory 方法将路径列表全部放到一个变量中 aux_source_directory(${CMAKE_HOME_DIRECTORY}/src/api SRC_LIST) aux_source_directory(${CMAKE_HOME_DIRECTORY}/src/core CORE_SRC_LIST) # 拼接到路径列表 list(APPEND SRC_LIST ${CORE_SRC_LIST}) add_library(native-lib SHARED ${SRC_LIST}) 调试 message 方法打印cmake_minimum_required(VERSION 3.4.1) message(STATUS &quot;execute CMakeLists&quot;) # 日志输出==&gt; .externalNativeBuild/cmake/debug/{abi}/cmake_build_output.txt CMakeLists.txt 改动什么时候执行sync 其他的时候只是出来缓存 测试了下，好像在 sync 的时候会执行。执行一次后会生成 makefile 的文件缓存之类的东西放在 externalNativeBuild 中。所以如果 CMakeLists.txt 中没有修改的话再次同步好像是不会重新执行的。（或者删除 .externalNativeBuild 目录）真正编译的时候好像只是读取.externalNativeBuild 目录中已经解析好的 makefile 去编译。不会再去执行 CMakeLists.txt 教程 官方7step入门教程： cmake-tutorial 【英文】 翻译： CMAKE官网教程 并有相关方法的详解 进阶Book: Mastering CMake 资料文献 CMake 手册详解（一） android ndk guides Introduction Building Architectures and CPUs Debugging and Profiling Libraries 安卓各版本提供可调用ndk库 High-Performance Audio 一些流行的底层的第三方库Simpleperf/ OpenSL ES/Vulkan/Machine Learning googlesamples/android-ndk CMake 官方文档 JNI 框架官方文档 参考 gcc程序的编译过程和链接原理 AndroidStudio用Cmake方式编译NDK代码 Android增量更新与CMake构建工具 跟我一起写 Makefile Android NDK开发扫盲及最新CMake的编译使用]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>cmake</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本UI空控件的用方法和属性]]></title>
    <url>%2F2018%2F07%2F03%2F2018-7-3-ui-open-source%2F</url>
    <content type="text"><![CDATA[提示类型Tosat GlideToast 工具类型 MaterialDateTimePicker 质感设计日期时间选择器 输入 Pattern Lock View 九宫格解锁]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 图片和文字开源库]]></title>
    <url>%2F2018%2F06%2F01%2F2018-6-1-font-img-tools%2F</url>
    <content type="text"><![CDATA[图片图片样式处理PloyFun 加载样式 加载样式]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>图片</tag>
        <tag>文字</tag>
        <tag>font</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网页工具]]></title>
    <url>%2F2018%2F05%2F05%2F2018-5-5-android-web-tools%2F</url>
    <content type="text"><![CDATA[看代码 codota 查询代码案例 查看不同版本Android，JDK源码 Android Framwork 源码查看 sourcegraph 基于网页端和Git的智能源码查看工具，可以本地安装 依赖 maven 仓库中搜索依赖 统计依赖大小，方法数量的变化 开源项目查找 GitHub 搜索 工具 json转化 Free Online IDE and Terminal 支持几乎所有主流编程语言的在线IDE terminalizer 录制终端命令行并转化成gif]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇葩说娱乐笔记]]></title>
    <url>%2F2018%2F04%2F20%2F2018-4-20-entertainment-fancy-talk%2F</url>
    <content type="text"><![CDATA[奇葩说第4季分手要不要当面说 20170414刘白范甜甜 他提出不公平，最爱的人否定伤得最深； 永开 分手的理由都是不对 把爱看太重 把爱情当成婚姻一样沉重，轻松的开始轻松的结束，把感情看得太重而不会享受感情—– 反驳受众是把分手看特很重的人群（这样这个辩题才有意义） 赵大情 热恋痛离 爱情观，热烈真诚而且深刻–恋爱的代价–更加珍贵分手的痛相对于见面的心动，微信的分手不配我的爱情 邱晨 分手好好说话；不要增加分手成本搞分手纪念日烧纸，对方要分手增加成本这样你就不敢分手了分手发生的情景 真实的分手的情况，切断信号，你们想象的是盛大闭幕式的烟花表演，分手是所有的烟花散去之过后，无尽的空洞和冷漠我们要分手就是我们没有办法从爱情这所学校毕业了，现在你要求我们要进行一场退学考试，甚至是退学面试，为什么，但凡我们有一丝一毫的勇气我们能不能用来在一起，而不是用来分开上 马微微 逃过生离，逃不过死离，需直面生活渣字被你一写变狂草了，书法艺术家呀，忽悠人忽悠得这么深情款款，让我觉得没有被你甩一次是我人生的大不幸呀成年人的决定 人生必修的一堂课，叫做当面分手，教会了我们什么，教会我们学会面对，坦然面对，面对我们的失败，面对我们的不堪逃避 每次逃走留下的烂摊子，最后都会成为你人生中无法收拾的烂尾楼吗？ 成年人的决定，想象超人想象特工是一种逃避逃不过 但是人生总有逃不过的时候，体体面面的分手从此在没有相见,这是成年人的分手，面对自己，面对对方。逃得过生离，逃得过死别吗 面对不完美的结局，并体面的收拾自己的烂摊子，人生必须处处 锥心，才有真心成熟而全面的决定 感性和理想票两票 其他 爱没有公不公平，只有愿不愿意，无法回到从前 单身狗，直男脱单，难于脱贫 两票，正常人只有感谢票，还他妈看脸，撕逼后我当时怎么就蒙住了呢，不当面能更好的撕 导师总结 不再驾驭感情，而是懂得感激；什么是驾驭感情，你在设计一种模式，比如说感激应该漂漂亮亮，感激应该是轻松的。感激这个事情是两个人的事情，是两个人最后化反的最终结果，你只能懂得我想我们不需要再继续走下去了，至少我觉得有困难，你是希望当面聊一聊，你还是希望这样就好了，那我随时在这里 辩题前提是一个人想见，一个人不见，不如不见 结辩 【重点】 该做不到，交代 两个底线1.我们在一起绝不互相绑架，一定要尊重对方的意志 我们不在一起我们绝不互相伤害，我们要文明。幼稚的定义，目标既定的情况下采取的策略是错的。– 你想分就分见个面就分幼稚— 我的目标是什么， 成人的世界没有态度的该不该，我的价值观稳定情况下，我设定的目标怎样拆解成方法和行动— 我的目标是分手而且对对方的伤害降得最低— 具体比抽象更伤害越抽象越尊重越不伤害– 长大 遇到危险伴侣手刀（快速逃跑）逃跑 该不该原谅他 20170421 赵又廷撒狗粮三生三世只爱高圆圆 马贱越爱情可以战胜一切，只要你爱他，就原谅他，否则，只做单身狗，只做自己 首尔 本能和本能之间差出和谐的火花 类比吵架维持内心和谐的次序，问路大叔，半身水池 烂事和惩罚的平衡 不原谅是对自己的一种救赎，原谅伴随着你对人性弱点的接纳和妥协，这样你会只相信人性，不相信人#### 灾难来了谁都得跑； 男的站着，女的跑 中国感动是教育（灾难面前人人都平等），我们以为人类仿佛应该是这样的，如果ta没做到这样子，ta就是不对的，其实他做到这样子，你更应该感谢的。因为，我们希望我们的爱情是获得式的爱情，不是索取式的爱情，他给你了你很高兴，他没给你这也很正常。感动时刻–&gt; 这个是加分项，不是底线，ta做到了你要感谢他 不原谅，放不下。灾难来了，没有太大的价值去怀念去铭记，你既是慷他之慨，也是慷自己之慨。浙大美女学霸 双重标准，爱情观中清单不可原谅的事情上，下面该不该原谅。张爱玲和胡兰成的事情，没有守住底线。爱情双方是增值的过程。 爱情能战胜一些本能的欲望与诉求； 因为我还是对爱情有一点点底线，一点点要求的人，我不希望我别成一个爱情只对我有要求的人，我不希望我变成爱情的努力。 永开 见死不救和灾难不同 可逃不可逃，为什么这个情景我们希望对方能活下来，为什么我们心中不原谅的情绪，我们不原谅的是那一个没有办法全心全意为对方担心的自己 自己的故事，如果恨我能让你感觉舒服一点点的话那你就恨我吧，没关系的。恨他没有让我得到救赎，甚至盖过了我幸福的瞬间 这对双方都是灾难 段子医生 有判断的，心里创伤 原谅和不原谅都轻描淡写了，所有说不原谅就是不要轻易的原谅； 呼唤爱 五秒性格，决定一生太鲁莽导师结辩-]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计相关]]></title>
    <url>%2F2018%2F04%2F15%2F2018-4-15-designer%2F</url>
    <content type="text"><![CDATA[相关开源库AE动画设计 + lottie-android 【简易的惊艳动画.必看】 fack-rebound 弹性动画 有网页Demo 能大大的提高用户体验 代码开源库控件 Genius-Android]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio 使用总结]]></title>
    <url>%2F2018%2F04%2F15%2F2018-4-15-android-studio-usage%2F</url>
    <content type="text"><![CDATA[常用插件 ADB Comand 3星 GsonFormatString 解析成实体 Default Option + s(Mac), Alt + s (win) Key Promoter X 快捷键提示 AS plugin 搜索安装 codota 代码案例查找【重点】 快捷键 Shift + Alt + Space CodeGlance 代码概况 Parcelable Plugin JarFilterPlugin 修改第三方Jar并打包进应用，如可以借助 JarFilterPlugin 来修改 Retrofit 的内部代码 优化 dexcount-gradle-plugin 每次编译都统计Field and Method number UI android-drawable-importer android-selector Material Design Icon Generator Android-drawable-preview-plugin Android Styler 相对于AS提供的功能，这个优势在能指定style存放的文件及相对的位置； 其他 idea-multimarkdown【收费】 gradle-maven-publish-plugin 上传你的代码到所有的版本仓库中 DepSwitchPlugin aar和源码切换，开发阶段源码，稳定阶段用aar 高级Android studio 插件的开发 How to Develop Android Studio Plugin]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android studio</tag>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 常用开源库]]></title>
    <url>%2F2018%2F04%2F14%2F2018-4-14-android-open-source-tools%2F</url>
    <content type="text"><![CDATA[正在研究 SUtils 封装有许多实用的开发工具类 APKParser parceler通过注解的方式序列化对象more: Transfuse Transfuse is a Java Dependency Injection (DI) and integration library geared specifically for the Google Android API. 数据库工具 android-sqlite-asset-helper 构建工具 MultiChannelPackageTool 快速多渠道打包工具。 开发中实用的工具 RoboGif A small utility to record Android device screen to a GIF AppUninstall Android App监听自身卸载，反馈统计 UI AndroidDesignPreview AndroidAssetStudio Android常用图标生成Web 切图标记外挂神器 Assistor PS 介绍 动态修改App字符开源库 Philology检测优化工具 LeakCanary Android 和 Java 内存泄露检测Tutorial ChineseEnglishphrof file path: /storage/sdcard0/Download/leakcanary/hprof-conv leakCanary apk-method-count 上传Apk，可以根据包名统计方法数量的网站，UI很友好。 battery-historian Google 官网方 针对 Api21 5.0以上系统开发的电量使用情况分析工具 功能性开发工具 card.io-Android-source 信用卡扫描ＳＤＫ reprint A simple, unified fingerprint authentication library for Android with ReactiveX extensions. DimensCodeTools 一个可以支持生成二维码，条形码和扫描的库 Permission Dexter Dexter is an Android library that simplifies the process of requesting permissions at runtime. PermissionHelper easypermissions 图片加载PicassoUniversal-ImageLoaderVolleyGlide Tutorial Chinese综合： 开源组件加载网络图片的优缺点比较 FileDownload Android-Download-Manager-Pro MultiThreadDownloader 下载 FileDownloader Multitask、Breakpoint-resume、High-concurrency、Simple to use、Single-process Once some info may show once in a new app in a update or first time install this via share sharedPreferences sore the timestamp 基础的开发工具 JavaVerbalExpressions Java regular expressions made easy. 帮助简单的实现正则表达 joda-time-android／ThreeTenABP Java8 的Date包移植到Android中来的库 MathView A library for displaying math formula in Android apps.崩溃错误处理LoadSir 优雅地处理加载中，重试，无数据等配置: compile ‘com.kingja.loadsir:loadsir:1.3.6’ProGuard:-dontwarn com.kingja.loadsir.** -keep class com.kingja.loadsir.** {*;} BufferKnifeVIEW LISTS@OnClick({ R.id.door1, R.id.door2, R.id.door3 }) @BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name }) List&lt;EditText&gt; nameViews; // The apply method allows you to act on all the views in a list at once. ButterKnife.apply(nameViews, DISABLE); ButterKnife.apply(nameViews, ENABLED, false); //Action and Setter interfaces allow specifying simple behavior. static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() { @Override public void apply(View view, int index) { view.setEnabled(false); } }; static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() { @Override public void set(View view, Boolean value, int index) { view.setEnabled(value); } }; An Android Property can also be used with the apply method.ButterKnife.apply(nameViews, View.ALPHA, 0.0f); RESOURCE BINDINGclass ExampleActivity extends Activity { @BindString(R.string.title) String title; @BindDrawable(R.drawable.graphic) Drawable graphic; @BindColor(R.color.red) int red; // int or ColorStateList field @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field // ... } automatically be cast.@OnClick(R.id.submit) public void sayHi(Button button) { button.setText(&quot;Hello!&quot;); } OPTIONAL BINDINGS@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() { // TODO ... } BINDING RESET on Fragments @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fancy_fragment, container, false); unbinder = ButterKnife.bind(this, view); // TODO Use fields... return view; } @Override public void onDestroyView() { super.onDestroyView(); unbinder.unbind(); }]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 代码规范化笔记]]></title>
    <url>%2F2018%2F04%2F14%2F2018-4-14-android-standards%2F</url>
    <content type="text"><![CDATA[代码规范化工具Square Android Code Style 下载-&gt; install.xx -&gt; restart-&gt;Code Style -&gt; Java 代码格式快捷键： Mac Cmd + Option + L Win Ctrl + Alt + LAS Plugin checkstyle-idea 安装plugin-&gt; reatart-&gt; Setting Other Setting -&gt; 可以导入自定义检查 运行 提交代码时自动格式化]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密钥和证书管理工具Keytool及jarsigner的使用]]></title>
    <url>%2F2017%2F04%2F19%2F2017-04-19-keytool_signerJar%2F</url>
    <content type="text"><![CDATA[Keytool简介keytool 是JDK 1.4 后集成的密钥和证书管理工具 官网文档·英文 Window：&lt;JAVA_HOME&gt;\bin\keytool.exeMac: &lt;JAVA_HOME&gt;/Contents/Home/bin 生成keystorekeytool -genkey -alias myAlias -keyalg RSA -validity 40000 -keystore demo.keystore #说明： # -genkey 产生密钥 # -alias myAlias 别名 myAlias # -keyalg RSA 使用RSA算法对签名加密 # -validity 40000 有效期限4000天 # -keystore demo.keystore 查看 keystore签名信息keytool -list -keystore demo.keystore 输出结果： -------------- 密钥库类型: JKS 密钥库提供方: SUN 您的密钥库包含 1 个条目 myAlias, 2017-4-19, PrivateKeyEntry, 证书指纹 (SHA1): C1:4E:A3:BC:4D:C3:35:6C:F6:8A:9D:0E:EA:F3:79:4B:D9:1D:B4:C1 对apk进行签名jarsigner -verbose -keystore [demo.keystore] -signedjar demo_signed.apk demo.apk [alias] Shell脚本获取指纹 【成果】Apk签名证书MD5指纹echo.sh #/bin/sh cert_XSA=`jar tf $1 | grep SA` #获取签名文件在Apk中路径, $1为输入的apk #echo $cert_XSA jar xf $1 $cert_XSA #提取签名文件 echo -------------------------------------------------------------------------- echo 证书MD5指纹:`keytool -printcert -file $cert_XSA | grep MD5` echo -------------------------------------------------------------------------- rm -rf `dirname $cert_XSA` #删除提取的文件夹 Usage： source echo.sh demo.apk 证书文件操作 导出到证书文件keytool -export -alias myAlias -file test.crt -keystore test.keystore 将名为test.keystore的证书库中别名为test1的证书条目导出到证书文件test.crt 导入证书的信息keytool -import -keystore test_cacerts -file test.crt 将证书文件test.crt导入到名为test_cacerts的证书库中 查看证书信息`shellkeytool -printcert -file “test.crt”输出结果： 所有者: CN=test, OU=android, O=android, L=shenzhen, ST=guangdong, C=china发布者: CN=test, OU=android, O=android, L=shenzhen, ST=guangdong, C=china序列号: 6f75ebb1有效期开始日期: Wed Apr 19 12:17:14 CST 2017, 截止日期: Fri Oct 25 12:17:14 CST 2126证书指纹: MD5: E0:93:87:28:43:D9:85:12:B2:41:36:D6:E2:BC:7C:83 SHA1: C1:4E:A3:BC:4D:C3:35:6C:F6:8A:9D:0E:EA:F3:79:4B:D9:1D:B4:C1 SHA256: 51:E8:9D:ED:64:62:4C:80:D4:42:69:41:9C:0C:E4:3B:89:FE:34:E6:A4:42:47:83:FB:CF:99:BD:DA:39:DA:90 签名算法名称: SHA256withRSA 版本: 3 扩展: #1: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 2E 49 AD 2B 2D 4E D3 0D 02 FC 5B 5F EF 00 77 0F .I.+-N….[_..w.0010: 5D 91 1D 1C ]…]]`]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 高效图片加载]]></title>
    <url>%2F2017%2F04%2F17%2F2017-04-17-Optimization-Bitmap%2F</url>
    <content type="text"><![CDATA[图片加载一直是程序稳定性的重要因素，但是随着Glide，Picasso，Universal-ImageLoader等图片加载库的逐渐成熟，反而会使我们对图片加载掉以轻心，疏忽对图片加载的操作，导致内存占用过高，频繁出现OOM(OutOfMemory)异常，严重影响用户体验。 Bitmap秘籍inJustDecodeBounds取关键信息，不加载到内存加载图片之前就获取到图片的长宽值和MIME类型，不加载进内存，从而根据情况对图片进行压缩 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(getResources(), R.id.myimage, options); int imageHeight = options.outHeight; int imageWidth = options.outWidth; String imageType = options.outMimeType; Note： 最理性的加载情况是，不穿小鞋也不穿大鞋 inSampleSize等比例压缩很多情况下我们是在大脚穿小鞋的情况，例如：用相机拍照返回的原图1024x768像素，直接用来显示头像ImageView只有128x96像素，设置inSampleSize=4，从原画中每4像素提取1给像素到目标图片，这样就减少内存使用；计算出合适的inSampleSize值 public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { // 源图片的高度和宽度 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height > reqHeight || width > reqWidth) { // 计算出实际宽高和目标宽高的比率 final int heightRatio = Math.round((float) height / (float) reqHeight); final int widthRatio = Math.round((float) width / (float) reqWidth); // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高 // 一定都会大于等于目标的宽和高。 inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio; } return inSampleSize; } 合并使用先开启inJustDecodeBounds只读取获取高宽关键信息，获得合适的inSimpleSize的值，合理加载图片； public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) { // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小 final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // 调用上面定义的方法计算inSampleSize值 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 使用获取到的inSampleSize值再次解析图片 options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); } InputStream 中使用 public static Bitmap getFitSampleBitmap(InputStream inputStream, int width, int height) throws Exception { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; byte[] bytes = readStream(inputStream); //BitmapFactory.decodeStream(inputStream, null, options); BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options); options.inSampleSize = getFitInSampleSize(width, height, options); options.inJustDecodeBounds = false; // return BitmapFactory.decodeStream(inputStream, null, options); return BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options); } /* * 从inputStream中获取字节流 数组大小 * */ public static byte[] readStream(InputStream inStream) throws Exception { ByteArrayOutputStream outStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while ((len = inStream.read(buffer)) != -1) { outStream.write(buffer, 0, len); } outStream.close(); inStream.close(); return outStream.toByteArray(); } 使用内存缓存技术LruCacheLruCache 在android-support-v4的包中提供, 它的主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。 LruCache.java private LruCache&lt;String, Bitmap> mMemoryCache; @Override protected void onCreate(Bundle savedInstanceState) { // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。 // LruCache通过构造函数传入缓存值，以KB为单位。 int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 使用最大可用内存值的1/8作为缓存的大小。 int cacheSize = maxMemory / 8; mMemoryCache = new LruCache&lt;String, Bitmap>(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { // 重写此方法来衡量每张图片的大小，默认返回图片数量。 return bitmap.getByteCount() / 1024; } }; } public void addBitmapToMemoryCache(String key, Bitmap bitmap) { if (getBitmapFromMemCache(key) == null) { mMemoryCache.put(key, bitmap); } } public Bitmap getBitmapFromMemCache(String key) { return mMemoryCache.get(key); } 如上，最核心的问题是如何合理的分配LruCache的大小，关键因素：设备 应用可分配内存； 设备屏幕和分辨率 图片 尺寸和大小及对应的消耗内存； 访问的频率； 动态保持的图片数量及内存总量； Glide 图片优化根据ImageView的大小，指定请求图片大小用 resize(x,y) 调整图片大小用CenterCrop, FitCenter调整显示效果 Glide .with(context) .load(UsageExampleListViewAdapter.eatFoodyImages[0]) .override(600, 200) // resizes the image to these dimensions (in pixel) //.fitCenter() .centerCrop() // this cropping technique scales the image so that it fills the requested bounds and then crops the extra. .into(imageView); 常用方法 获得应用程序最高可用内存int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); Log.d("TAG", "Max memory is " + maxMemory + "KB"); 官方资源 Handling Bitmaps 【需翻墙】 DisplayingBitmaps.zip DisplayingBitmaps部分讲解： Android中高效的显示图片 - Bitmap的内存模型 参考 [1] ANDROID高效加载图片，有效避免程序OOM [2] Glide 系列预览]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Data Binding 详解及使用案例]]></title>
    <url>%2F2017%2F04%2F02%2F2017-04-02-Data-Binding%2F</url>
    <content type="text"><![CDATA[构建环境使用条件 支持 Android 2.1 (API level 7+). Android Plugin for Gradle 1.5.0-alpha1 或更高buildscript { ... dependencies { classpath 'com.android.tools.build:gradle:1.5.0-alpha1' } } 开启android { .... dataBinding { enabled = true } } 基本用法 （Data Binding Layout Files）绑定实体数据到指定布局（Layout）public class User { private final String firstName; private final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String getFirstName() { return this.firstName; } public String getLastName() { return this.lastName; } } 如果我需要用Layout展示用户信息 User，通常我们的做法就是 新建Layout.xml； 找到对应控件，findIdByView或 Butterknife ； 设置数据； 感觉用Butterknife已经很高大上，很高效了，看一下Data Binding的效率：main_activity.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;data> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;TextView android:layout_width="wrap_content" android:id="@+id/mFirstName" android:layout_height="wrap_content" android:text="@{user.firstName}"/> &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@{user.lastName}"/> &lt;/LinearLayout> &lt;/layout> MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); User user = new User("Test", "User"); binding.setUser(user); } 高效没看出来呀！为了让接手的下一个兄弟不骂娘，我还是选择普通写法o(╯□╰)o，那如果是这种布局呢 你用几百行的代码，DataBinding一行搞定，Boss此刻应该蹲在厕所喜极而泣，我XX我早该找一个这样的程序员。 小知识点 Fragment ,ListView,RecyclerView 中的使用// ListView RecyclerView ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); //Fragment MainFragmentBinding binding = DataBindingUtil.inflate(inflater, R.layout.main_fragment, container, false); 如果想操作对应的控件需要设置id号，如main_activity.xml, 设置android:id=&quot;@+id/mFirstName&quot; ，可以直接用binding.mFirstName 找到控件 ； 【待处理】测试中得到binding MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater()); ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false); 事件绑定（Event Handling）最简单的应用main_activity.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;data> &lt;variable name="handlers" type="com.example.MyHandlers"/> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@{user.firstName}" android:onClick="@{handlers::onClickFriend}"/> &lt;/LinearLayout> &lt;/layout> 事件处理类 public class/*也可以是接口*/ MyHandlers { public void onClickFriend(View view) { ... } } 控制代码同上，设置变量就可以binding.setHandlers(...) 带参数的事件绑定（Android Plugin for Gradle 2.0 或更高）main_activity.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;data> &lt;variable name="handlers" type="com.example.MyHandlers"/> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@{user.firstName}" android:onClick="@{() -> handlers.onSaveClick(user)}"/> &lt;/LinearLayout> &lt;/layout> 事件处理类 public class MyHandlers { public void onSaveClick(User user){} } 传入View方式 android:onClick=&quot;@{(theView) -&gt; handlers.onSaveClick(theView, user)}&quot; 或 &lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:onCheckedChanged="@{(cb, isChecked) -> handlers.completeChanged(user, isChecked)}" /> 注意：避免一些比较复杂的listeners，这样会使得Layout更易读更容易维护 Data Layout 小细节及简单语法Imports&lt;data> &lt;import type="android.text.TextUtils"/> &lt;!--静态类的使用--> &lt;import type="android.view.View"/> &lt;!--导入--> &lt;variable name="note" type="String"/>&lt;!--自动导入java.lang.*--> &lt;import type="com.example.real.estate.View" alias="Vista"/> &lt;!--别名解决同名类--> &lt;/data> &lt;TextView android:text="@{TextUtils.isEmpty(user.lastName)? "default":user.lastName }" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@{user.isAdult ? View.VISIBLE : View.GONE}"/> &lt;!-【使用】--> Note: 默认自动导入java.lang.*，常用的有Integer，String，StringBuffer，Math类 Binding Class Names 如上：MainActivityBinding 类 默认命名规则 包名+布局名去‘_’首字母大写+Binding 如： main_activity.xml ==&gt; MainActivityBinding.class 自定义的三种解释&lt;data class="ContactItem">&lt;/data> &lt;!--自定义名称--> &lt;data class=".ContactItem">&lt;/data> &lt;!--使用module包名--> &lt;data class="com.example.ContactItem">&lt;/data> &lt;!--指定包名--> IncludesData layout 复用&lt;?xml version="1.0" encoding="utf-8"?> &lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"> &lt;data> &lt;variable name="user" type="com.example.User"/> &lt;/data> &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;include layout="@layout/name" bind:user="@{user}"/> &lt;include layout="@layout/contact" bind:user="@{user}"/> &lt;/LinearLayout> &lt;/layout> 简单语法Java共同特征 Mathematical + - / * % String concatenation + Logical &amp;&amp; || Binary &amp; | ^ Unary + - ! ~ Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt; Comparison == &gt; &lt; &gt;= &lt;= instanceof Grouping () Literals - character, String, numeric, null Cast Method calls Field access Array access [] Ternary operator ?: Examples: android:text=&quot;@{String.valueOf(index + 1)}&quot; android:visibility=&quot;@{age &lt; 13 ? View.GONE : View.VISIBLE}&quot; android:transitionName=&#39;@{&quot;image_&quot; + id}&#39; android:text=&quot;@{user.displayName ?? user.lastName}&quot; 【重点】&lt;==&gt; 等价于 android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot; Resources引用 Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList Sample android:text=&quot;@{@string/nameFormat(firstName, lastName)}&quot; android:text=&quot;@{@plurals/banana(bananaCount)}&quot; android:padding=&quot;@{large? @dimen/largePadding : @dimen/smallPadding}&quot; String formatting &lt;resources&gt; &lt;string name=&quot;greeting&quot;&gt;Hello, %s&lt;/string&gt; &lt;/resources&gt; &lt;TextView android:text=&quot;@{@string/greeting(user.firstName)}&quot;/&gt; Math in expressions &lt;TextView android:padding="@dimen/padding" android:padding="@{@dimen/padding}" android:padding="@{@dimen/padding * 2}" android:padding="@{@dimen/padding + @dimen/padding}" android:padding="@{largeScreen ? @dimen/padding * 2 : @dimen/padding}" /> 更改数据自动更新UI界面 （Data Objects）经过上的学习，有木有发现， 布局Layout中的数据variables是固定的，只有初始化的时候赋值 数据变动时（设置数据，得到数据），还需要找控件，设置参数，更改UI状态, 基本还是老套路，官方的解决方案是Observable，使用观察者模式，当数据变化时通知layout自动变化，官方提供的类： Observable Objects ； ObservableFields ； Observable Collections； Observable Objectspublic static class User extends BaseObservable { private String firstName; private String lastName; @Bindable public String getFirstName() { return this.firstName; } @Bindable public String getLastName() { return this.lastName; } public void setFirstName(String firstName) { this.firstName = firstName; notifyPropertyChanged(BR.firstName); } public void setLastName(String lastName) { this.lastName = lastName; notifyPropertyChanged(BR.lastName); } } 经过改造后的User,同上的初始化 private User user ; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); user = new User("Test", "User"); binding.setUser(user); //点击LastName触发 binding.setHandlers(new MyHandlers() { @Override public void onClickFriend(View view) { user.setFirstName("FirstName"); //布局自动更新为`FirstName` //此后常用的操作 //布局中Progress android:visibility="@{TextUtil.isEmpty(user.firstName) ? View.GONE : View.VISIBLE}" // 自动控制对应的Progress是否显示，或进行一些简单的逻辑处理 } }); } ObservableFieldsprivate static class User { public final ObservableField&lt;String> firstName = new ObservableField&lt;>(); public final ObservableField&lt;String> lastName = new ObservableField&lt;>(); public final ObservableInt age = new ObservableInt(); } // 对应的set/get user.firstName.set("Google"); int age = user.age.get(); Observable CollectionsObservableArrayMap&lt;String, Object> user = new ObservableArrayMap&lt;>(); user.put("firstName", "Google"); user.put("lastName", "Inc."); user.put("age", 17); 高阶用法在RecyclerView中的使用 （Dynamic Variables）BindingHolder.java public static class BindingHolder extends RecyclerView.ViewHolder{ //加入 ViewDataBinding setter/getter 方法 private ViewDataBinding binding ; public ViewDataBinding getBinding() { return binding; } public void setBinding(ViewDataBinding binding) { this.binding = binding; } public BindingHolder(View itemView) { super(itemView); } } MyAdapter.java private class MyAdapter extends RecyclerView.Adapter&lt;BindingHolder>{ private List&lt;User> users; public MyAdapter(List&lt;User> users) { this.users = users; } @Override public BindingHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) { //核心代码 ViewDataBinding binding = DataBindingUtil.inflate( LayoutInflater.from(viewGroup.getContext()), R.layout.list_item, viewGroup, false); BindingHolder holder = new BindingHolder(binding.getRoot()); holder.setBinding(binding); return holder; } @Override public void onBindViewHolder(BindingHolder holder, int position) { User user = users.get(position); holder.getBinding().setVariable(BR.user, user); //不等待下一帧（Frame），直接更新，这个方法必须运行在UI线程 holder.getBinding().executePendingBindings(); } @Override public int getItemCount() { return users.size(); } } 更简洁的用法 public class UserAdapter extends RecyclerView.Adapter&lt;UserAdapter.UserHolder> { private static final int USER_COUNT = 10; @NonNull private List&lt;User> mUsers; public UserAdapter() { mUsers = new ArrayList&lt;>(10); for (int i = 0; i &lt; USER_COUNT; i ++) { User user = new User(RandomNames.nextFirstName(), RandomNames.nextLastName()); mUsers.add(user); } } public static class UserHolder extends RecyclerView.ViewHolder { private UserItemBinding mBinding; public UserHolder(View itemView) { super(itemView); mBinding = DataBindingUtil.bind(itemView); } public void bind(@NonNull User user) { mBinding.setUser(user); } } @Override public UserHolder onCreateViewHolder(ViewGroup viewGroup, int i) { View itemView = LayoutInflater.from(viewGroup.getContext()) .inflate(R.layout.user_item, viewGroup, false); return new UserHolder(itemView); } @Override public void onBindViewHolder(UserHolder holder, int position) { holder.bind(mUsers.get(position)); } @Override public int getItemCount() { return mUsers.size(); } } ViewStubs使用ViewStub 是不可见的,0大小常用于惰性加载，说白了就是占给位置，在父容器的inflate时候不用处理，当在ViewStub setVisibility(int) or inflate()才会加载到布局中，应用场景：错误提示，帮助提示，用户引导等；用法： &lt;ViewStub android:id="@+id/stub" android:inflatedId="@+id/subTree" android:layout="@layout/mySubTree" android:layout_width="120dip" android:layout_height="40dip" /> ViewStub stub = (ViewStub) findViewById(R.id.stub); View inflated = stub.inflate(); Data layout &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"> &lt;LinearLayout ...> &lt;!--需要增加ID--> &lt;ViewStub android:id="@+id/view_stub" android:layout="@layout/view_stub" ... /> &lt;/LinearLayout> &lt;/layout> 监听ViewStub inflate 事件 binding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() { @Override public void onInflate(ViewStub stub, View inflated) { ViewStubBinding binding = DataBindingUtil.bind(inflated); User user = new User("fee", "lang"); binding.setUser(user); } }); 自定义Setter实用小例子：设置url，控件直接加载url地址的图片attrs.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;resources> &lt;attr name="url" format="string"/> &lt;/resources> 在任意代码中加入如下： @BindingAdapter("url") public static void loadImage(final ImageView imageView, final String url){ Glide.with(imageView.getContext().getApplicationContext()) .load(url) .into(imageView); } 能得到变化的url及对应的ImageView控件 特殊说明: MasteringAndroidDataBinding中是用declare-styleable加自定义控件的方法来处理数据变化，上面的例子最能达到实践效果，在原生控件中加入自定义是属性,简洁易用； BindingAdapter进价用法观察多个属性 如： @BindingAdapter(value = {&quot;url&quot;,&quot;drawable&quot;},requireAll = false) requireAll指 布局控件中是否需要&quot;url&quot;`“drawable”` 属性都存在，默认为true；监听原生控件的属性变化，做响应的处理（重写），如：@BindingAdapter("android:paddingLeft") public static void setPaddingLeft(View view, int padding) { view.setPadding(padding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); } 获取变化的旧数据和新数据，自义定属性也能使用@BindingAdapter("android:paddingLeft") //注意：android:paddingLeft 可以改为自定义的Setter属性，如上‘url’ public static void setPaddingLeft(View view, int oldPadding, int newPadding) { if (oldPadding != newPadding) { view.setPadding(newPadding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); } } 总结: Data Binding 核心思想是把控件的属性用静态变量代表，并监听属性的变化，通过BindingAdapter来处理数据变化；如果不是很有感觉, 有兴趣进一步研究，建议看一下MVVMLight源码, 一个Data Binding 和RxJava 结合使用的库 单元测试【待实践】安卓 Data Binding 使用方法总结（姐姐篇） 学习资料实在的博客工作原理 Android Data Binding从抵触到爱不释手 比较详细，特别是有源码分析 开源库学习资料 MVVMLight源码, 一个Data Binding 和RxJava 结合使用的库 TODO-DataBinding 和MVP结合使用，Google 官方例子 附录Resource 引用对照表 Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList 常用转义表显示结果 描述 转义字符 十进制 空格 &nbsp; &#160; < 小于号 &lt; &#60; > 大于号 &gt; &#62; & 与号 &amp; &#38; " 引号 &quot; &#34; ‘ 撇号 &apos; &#39; × 乘号 &times; &#215; ÷ 除号 &divide; &#247; 引用： Data Binding Library MasteringAndroidDataBinding Data Binding in the Real World 安卓 Data Binding 使用方法总结（姐姐篇）]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2017%2F02%2F21%2F2017-02-21-linux-study%2F</url>
    <content type="text"><![CDATA[常用的命令日常常用cp /etc/apt/sources.list /etc/apt/sources.list.2015.06.05 vim /etc/apt/sources.list sudo chmod ugo+rwx //user + read write execution permisstion ps -ef | grep "key_word" edward 7751 7723 0 23:01 ? 00:00:00 /usr/share/android-studio/bin/fs kill 7723 sudo lsb_release -a // look ubuntu version uname -r //kernal version netstat –tln //查看服务监听端口 netstat //查看进程号 ps –aux //查看进程号 ps –aux | more //全部查看 ps –ef | grep mysql //查看mysql的进程 kill -9 3306 //强制杀掉进程号3306 sudo gdebi sogou_pinyin_linux_1.0.0.0014_amd64.deb vim ~/.bashrc alias pbcopy="xclip -selection c" alias pbpaste="xclip -selection clipboard -o" source ~/.bashrc diff -ruNa dir1 dir2 > s12.diff pcmanfm . 当前路径当前文件管理 加压和解压.bz2 解压1：bzip2 -d FileName.bz2 解压2：bunzip2 FileName.bz2 压缩： bzip2 -z FileName .tar.bz2 解压：tar jxvf FileName.tar.bz2 压缩：tar jcvf FileName.tar.bz2 DirName --------------------------------------------- .bz 解压1：bzip2 -d FileName.bz 解压2：bunzip2 FileName.bz 压缩：未知 .tar.bz 解压：tar jxvf FileName.tar.bz 压缩：未知 --------------------------------------------- .Z 解压：uncompress FileName.Z 压缩：compress FileName .tar.Z 解压：tar Zxvf FileName.tar.Z 压缩：tar Zcvf FileName.tar.Z DirName --------------------------------------------- .tgz 解压：tar zxvf FileName.tgz 压缩：未知 .tar.tgz 解压：tar zxvf FileName.tar.tgz 压缩：tar zcvf FileName.tar.tgz FileName --------------------------------------------- .zip 解压：unzip FileName.zip 压缩：zip FileName.zip DirName --------------------------------------------- .rar 解压：rar a FileName.rar 压缩：r ar e FileName.rar gz 解压1：gunzip FileName.gz 解压2：gzip -d FileName.gz 压缩：gzip FileName .tar.gz 解压：tar zxvf FileName.tar.gz 压缩：tar zcvf FileName.tar.gz DirName 几种快速清空文件内容的方法echo "" > fileName echo /dev/null > fileName echo > fileName cat /dev/null > fileName 软件安装问题upgrade 部分链接报错 GPG error: http://deb.playonlinux.com trusty InRelease: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY E0F72778C4676186 签名过期==&gt; 解决： sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys E0F72778C4676186 学习资料博客 Linux shell 常用技巧系列教程 Ubuntu下配置支持Windows访问的Samba共享 bash shell命令行选项与修传入参数处理 常用软件使用vim ～/.vimrc hi Comment ctermfg =blue #蓝色注释 git config –global core.editor vim 中文乱码 set fencs=utf-8,GB18030,ucs-bom,default,latin1 设置TABset ts=4 (注：ts是tabstop的缩写，设TAB宽4个空格)set expandtab对于已保存的文件，可以使用下面的方法进行空格和TAB的替换：TAB替换为空格：:set ts=4:set expandtab:%retab!空格替换为TAB：:set ts=4:set noexpandtab:%retab!加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。 常用命令 vim FileName +LineNumber == vim + LineNumber Filename VPN Shadowsocks免费翻墙账号网站大集合https://www.lightss.xyz/user/node/index.phpkebi2014@gmail.comhttps://www.ss-link.com/my/freehttps://www.shadowsocksx.me/SwitchyOptions.bak下载sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5 ss-qt5 自己搭建 搬瓦工的vps Lubuntu 精简Linux系统的使用好玩的工具lolcat gem install lolcat]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Basic</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本UI空控件的用方法和属性]]></title>
    <url>%2F2017%2F02%2F17%2F2017-02-17-basic-ui-study%2F</url>
    <content type="text"><![CDATA[控件使用ViewFlipper setInAnimation/setOutAnimation showNext/showPrevious getDisplayedChild() ==&gt; index ==&gt; getChildAt addView(view)/addView(view,position) AbsListView setSelector(new ColorDrawable(Color.TRANSPARENT)); GridView setNumColumns; setVerticalSpacing/setHorizontalSpacing AnimationSet = AnimationUtils.loadAnimation() Tip: 在GridView 的Adapter 内的View 设置setOnClickListener 会导致 设置的 GestureDetector.SimpleOnGestureListener.onFling返回的MotionEvent == null; EditText 显示/隐藏密码setInputType(hasShowPassword ? 129 : InputType.TYPE_TEXT_VARIATION_PASSWORD); 光标位置(定位到最后)edittext.setSelection(int) 获取焦点editText.requestFocus();//获取焦点 如果对edittext组件设置了editText.setFocusable(false);需要重新获取焦点则必须执行： editText.setFocusable(ture); editText.setFocusableInTouchMode(true); editText.requestFocus(); 注意：这种情况下，当重新点击文本框，是无法打开软键盘，必须点击第二次才能打开。 ViewPager setPageTransformer(); //设置页面切换效果 JazzyViewPager 提供11种切换效果 经常直播的效果 public class DepthPageTransformer implements PageTransformer { private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) { int pageWidth = view.getWidth(); if (position &lt; -1) { // [-Infinity,-1) ///看不到的一页 * // This page is way off-screen to the left. view.setAlpha(0); } else if (position &lt;= 0) { // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); } else if (position &lt;= 1) { // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); } else { // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); } } } ListView List内容平滑的移动到指定的位置 smoothScrollToPosition(position); PopupWindow 一定要设置的：View contentView，int width, int height;//构造方法： public PopupWindow (Context context) public PopupWindow(View contentView) public PopupWindow(View contentView, int width, int height) public PopupWindow(View contentView, int width, int height, boolean focusable) //常用的初始化 View contentView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popuplayout, null); PopupWindow popWnd = PopupWindow (context); popWnd.setContentView(contentView); popWnd.setWidth(ViewGroup.LayoutParams.WRAP_CONTENT); popWnd.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT); 显示//相对某个控件的位置（正左下方），无偏移 showAsDropDown(View anchor)： //相对某个控件的位置，有偏移;xoff表示x轴的偏移，正值表示向左，负值表示向右；yoff表示相对y轴的偏移，正值是向下，负值是向上； showAsDropDown(View anchor, int xoff, int yoff)： //相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移 showAtLocation(View parent, int gravity, int x, int y)： 添加动画mPopWindow.setAnimationStyle(R.style.contextMenuAnim);contextMenuAnim.xml &lt;style name="contextMenuAnim" parent="@android:style/Animation.Activity"> &lt;item name="android:windowEnterAnimation">@anim/context_menu_enter&lt;/item> &lt;item name="android:windowExitAnimation">@anim/context_menu_exit&lt;/item> &lt;/style> context_menu_exit.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;set xmlns:android="http://schemas.android.com/apk/res/android" > &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="100%p" /> &lt;/set> setFocusable EditText 是否点击后可编辑 mPopWindow.setBackgroundDrawable(new BitmapDrawable()) 的作用 setOutsideTouchable（）才会生效 PopupWindow才会对手机的返回按钮有响应 API &gt;= 23 setEnterTransition(Transition) or setExitTransition(Transition) 参考： PopupWindow才会对手机的返回按钮有响应 常用的UI方法获取xml属性 // Calculate ActionBar height TypedValue tv = new TypedValue(); if (context.getTheme().resolveAttribute( android.R.attr.actionBarSize, tv, true)) { mActionBarHeight = TypedValue.complexToDimensionPixelSize( tv.data, context.getResources().getDisplayMetrics()); }]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Basic</tag>
        <tag>support</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout入门体验]]></title>
    <url>%2F2017%2F02%2F07%2F2017-02-07-ConstraintLayout-study%2F</url>
    <content type="text"><![CDATA[ConstraintLayout 核心思想：平面内确定一点]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>support</tag>
        <tag>UI</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc学习笔记]]></title>
    <url>%2F2017%2F02%2F05%2F2017-02-05-java-doc%2F</url>
    <content type="text"><![CDATA[官方学习文档 How to Write Doc Comments for the Javadoc Tool 常用的HTML标签 标签 含义 &lt;strong&gt;&lt;/strong&gt; 字体加粗 &lt;p&gt; 换行 &lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt; 图片引用 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 超链接内容 加粗 strong&lt;strong&gt;Strong&lt;/strong&gt; 超链接 href&lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;Rx Design Guidelines (PDF)&lt;/a&gt; 换行/** &lt;p> * **/ 图片引用&lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/create.png&quot; alt=&quot;&quot;&gt; 常用的格式 标题加粗换行 /** * &lt;dl> * &lt;dt>&lt;b>Backpressure:&lt;/b>&lt;/dt> * &lt;dd>The {@code OnSubscribe} instance provided is responsible to be backpressure-aware or * document the fact that the consumer of the returned {@code Observable} has to apply one of * the {@code onBackpressureXXX} operators.&lt;/dd> * &lt;dt>&lt;b>Scheduler:&lt;/b>&lt;/dt> * &lt;dd>{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd> * &lt;/dl> **/]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 学习笔记]]></title>
    <url>%2F2017%2F02%2F01%2F2017-02-01-rx-learning-note%2F</url>
    <content type="text"><![CDATA[为什么要学RxJava 最大的好处在于,很优雅处理各种线程切换,能使整个代码块的逻辑连贯,易于阅读和维护; 提供丰富的操作符, 能使很多复杂的操作简单几步搞定; 运用响应式编程,使整个编程更流畅简洁; 开源库 RxJava&nbsp;&nbsp;&nbsp;&nbsp; RxAndroid Rx Sample RxUi Implementation of pure functional concept of talking to Android View layer in a Reactive way ReactiveCache Android-RxJava-samples Rex-weather Android animations powered by RxJava Rx 相关的开源工具库 RxAnimations RxBinding rx-preferences Reactive SharedPreferences for Android requery 支持RxJava Kotlin / Android ORM库 RxLifecycle 处理由Activity 或 Fragment生命周期，导致没有完成的订阅（subscriptions）触发的内存泄露 Frodo 模仿Jake Wharton’s Hugo，使用Java切面编程的Android 日志工具库 RxIAPv3 一个用Rx封装后的 Android App内购支付库，提供几个购买、消费和商品清单列表的Rx方法。 RxFile RxCamera RxJava style API for android camera RxPermissions Android runtime permissions powered by RxJava Resource Homepage http://reactivex.io/ RxJava 操作符动画效果演示 http://rxmarbles.com/ Testing asynchronous RxJava code using Mockito RxRecipes: Wrap your way to Rx 主要讲 fromCallable() fromAction() 替换Rx中的接口； Rxify : The Anti Cache-then-Network OR Network-then-Cache Problem 使用RX concat onErrorResumeNext onErrorReturn 处理访问网络失败后返回本地缓存的机制。 Book: RxJavaEssentials.pdf 【英文】 RxJava Essentials 中文翻译版 官方文档 Doc for operators (操作符相关文档) Scheduler官方文档 【待研究】 RxJava Wiki 文档 Implementing Your Own Operators 【实现自己的操作符】【重点】 翻译文档 ReactiveX/RxJava文档中文版 一些高质量学习资源 Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#0 【重点】 Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#1【重点】 给 Android 开发者的 RxJava 详解 使用RxJava构造Android清晰框架 Awesome-RxJava 一些RxJava的资料集合 【最爱】 Grokking RxJava, Part 1: The Basics 【英文】 操作符 操作符相关文章 木水川的博客 【强力推荐】 throttleFirst():RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) FlatMap无序，concatMap有序排列FlatMap应用场景： 1. 抽取对象的集合并逐个输出； 2. 嵌套回调解决回调地狱的问题； Student[] students = ...; Subscriber&lt;Course> subscriber = new Subscriber&lt;Course>() { @Override public void onNext(Course course) { Log.d(tag, course.getName()); } ... }; Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course>>() { @Override public Observable&lt;Course> call(Student student) { return Observable.from(student.getCourses()); } }) .subscribe(subscriber); first() vs. takeFirst() The difference between the two calls is that first() will throw a NoSuchElementException if none of the sources emits valid data, whereas takeFirst() will simply complete without exception. .groupBy()一旦产生的Observable被订阅，分组产生的GroupedObservable就开始缓存，没有被订阅（处理）的GroupedObservable可能会引起内存泄露，故，对不想处理的GroupedObservable，使用take(0)释放缓存； combineLatest 笔记操作符分类 合并型 combineLatest join merge mergeDelayError switchOnNext操作符是把一组Observable转换成一个Observable zip操作符是把两个observable提交的结果，严格按照顺序进行合并 截取添加分类型 startWith buffer debounce window groupBy distinct elementAt filter ofType first last single sample skip skipLast take 错误处理 onErrorReturn onErrorResumeNext return Observerable onExceptionResumeNext 改变流程走向 retry retryWhen 其他 concatMap cast scan ignoreElements操作符忽略所有源Observable产生的结果，只把Observable的onCompleted和onError事件通知给订阅者 进价问题研究 线程控制 Scheduler在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn() vs observeOn() 对事情线程的影响； subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() { @Override public void call() { progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 } }) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); Backpressure 【待研究】 生产速度比消费快,抛出MissingBackpressureException的异常官方对Backpressure的介绍及对应的解决方案 使用案例 省略subscribeOn()和observeOn()在切换线程时在Android开发的时候频繁使用subscribeOn()和observeOn()，后台线程和UI线程切换这可以可以抽离出来（文章：避免打断链式结构：使用.compose( )操作符） &lt;T> Transformer&lt;T, T> applySchedulers() { return new Transformer&lt;T, T>() { @Override public Observable&lt;T> call(Observable&lt;T> observable) { return observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); } }; } 使用debounce做textSearch用简单的话讲就是当N个结点发生的时间太靠近（即发生的时间差小于设定的值T），debounce就会自动过滤掉前N-1个结点。解决频繁改变，导致的多余的网络访问（场景举例：删除多余信息） RxTextView.textChangeEvents(inputEditText) .debounce(400, TimeUnit.MILLISECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;TextViewTextChangeEvent>() { @Override public void onCompleted() { log.d("onComplete"); } @Override public void onError(Throwable e) { log.d("Error"); } @Override public void onNext(TextViewTextChangeEvent onTextChangeEvent) { log.d(format("Searching for %s", onTextChangeEvent.text().toString())); } }); RxJava代替EventBus，Otto：RxBus 用RxJava实现事件总线(Event Bus) Implementing an Event Bus With RxJava - RxBus 延迟Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Long>() { @Override public void onCompleted() { log.d ("completed"); } @Override public void onError(Throwable e) { log.e("error"); } @Override public void onNext(Long number) { log.d ("hello world"); } }); schedulePeriodically轮询Observable.create(new Observable.OnSubscribe&lt;String>() { @Override public void call(final Subscriber&lt;? super String> observer) { Schedulers.newThread().createWorker() .schedulePeriodically(new Action0() { @Override public void call() { observer.onNext(doNetworkCallAndGetStringResult()); } }, INITIAL_DELAY, POLLING_INTERVAL, TimeUnit.MILLISECONDS); } }).subscribe(new Action1&lt;String>() { @Override public void call(String s) { log.d("polling….”)); } }) 使用RxJava处理复杂的Url操作query("Hello, world!") .flatMap(urls -> Observable.from(urls)) //拆分List .flatMap(url -> getTitle(url)) // 获取网站头名称 .filter(title -> title != null) // 过滤掉title == null .take(5) // 取前5个 .doOnNext(title -> saveTitle(title)) // 在得到结果前保存标题到Disk里 .subscribe(title -> System.out.println(title)); 按顺序从内存–&gt;文件–&gt;网络获取资源,成功程序停止final Observable&lt;String> memory = Observable.create(new Observable.OnSubscribe&lt;String>() { @Override public void call(Subscriber&lt;? super String> subscriber) { if (memoryCache != null) { subscriber.onNext(memoryCache); } else { subscriber.onCompleted(); } } }); Observable.concat(memory, disk, network) .first() .subscribeOn(Schedulers.newThread()) .subscribe(s -> { memoryCache = "memory"; System.out.println("--------------subscribe: " + s); }); 多个异步并发处理完，再更新 Observable.merge(observable1, observable2) .subscribeOn(Schedulers.newThread()) .subscribe(System.out::println); flatMap处理异步嵌套异步（Callback Hell）NetworkService.getToken("username", "password") .flatMap(s -> NetworkService.getMessage(s)) .subscribe(s -> { System.out.println("message: " + s); }); 按钮防抖RxView.clicks(findViewById(R.id.btn_throttle)) .throttleFirst(1, TimeUnit.SECONDS) .subscribe(aVoid -> { System.out.println("click"); }); 响应式的界面勾选了某个checkbox，自动更新对应的preference SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this); RxSharedPreferences rxPreferences = RxSharedPreferences.create(preferences); Preference&lt;Boolean> checked = rxPreferences.getBoolean("checked", true); CheckBox checkBox = (CheckBox) findViewById(R.id.cb_test); RxCompoundButton.checkedChanges(checkBox) .subscribe(checked.asAction()); Fragment 旋转缓存【待研究】 @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); /*.cache()操作符： 当第一个subscribe订阅的时候，才会连接原始Observable，缓存事件, 重发给后续订阅的subscribe 值得注意的事， 它和使用了.replay().publish()操作符的ConnectableObservable的不同。 另外，为了避免内存开销，不建议缓存大量事件*/ setRetainInstance(true); cacheObservable = weatherManager.getWeather().cache(); } @Override public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); cacheObservable.subscribe(/*your subscribe*/); } 测试调试 【待研究】 Unit Testing RxJava Observables and Subscriptions Debugging RxJava on Android 实战笔记 RxJava-Android-SamplesRetrofitFragment.javaObservable.zip / Observable.just gist code DebounceSearchEmitterFragment.javaRxTextView.textChangeEvents gitst code BufferDemoFragment.java RxView.clickEvents/ .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 private Subscription _getBufferedSubscription() { return RxView.clickEvents(_tapBtn) .map(new Func1&lt;ViewClickEvent, Integer>() { @Override public Integer call(ViewClickEvent onClickEvent) { Timber.d("--------- GOT A TAP"); _log("GOT A TAP"); return 1; } }) .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;Integer>>() {} ）； PublishSubject PublishSubject&lt;Float> _resultEmitterSubject = PublishSubject.create(); _subscription = _resultEmitterSubject.asObservable().subscribe(new Action1&lt;Float>() { @Override public void call(Float aFloat) { _result.setText(String.valueOf(aFloat)); } }); _resultEmitterSubject.onNext(num1 + num2); @OnTextChanged PollingFragment.javaCompositeSubscription / interval /doOnSubscribe /repeatWhen /Observable.timer _subscriptions.add(// Observable.just(1) .repeatWhen(new RepeatWithDelay(pollCount, pollingInterval)) .subscribe(new Action1&lt;Object>() { @Override public void call(Object o) { _log(String.format(Locale.US, "Executing polled task now time : [xx:%02d]", _getSecondHand())); } }, new Action1&lt;Throwable>() { @Override public void call(Throwable e) { Timber.d(e, "arrrr. Error"); } }) ); _subscriptions.add(// Observable.interval(INITIAL_DELAY, POLLING_INTERVAL, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String>() { @Override public String call(Long heartBeat) { return _doNetworkCallAndGetStringResult(heartBeat); } }).take(pollCount) .doOnSubscribe(new Action0() { @Override public void call() { _log(String.format("Start simple polling - %s", _counter)); } }) .subscribe(new Action1&lt;String>() { @Override public void call(String taskName) { _log(String.format(Locale.US, "Executing polled task [%s] now time : [xx:%02d]", taskName, _getSecondHand())); } }) ); public class RepeatWithDelay implements Func1&lt;Observable&lt;? extends Void>, Observable&lt;?>> { private final int _repeatLimit; private final int _pollingInterval; private int _repeatCount = 1; RepeatWithDelay(int repeatLimit, int pollingInterval) { _pollingInterval = pollingInterval; _repeatLimit = repeatLimit; } // this is a notificationhandler, all we care about is // the emission "type" not emission "content" // only onNext triggers a re-subscription @Override public Observable&lt;?> call(Observable&lt;? extends Void> inputObservable) { // it is critical to use inputObservable in the chain for the result // ignoring it and doing your own thing will break the sequence return inputObservable.flatMap(new Func1&lt;Void, Observable&lt;?>>() { @Override public Observable&lt;?> call(Void blah) { if (_repeatCount >= _repeatLimit) { // terminate the sequence cause we reached the limit _log("Completing sequence"); return Observable.empty(); } // since we don't get an input // we store state in this handler to tell us the point of time we're firing _repeatCount++; return Observable.timer(_repeatCount * _pollingInterval, TimeUnit.MILLISECONDS); } }); } } RxBusDemoFragment.javaConnectableObservable / SerializedSubjectgist代码 private final Subject&lt;Object, Object> _bus = new SerializedSubject&lt;>(PublishSubject.create()); _bus.onNext(object); _bus.hasObservers(); ConnectableObservable&lt;Object> tapEventEmitter = _rxBus.toObserverable().publish(); _subscriptions// .add(tapEventEmitter.subscribe(new Action1&lt;Object>() { @Override public void call(Object event) { if (event instanceof RxBusDemoFragment.TapEvent) { _showTapText(); } } })); stream.buffer(stream.debounce(1, TimeUnit.SECONDS)); _subscriptions.add(tapEventEmitter.connect()); FormValidationCombineLatestFragment.java private Observable&lt;CharSequence> _numberChangeObservable = RxTextView.textChanges(_email_editText).skip(1); _subscription = Observable.combineLatest(_emailChangeObservable, _passwordChangeObservable, _numberChangeObservable, new Fun3...) PseudoCacheMergeFragment.javaObservable.merge();TimingDemoFragment.java Observable.timer(2, TimeUnit.SECONDS)// //.just(1).delay(2, TimeUnit.SECONDS)// //.interval(1, TimeUnit.SECONDS)// //.interval(0, 1, TimeUnit.SECONDS)// //.interval(3, TimeUnit.SECONDS).take(5)// ExponentialBackoffFragment.java Observable// .error(new RuntimeException("testing")) // always fails .retryWhen(new RetryWithDelay(5, 1000)) //当错误时调用，适用于错误处理 //1-4 指数的递增延迟 Observable.range(1, 4)// .delay(new Func1&lt;Integer, Observable&lt;Integer>>() { @Override public Observable&lt;Integer> call(final Integer integer) { // Rx-y way of doing the Fibonnaci :P return MathObservable// .sumInteger(Observable.range(1, integer)) .flatMap(new Func1&lt;Integer, Observable&lt;Integer>>() { @Override public Observable&lt;Integer> call(Integer targetSecondDelay) { return Observable.just(integer) .delay(targetSecondDelay, TimeUnit.SECONDS); } }); } })// RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 其他 RxJS RxJS The Reactive Extensions for JavaScript http://reactivex.io Big list of functions 常用函数的例子 Creating Observables 产生Observable的方法 The introduction to Reactive Programming you’ve been missing 对应的 Demo 参考 RxJava使用场景小结 使用RxJava构造Android清晰框架]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 学习积累]]></title>
    <url>%2F2017%2F01%2F08%2F2017-01-08-gradle-note%2F</url>
    <content type="text"><![CDATA[基础教程 实践博客 Google’s guide on Gradle for Android 美团Android自动化之旅—适配渠道包 Android Gradle实战中遇到的问题与经验 Maven 建立企业内部maven服务器并使用Android Studio发布公共项目。 Gradle Tutorial Gradle 用法总结 构建神器Gradle 翻译gradle for android ==&gt;gradle for android pdf Writing Custom Plugins gradle官方文档，自定义插件拿到Project类，就可以拿到几乎所有工程配置的属性和方法，然后发挥想象控制你的工程。 官网资料 Chapter 23. Dependency Management 【待研究】 Chapter 45. The Java Plugin DependencyHandler Gradle Plugin User Guide Android Studio 官网提供的Gradle实用教程 Android Plugin DSL Reference build.gradle android{….} API 进阶博文 Android Gradle编译过程 比较详细的讲述了Gradle 编译 Apk的过程。 Weapons for Boilerplate Destruction 之Gradle 篇以上project.extensions.create….,可以使用${project.myextension.aNumber}访问到对应的属性 进阶源码阅读 hugo JakeWharton 不必介绍了。项目中使用Gradle plugin 和自定义Task 顺便学习一些Process Annotation. 开源插件 gradle-android-junit-jacoco-plugin可以生成代码单元测试覆盖率报告的 Gradle 插件。 gradle-android-javadoc-plugin可以生成 java doc 的 Gradle 插件。 gradle-android-apk-size-plugin可以将 Apk 大小记录到 CSV 文件的 Gradle 插件。 android-fat-aar Gradle script that allows you to merge and embed dependencies in generted aar file. ProperDroid simplifies the way that config different variant on your project. dexcount-gradle-plugin A Gradle plugin to report the number of method references in your APK on every build. 使用案例 本地引入.aar文件dependencies { compile(name:'nameOfYourAARFileWithoutExtension', ext:'aar') } repositories{ flatDir{ dirs 'libs' } } gradleBuildTime.gradle 获取build脚本每个任务（Task）执行的时间。 gradle.properties 自定义 buildConfigField 外部变量 修改output/apk/[自定义].apk 每次构建工程把git版本控制的信息加入VersionName中def gitSha = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim() def gitTag = 'git tag'.execute([], project.rootDir).text.trim().split("\n").last() def gitCommits = Integer.parseInt('git rev-list --count HEAD'.execute([], project.rootDir).text.trim()) 动态修改Manifest中的参数 android { compileSdkVersion 23 buildToolsVersion '23.0.2' defaultConfig { applicationId "com.liulishuo.engzo" minSdkVersion 15 targetSdkVersion 23 manifestPlaceholders = [ // 这里需要换成:tencent+你的AppId "tencentAuthId": "tencent123456", ] } ｝ 使用全局变量进行依赖版本及一些常用配置的统一管理 配置 Apk split 使Android Studio每个对应的Cpu 架构都生成单独的apk，减小整个应用的大小。 rootdirOfProject/gradle.properties 配置变量如： VERSION_NAME=1.2.2-SNAPSHOT 然后可以在配置文件所在项目中的所有*.gradle 文件直接引用。 有点类似Java public static的感觉。 Java 指定JDK版本android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 // targetCompatibility JavaVersion.VERSION_1_8 // sourceCompatibility JavaVersion.VERSION_1_8 } } 签名信息(release.keystore)的存放方式 stackoverflow Android — How to add Gradle dependencies using ‘foreach’ 很多开源项目都把依赖统一管理, 这个博文是做得做系统和简洁 问题解决 依赖更新项目依赖的远程包如果有更新，会有提醒或者自动更新吗？ 不会的，需要你手动设置changing标记为true，这样gradle会每24小时检查更新，通过更改resolutionStrategy可以修改检查周期。 configurations.all { // check for updates every build resolutionStrategy.cacheChangingModulesFor 0, 'seconds' } dependencies { compile group: "group", name: "projectA", version: "1.1-SNAPSHOT", changing: true } 之前上传aar同一版本到maven仓库，但依赖却没有更新，该怎么办呢?可以直接删除本地缓存，缓存在~/.gradle/caches目录下，删除缓存后，下次运行就会自动重新下载远程依赖了。 Gradle 一直在后台下载 （更新Gradle 版本） 原因: 由于 services.gradle.org 国内下载速度很慢(一般为45kb/s), 而每个gradle-xx.xx.-all.zip 版本至少60MB, 也就正常是需要40分钟左右,花都谢了 修改{$your_project}/gradle/wrapper/gradle-wrapper.properties 方案一： 修改distributionUrl指定的版本为本地存在的版本(正常能跑的项目中找)//例如： 新的工程, gradle-wrapper.properties 文件,如下 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip // 只修改 distributionUrl 属性 // 如: distributionUrl=.../gradle-3.3-all.zip 修改为: distributionUrl=.../gradle-2.14.1-all.zip 方案二： 直接从distributionUrl指定的链接下载如: https\://services.gradle.org/distributions/gradle-3.3-all.zip 一般浏览器下载比Android Studio快 或者搜索对应版本(gradle-3.3-all.zip),下载别人已经下载好的,国内节点2~3分钟搞定 ; 修改distributionUrl,指向本地文件 Window ==&gt; distributionUrl=file:///C:/downloads/gradle-2.1-all.zip Unix ==&gt; distributionUrl=file\:/tmp/gradle-2.2.1-all.zip 方案三: 直接把下载好的文件(gradle-xx.xx.-all.zip),放在{$your_project}/gradle/wrapper/下,也就是和gradle-wrapper.properties同一目录; 方案四: 把下载好的gradle-xx.xx.-xx.zip,放到gradle对应的缓存目录下,{文件md校验生成的文件名}/gradle-xx.xx.-xx.zip; 方案五： 直接更改 distributionUrl的下载路径为国内服务器，例如：http://mirrors.flysnow.org/`distributionUrl=http\://mirrors.flysnow.org/gradle/gradle-4.1-bin.zip如果你在 gradle.properties 配置了代理，请添加一个不走代理的配置，否则 gralde 无法安装systemProp.http.proxyHost=mirrors.neusoft.edu.cnsystemProp.http.proxyPort=80 添加不走代理的 host，会影响 package 的安装systemProp.http.nonProxyHosts=172.1.1.227|localhost|mirrors.flysnow.org #### 使用阿里云国内镜像 单个项目生效 buildscript { repositories { maven { url ‘http://maven.aliyun.com/nexus/content/groups/public/&#39; } maven{ url ‘http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;} } dependencies { classpath ‘com.android.tools.build:gradle:2.2.3’ }}allprojects { repositories { maven { url ‘http://maven.aliyun.com/nexus/content/groups/public/&#39; } maven{ url ‘http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;} }} 对所有项目生效，在USER_HOME/.gradle/下创建init.gradle文件 allprojects{ repositories { def ALIYUN_REPOSITORY_URL = ‘http://maven.aliyun.com/nexus/content/groups/public&#39; def ALIYUN_JCENTER_URL = ‘http://maven.aliyun.com/nexus/content/repositories/jcenter&#39; all { ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository){ def url = repo.url.toString() if (url.startsWith(‘https://repo1.maven.org/maven2&#39;)) { project.logger.lifecycle “Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.” remove repo } if (url.startsWith(‘https://jcenter.bintray.com/&#39;)) { project.logger.lifecycle “Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.” remove repo } } } maven { url ALIYUN_REPOSITORY_URL url ALIYUN_JCENTER_URL } }}` 实用小技巧distributionUrl 尽量使用** bin.zip 如：gradle-xxx-bin.zip]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 架构相关笔记]]></title>
    <url>%2F2016%2F12%2F27%2F2016-12-27-Archtecture-for-Android%2F</url>
    <content type="text"><![CDATA[学习资源 Google 官方 android-architecture-components Google I/O Android App The Google I/O Android App Data Binding Guide Android Architecture Blueprints 【重点】 其他 Android Boilerplate 一些常用开源框架的集合 【重点】 Android Guidelines Architecture and code guidelines 2000+【重点】 常用的架构及教程 Google官方MVP+Dagger2架构详解 Android-CleanArchitectureRelative blog Architecting-android-the-clean-way EffectiveAndroidUI Retrofit2 Retrofit2 使用注意点总结 Tutorial Getting Started and Creating an Android Client 深入浅出 Retrofit，这么牛逼的框架你们还不来看看？ Dagger2 Providing test doubles with Dagger 1 and Dagger 2 Dagger2 Example 简明清晰的Dagger2教程 Dagger2 Android 告别Dagger2模板代码：Dagger Android使用详解 官方网址 图片加载 Glide 谷歌官方推荐使用 Glide 使用的详解教程 英文版 Glide 系列预览中文版 Picasso square 开源 12000+ star Picasso学习笔记 Fresco-Source-Analysis FluxFacebook 华人工程师提出的一种软件架构 Tutorial：Flux Architecture on Android Flux Architecture on Android 使用Otto在Android上简单是实现Demo Facebook官网对flux的介绍 【需要翻墙】 MVP MVP 简单的介绍, 及下面介绍推荐相关MVP教程 MVP Wiki 【英文】 Android中的MVP模式，带实例 MVP Android Example github 3700+ star Google Sample: Android Architecture Blueprints 之 MVP MVVM MVVM wiki 官方学习资料Data Binding Guide MVVMLight 对DataBind库进行优化，使MVVM用起来更加的简洁。 【推荐】 Approaching Android with MVVM 【英文】 开源工具库 truetime-android 一个可以在不同App,不同设备得到唯一的时间掺照物的库，IOS也有相同的库； Mortar 【待研究】 Scoop 【待研究】 任务处理 Android-Job Android library to handle jobs in the background. 页面关系的处理 alibaba/ARouter 典型应用场景 :从外部URL映射到内部页面，以及参数传递与解析跨模块页面跳转，模块间解耦拦截跳转过程，处理登陆、埋点等逻辑跨模块API调用，模块间解耦(注册ARouter服务的形式，通过接口互相调用) Cicerone 一个Activity/fragment/ViewGroup的路由库 系列文章问答 Android 开发有什么好的架构么? 【经典】 博客架构工具使用 不容错过，最全的安卓架构合集【从零开始搭建android框架系列（2）】 对应的Github地址 AndroidArchitectureCollection RxJava+Retrofit+OkHttp 懒人方式使用一 Google官方MVP+Dagger2架构详解 实战项目架构经验 The Making of Falcon Pro 3 三周开发，发布20天没有推广，安装量6000的经验介绍 【英文】 从360手机卫士的开发历程看如何实施大型移动应用开发 从整体上讲述软件开发流程及管理，清晰而且基本每个例子都很经典。看了第二次还是有很多收货。【重点】 英语流利说 Android 架构演进 逻辑条理清晰。 Android Application Architecture 译文 Architecting Android…The evolution 很经典的安卓架构文章，惊叹其架构层级之清晰，解耦之精妙，但是很难吃透不适合入门，会是整个软件架构很复杂 【英文】 从零开始的Android新项目1 - 架构搭建篇 简洁的概括了Android依赖库分层 开源项目线上商用项目 【重点研读】 Kickstarter for Android 一个用视频推销产品的电商APP，同时开源IOS，github 3300+ star官网：https://www.kickstarter.com/mobile Telegram 开源的Android聊天应用,有IOS,WP开源代码多平台Star 7000+ 加星项目 Timber Material Design Music Player github star 2200+【整体框架过了一遍，很多细节需要深入看】 Notes Material Design Notes App WordPress-Android Google 开源 Topeka for Android Material Design 的演示 APP 源代码 Google Santa Tracker for Android Features: A beautiful materially designed village 6 exciting games 2 interactive Android Wear watchfaces (with sound!) Videos, animations and more. 有用的功能性项目 Rox-Android一个基于Foursquare，根据位置信息及个人和朋友的喜好，推荐可能感兴趣的地方并提供导航 tickerCamera 这是一款集成了相机,图片裁剪,给图片贴贴图打标签的APP。 Tabby 手机App跳转到Chrome，设置样式及对应的菜单选项 用户引导帮助开源库 Highlight Ahoy-onboarding 其他Douya开源的 Material Design 豆瓣客户端（A Material Design app for douban.com） MusicStreamer mr-mantou-android 简单的架构及集合了国内一些第三方服务 扩展学习 Google首席软件工程师Joshua Bloch谈如何设计一款优秀的API【附PPT】]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推送实践]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-jpush-note%2F</url>
    <content type="text"><![CDATA[极光推送介绍极光推送自动集成官方 Android SDK 集成指南集成实践详细步骤注册极光账号 并配置Android 程序包名配置了jcenter支持buildscript { repositories { jcenter() } } allprojects { repositories { jcenter() } } 集成依赖android { defaultConfig { applicationId &quot;com.xxx.xxx&quot; //JPush上注册的包名. ndk { //选择要添加的对应cpu类型的.so库。 abiFilters &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;armeabi-v8a&#39; // 还可以添加 &#39;x86&#39;, &#39;x86_64&#39;, &#39;mips&#39;, &#39;mips64&#39; } manifestPlaceholders = [ JPUSH_PKGNAME : applicationId, JPUSH_APPKEY : &quot;你的appkey&quot;, //JPush上注册的包名对应的appkey. JPUSH_CHANNEL : &quot;developer-default&quot;, //暂时填写默认值即可. ] } } dependencies { compile &#39;cn.jiguang.sdk:jpush:3.0.0&#39; // 此处以JPush 3.0.0 版本为例。 compile &#39;cn.jiguang.sdk:jcore:1.0.0&#39; // 此处以JCore 1.0.0 版本为例。 } Manifest自定义广播设置 &lt;!-- ************************************* --> &lt;!-- The begin setting of JPush --> &lt;!-- ************************************* --> &lt;!-- User defined. 用户自定义的广播接收器--> &lt;receiver android:name=".broadcast.JPushReceive" android:enabled="true"> &lt;intent-filter> &lt;!--Required 用户注册SDK的intent--> &lt;action android:name="cn.jpush.android.intent.REGISTRATION" /> &lt;!--Required 用户接收SDK消息的intent--> &lt;action android:name="cn.jpush.android.intent.MESSAGE_RECEIVED" /> &lt;!--Required 用户接收SDK通知栏信息的intent--> &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_RECEIVED" /> &lt;!--Required 用户打开自定义通知栏的intent--> &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_OPENED" /> &lt;!-- 接收网络变化 连接/断开 since 1.6.3 --> &lt;action android:name="cn.jpush.android.intent.CONNECTION" /> &lt;category android:name="${JPUSH_PKGNAME}" /> &lt;/intent-filter> &lt;/receiver> &lt;!-- ************************************* --> &lt;!-- The end setting of JPush --> &lt;!-- ************************************* --> 自定义广播接收器官方Demo代码 JPushReceive.java 初始化public class ExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); JPushInterface.setDebugMode(true); JPushInterface.init(this); } } 测试API集成是否成功 启动应用程序，出现如下日志，说明SDK运行正常[JPushInterface] action:init - sdkVersion:3.0.0, buildId:319 pushcore I/JIGUANG-JCore: [ConnectingHelper] Login succeed 运行App，到控制台发送测试推送 【重点-填坑】如果没有收到推送重启手机， 日志会打印某些jni调用的代码未找到； 经验集成SDK，配置完成后需等待一段时间，功能才会见效； 进价别名与标签把绑定关系保存到 JPush 服务器端 使用案例： 动态标签 根据角色和地域等相关的信息动态设置标签和别名，从而区分收到推送的客户；相关方法JPushInterface.setAlias(Context context,String alias, TagAliasCallback CallBack); JPushInterface.setTags(Context ctx,Set&lt;String&gt; tags, TagAliasCallback CallBack); JPushInterface.setAliasAndTags(getApplicationContext(), null, (Set&lt;String&gt;) msg.obj, mTagsCallback); 温馨提示 设置标签别名请注意处理call back结果。只有call back 返回值为 0 才设置成功，才可以向目标推送。否则服务器 API 会返回1011错误。 RegistrationID把绑定关系保存到开发者应用服务器中 客户端设置通知栏样式 铃声、震动显示图标替换默认的通知栏样式。 自定义通知栏样式 /** * 设置通知提示方式 - 基础属性 */ private void setStyleBasic() { BasicPushNotificationBuilder builder = new BasicPushNotificationBuilder(PushSetActivity.this); builder.statusBarDrawable = R.drawable.ic_launcher; builder.notificationFlags = Notification.FLAG_AUTO_CANCEL; //设置为点击后自动消失 builder.notificationDefaults = Notification.DEFAULT_SOUND; //设置为铃声（ Notification.DEFAULT_SOUND）或者震动（ Notification.DEFAULT_VIBRATE） JPushInterface.setPushNotificationBuilder(1, builder); Toast.makeText(PushSetActivity.this, &quot;Basic Builder - 1&quot;, Toast.LENGTH_SHORT).show(); } /** * 设置通知栏样式 - 定义通知栏Layout */ private void setStyleCustom() { CustomPushNotificationBuilder builder = new CustomPushNotificationBuilder(PushSetActivity.this, R.layout.customer_notitfication_layout, R.id.icon, R.id.title, R.id.text); builder.layoutIconDrawable = R.drawable.ic_launcher; builder.developerArg0 = &quot;developerArg2&quot;; JPushInterface.setPushNotificationBuilder(2, builder); Toast.makeText(PushSetActivity.this, &quot;Custom Builder - 2&quot;, Toast.LENGTH_SHORT).show(); } private void setAddActionsStyle() { MultiActionsNotificationBuilder builder = new MultiActionsNotificationBuilder(PushSetActivity.this); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;first&quot;, &quot;my_extra1&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;second&quot;, &quot;my_extra2&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;third&quot;, &quot;my_extra3&quot;); JPushInterface.setPushNotificationBuilder(10, builder); Toast.makeText(PushSetActivity.this, &quot;AddActions Builder - 10&quot;, Toast.LENGTH_SHORT).show(); } 错误处理gradle.properties 增加 android.useDeprecatedNdk=true 使用旧版本的ndk集成方式,不添加会报错: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin.]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>第三方SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android测试资源集合,测试工具,测试开源项目]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-android-test%2F</url>
    <content type="text"><![CDATA[测试第三方服务 国内 https://bugly.qq.com/v2/ 腾讯的bugly 免费, 而且相当好用 腾讯优测云 提供真机测试和漏洞分析 Testin MTC 易测云 国外 TestCloud Testdroid Nimbledroid Automated performance analysis website Test bird APP和手游测试 kobiton 免费的在线真机测试 第三方性能采集SDK OneAPM 听云 自动化测试 CircleCI 一个基于Github的自动化测试，单元测试工具，提供一个免费的私有仓库。 Google官方学习资料 Best Practices for Testing 【最新/重点】 Android Testing Support library (ATSL) 【重点】相关视频： Android Testing (Android Dev Summit 2015) youtube 2015年视频 Developer API Testing Concepts 优秀博客 Java 测试 Leveraging product flavors in Android Studio for hermetic testing 与之对应的 codelab学习地址笔记： Just Say No to More End-to-End Tests two JUnit Rules @rule will be launched before @Before. The ActivityTestRule is a rule that provides functional testing of a single Activity. Test coverage report for Android application 使用jacoco-android plugin in a build.gradle进行测试覆盖率报告 Android单元测试在蘑菇街支付金融部门的实践 很详细介绍了单元测试在实践操作中的使用 RxJava Test Unit Testing RxJava Observables and Subscriptions Unit Testing RxJava Observables Unit Testing with RxJava UI测试 小心！做UI自动化一定要跨过这些坑 【待看】 测试框架 Unit Testing Junit4 Github A programmer-oriented testing framework for Java.http://junit.org/junit4/ Mockito Tasty mocking framework for unit tests in Java JMockit An automated testing toolkit for Java对比： mockito不能mock static method和final class、final method，JMockit可以；对比Mockito和JMockit的文章 PowerMock 一个可以Mock静态类的开源库 Tools for UI Testing: Robotium, Appium, Calabash, Robolectric. UI Testing Espresso Android 官方推荐使用的UI测试库 UIAutomator 可以夸应用进行测试 Robolectric is a unit test framework that de-fangs the Android SDK jar so you can test-drive the development of your Android app. Tests run inside the JVM on your workstation in seconds More RoboSpock Github A testing framework which brings powers of Spock and Groovy to Android app testing http://robospock.org Hamcrest matchersWhat is Hamcrest?Hamcrest is a library of matchers, which can be combined in to create flexible expressions of intent in tests. They’ve also been used for other purposes. Calabash 特点: 支持多种平台，代码复用性强:代码同时支持Android 和iOS, Web也有一定的支持; 语法更接近自然语音,易懂也易维护; 纯黑盒测试。 开源库 Collection awesome-android-testing collection of android test info 【重点】 Sample android-gradle-java-template Gradle + Android Studio + Robolectric + Espresso + Mockito + EasyMock/PowerMock + JaCoCo Demo Android-Clean-Testing Android Testing Sample Project robotium-showcase This example shows how to use Robotium with ActvitityTestRule and @Test annotation, it means in Google’s Espresso way. Google Sample android-testing-templates android-testing A collection of samples demonstrating different frameworks and techniques for automated testing Tools 测试工具square/spoon在adb devices 检测到的设备跑测试程序，并提供截屏，文件，数据库操作：最最重要的是生成简单明了的测试报告： Android Studio 2.2 Preview new feature: Espresso Test Recorder 菜单/run/Recorder Expresso Test 选项可以记录你的操作并转化为Espresso 的测试代码 APK Analyzer 菜单/build/Analyzer APK 提供APK大小分析工具，清楚的知道代码体积变换的趋势。 screengrab 当UI Tests 时自动化截屏STF 远程控制，一台电脑控制测试多个测试设openstf.github.io Control and manage Android devices from your browser Vysor 用Chrome浏览器控制你的Android手机 Vysor让你在电脑上完全控制android手机屏幕镜像 Vysor 情怀玩法 （番外篇） 开发时的调试工具stethoFacebook开源，很强大的Android网络和数据库调试工具,能像调试WebApp一样调试Android原生应用。借助Stetho在Chrome上调试Android网络&amp;数据库常用配置: 初始化public class MyApplication extends Application { public void onCreate() { super.onCreate(); Stetho.initializeWithDefaults(this); } } Chrome浏览器打开chrome://inspect/#devices 进阶增加网络拦截 Dependency 增加依赖环境compile 'com.facebook.stetho:stetho:1.3.1' compile 'com.facebook.stetho:stetho-okhttp3:1.3.1' compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4' compile 'com.squareup.okhttp3:okhttp:3.2.0' compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4' 向OkHttpClient增加网络拦截OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); augmented-traffic-controlFackbook开源项目模拟移动网络，对App的调试及网络优化有很大的帮助，主要参数有： 网络带宽（bandwidth） 延迟（latency） 丢包率（packet loss） 错包率（corrupted packets） 乱序率（packets ordering） GT（随身调） 腾讯开源的测试套件能Android设备上安装,进行移动调试,确保测试数据的真实有效性开源地址: https://github.com/TencentOpen/GT官网地址 使用GT APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。 一. 基本功能测试 1. CPU占有率; 2 jiffes（CPU时间片）; 3. 内存PSS值稳定在36M; 4. 网络上行流量和下行流量; 5. "数据存档" 二. 电量测试 再启动电流监控观察，1分钟后平均电流是220mA 三. crash - 保存了抓包文件后; - Logcat查看界面，立即把手机缓存的Logcat日志保存下来; 四. Net - 系统提供的流量查看也包括局域网socket的流量,而且不能分时段统计; - tcpdump抓包(需要手机root) + Wiresharek 抓包分析; 疑问点: 1. 激活FPS（帧率）的监测; 应用开发助手 Google Play、应用宝搜索“开发助手”下载， 或Download 屏幕分辨率、CPU 核数、IP 及 Mac 地址、so 类型、系统版本。 频繁切换“严格模式”； 多次启停“显示布局边界”； 测试被系统回收来回切换“不保留活动”； Android Debug Drawer 查看设备信息 安卓日志工具 XLog github微信mars 的高性能日志模块 xlog Pidcat Timber jakewharton 出品 compile 'com.jakewharton.timber:timber:4.5.1' // 初始化 if (BuildConfig.DEBUG) { Timber.plant(new Timber.DebugTree()); } else { Timber.plant(new CrashReportingTree()); } //发布后程序（Release.apk），崩溃日志上报 /** A tree which logs important information for crash reporting. */ private static class CrashReportingTree extends Timber.Tree { @Override protected void log(int priority, String tag, String message, Throwable t) { if (priority == Log.ERROR) { String msg = message + (t == null ? "" : t.getMessage()); MobclickAgent.reportError(mContext, String.format("TAG=%s, msg=%s, Throwable=%s", tag, message, t == null ? "" : t.getMessage())); //友盟错误上传 // Crashlytics.log(priority, tag, msg);// Fabric 错误上传 } } } Hugo 用注解的方式日志打印方法传入的参数 Annotation-triggered method call logging for your debug builds. Pury like Hugo But Android library for measuring time between multiple independentevents. KLog 这是一个Android专用的LogCat工具，主要功能为打印行号、函数调用、Json解析、XML解析、点击跳转、Log信息保存等功能 ViewInspector 查看View绘制层级，参数等View Inspection Toolbar for Android Development Purchase UI Tool (付费工具) Robotium Recorder 优化和分析工具Quality-Tools-for-Androidvb-android-app-qualityAndroidCodeQuality每次打包时都进行一次 checkstyle,pmd,findbugs验证 AndroidDevMetricsPerformance metrics library for Android development AndroidPerformanceMonitor一个对ANR（UI线程block）的监控工具 A transparent ui-block detection library for Android. (known as BlockCanary)]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Tutorial]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-hexo-tutorial%2F</url>
    <content type="text"><![CDATA[Hexo 相关教程 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hexo安装环境准备 Git / Node.js hexo官方教程两个初始化命令hexo init 类似git init 需要新建目录保存博文信息； 执行命令会在当前目录下生产如下文件：├── _config.yml #全局配置文件 ├── node_modules #Hexo插件（Node.js 插件默认安装目录） ├── package.json #Node 工程的依赖和基本信息 ├── scaffolds #模板 ├── source #博客正文源文件 └── themes 【重点】如果你有配置，会覆盖你原来的配置；npm install #安装package.json 下面的依赖包hexo http://localhost:4000/ 检查是否安装成功测试hexo是否正确安装hexo init cd folder npm install npm install hexo-server --save hexo server # 访问是否正常显示 http://localhost:4000/ hexo 配置hexo-theme-next主题的配置 最强主题基本上所有的配置信息都能满足,优雅,文档齐全 安装 Next主题 基本和教程走一边,就可以得到一个很牛的网站了 三种主题样式的选择： hexo/themes/next/_config.xml 搜索 scheme 网站logo设置 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。next主题：将图片放在next主题source/images目录下在next主题配置文件中添加：favicon: images/favicon.ico 设置首页是否为摘录（不显示所有内容）{your-hexo-dir}/themes/next/_config.yml auto_excerpt true 注册云存储存储图片防止图片链接失效,和在博客迁移过程中导致的图片获取异常,丢失. 统一管理文章中的图片 七牛 域名绑定 设置域名的指向的地址 在源文件中增加github page 的设置文件 source/CNAME 并增加你的域名,不带www的,例如:’taobao.com’Hexo 显示访问次数代码高亮 hexo-prism-plugin$hexo_dir/_config.yml Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sitesMore info: Deployment $ hexo deploy 常用的方法命令简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 一般的发布步骤hexo clean #删除产生的文件和缓存 hexo (g)generate # 生成静太文件 hexo (d)deploy # 发布网页 日常维护命令npm update -g hexo #hexo 更新 cd /{you-blog-dir}/theme/next git pull #更新主题代码 npm update # 更新插件 高级玩法添加网易云音乐由于markdown支持HTML, 打开网页版网易云音乐–&gt; 点击生成外链播放器 –&gt; 直接粘贴网易云音乐的外链接iframe代码 添加high一下效果整个页面渐进式摇摆,摇摆 复制header.swig的代码到{your-hexo-dir}/themes/next/layout/_custom/header.swig 本地刷新在菜单栏附近出现High一下 点击查看效果 问题解决 ERROR Plugin load failed: hexo-server 解决: npm install hexo-server ERROR Deployer not found: Git 解决： npm install hexo-deployer-git –save Cannot GET 解决 npm install 参考 GitHub Pages 绑定来自阿里云的域名 手把手教你建github技术博客 hexo下新建页面下如何放多个文章？ 博客推广——提交搜索引擎 动动手指，不限于NexT主题的Hexo优化（SEO篇）]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native for Android]]></title>
    <url>%2F2016%2F11%2F20%2F2016-11-20-React-Native-for-Android%2F</url>
    <content type="text"><![CDATA[入门 React Native for Android 入门老虎problem solution: when “brew install watchman” ==&gt;&gt; configure: error: You need a C++ compiler for C++ support ==&gt; sudo apt-get install build-essential2. brew install flow ==&gt;&gt; bnpm install flow-bin –global Android开发技术周报特刊之React Native 【经典教程】 Facebook.org react react-native React-Native 的优化进阶之旅 进阶 构建 F8 App / React Native 开发指南 【ReactNative For Android】框架启动核心路径剖析 印象笔记有备份 携程 React Native 实践与性能优化 相关开源项目 DoubanMovie-React-Native create-react-app Create React apps with no build configuration. Learning material react-native-guide React-Native指南汇集了react-native学习资源与各类开源app CodePush 大微软推出的一套可以为用 React Native 和 Cordova 开发的 App 提供代码热更新的方案。 React Native Training (中文) 视频 介绍 InfoQ: 探索 React 生态圈 Atom官网安装 sudo add-apt-repository ppa:webupd8team/atom sudo apt-get update sudo apt-get install atom /opt/atom/atom Proxy setting from apm github Using a proxy? If you are using a HTTP(S) proxy you can configure apm to use it by running: apm config set https-proxy https://127.0.0.1:1080 You can run apm config get https-proxy to verify it has been set correctly. plugincp the plugin.zip to ~/.atom/packages or $ apm install color-picker emmet-atom browser-plus highlight-selected atom-api-blueprint-preview Read.md previewjshint：检查 JavaScript 的语法，支持 JSX （需要在插件设置中开启 Support Linting JSX）；emmet：用 emmet （Zen Coding）方式快速编写页面；save-session：让 Atom 记住上一次打开的会话；browser-plus：在 Atom 中内嵌一个浏览器窗口，方便页面调试（其实 Atom 本身就是一个浏览器）；minimap：如果你对 Sublime Text 的 minimap 念念不忘；atomic-emacs：Emacs 键盘布局，适合 Emacs 用户使用；vim-mode：Vim 键盘布局，适合 Vim 用户使用。 待处理 atom-space-pen-views atom-html-preview 教程Atom 使用教程]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>facebook</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据处理资源总汇]]></title>
    <url>%2F2016%2F09%2F08%2F2016-09-08-Android-database-note%2F</url>
    <content type="text"><![CDATA[数据格式 gson Gson Json Annotations Example stag-java Speedy Type Adapter Generation fastjson 序列化 Parcelable Parcelable AutoValue使用 Google AutoValue 自动生成代码 Dependencies dependencies { provided &#39;com.google.auto.value:auto-value:1.2&#39; apt &#39;com.google.auto.value:auto-value:1.2&#39; apt &#39;com.ryanharter.auto.value:auto-value-parcel:0.2.1&#39; } Sample @AutoValue public abstract class Story implements Parcelable{ public abstract int id(); public abstract String title(); public static Story create(int id, String title){ new AutoValue_Story(id,title); } } 日常笔记 Sqlite 批量处理 SQLite批量插入和其他一些使用心得 android SQLite 批量插入数据慢的解决方案 Tutorial sqlite-tutorial Android 保存图片到SQLite,读出SQLite中的图片 sqlite 官方教程 CREATE TRIGGER Sqlite learnning Course SQL语句 Inner join/ union 的学习select f.name ,count(1) as sum, d.value as url from Favorite f inner join data d on d.key==f.name group by f.name 笔记好滴博文 5个Android ORM框架 Android 主流ORM（对象关系数据映射）简介 常用的SQL语句 DROP TABLE IF EXISTS t_student CREATE TALBE IF NOT EXISTS t_student (id iteger primary key autoincrement, name text, age integer, score real ); INSERT INTO t_student (name,age) values ('jack',22) update t_student set name='jack' ,id =1 select * from t_student where score >= 60 order by score asc, age asc; limit 分页查询 limit 0,5 limit 5,5 约束 not null, unique, default 外键—— create table t_student (id integer primary key autoincrement,name text, class_id integer, constraint fk_t_student_class_id_t_class_id foreign key (class_id) references t_class(id) ) No Sql RxPaper Like below Paper Rx-preferences Reactive SharedPreferences for Android http://f2prateek.com/2015/10/05/rx-preferences/ Leveldb is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values. Paper save/restore Java objects by using efficient Kryo serialization and handling data structure changes automatically. Iron Fast and easy to use NoSQL data storage 轻量对原生方法的封装（Origin API Extension） Favor A easy way to use android sharepreference SQLite ORM LitePal Android数据库高手秘籍 greendao Home page, documentation, and support links: http://greenrobot.org/greendao/ Chinese tutorial requery 又一轻量ORM库 What is a good tutorial for using ORMLite with SQLite and Android Improve SQLiteOpenHelper and ContentResolverSquare 出品 Sqlbrite A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.http://square.github.io/sqlbrite/ sqldelight Generates Java models from CREATE TABLE statements.（从sql语句生成Java模式 ）能把sql统一管理 Delightful-SQLBrite sqldelight 和 SQLBrite 例子 Qit Storio Beautiful API for SQLiteDatabase and ContentResolver Android InstanceIcepick Android Instance State made easy It works for Activities, Fragments or any object that needs to serialize its state on a Bundle Tools(工具) android_dbinspector Sqlite3 sqlite3 not foundblog: sqlite3 not found的解决办法 cant-remount-system-in-rw Nexus5使用有效果的命令：mount -o remount,rw /system chmod 4755 /system/xbin/sqlite3 sqlite3 robot.db ==&gt; error: only position independent executables (PIE) are supported. 优化 WeChat Sqliste 微信ANDROID客户端-会话速度提升70%的背后 protocol buffer (protobuf)]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>数据库</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 相关的新技术]]></title>
    <url>%2F2016%2F08%2F04%2F2016-08-04-New-trend-for-Android%2F</url>
    <content type="text"><![CDATA[Dynamic Loading 360 出品 DroidPlugin A plugin framework on android,Run any third-party apk without installation, modification or repackage Like web app release version ==&gt;open source Nuwa 女娲（Nuwa），可以热修复Android应用，可以加快编译 Dynamic-loading Alibabadexposed AOP (Aspect-oriented Programming) framework for Android app developmentAndFix C++ Android App 线上热修复方案 Android平台免Root无侵入AOP框架Dexposed使用详解 【翻译】Android中的AOP编程 Alibaba-Dexposed框架在线热补丁修复的使用 weex 阿里开源,类似React Native基于JS开源夸平台开源库 携程插件框架DynamicAPK Solution to implement multi apk dynamic loading and hot fixing for Android App. (实现Android App多apk插件化和动态加载，支持资源分包和热修复) 如何实现携程动态加载插件中对aapt的改造 Samll 做最轻巧的跨平台插件化框架。支持平台：Android API 15(4.0.3)+ iOS 7.0+ 敬请期待。 Xposed 用黑客思维做测试——神器 Xposed 框架介绍 官网教程: Development-tutorial tinker github 微信热更新方案 Tinker_imitator 微信热更新方案实践 博文介绍 微信Tinker的一切都在这里，包括源码(一) tinker-manager 微信tinker补丁管理，后端代码+客户端sdk 博文讲解Android插件化原理解析——Hook机制之Binder Hook Weex阿里开源基于JS开源夸平台开源库,类似React Native但是更轻量，学习成本低。 Weex 官网 阿里无线11.11 ： Weex——关于移动端动态性的思考、实现和未来 Kotlin Weekly Kotlin 资源合集 org.website Tutorial Online Compile Tutorial command-line reference Examples Kotlin语言1.0Beta发布，JetBrain介绍其设计理念 Kotlin 1.0都出了还没看过肿么办？不怕！来看我整理的Kotlin学习资源 相关开源库： AdvancedRecyclerView RxAndroidReading Grokking RxJava, Part 4: Reactive Android Rxlint compile &#39;nl.littlerobots.rxlint:rxlint:1.0 优化 redex 通过对字节码进行优化，以减小 Android Apk 大小，同时提高 App 启动速度。Facebook App 优化工具 ReDex 优化的 6 点及未优化的一大方面 统一开发 Multi-OS Engine Create Android and iOS apps using Java Coding 一个能用Android Studio统一开发 IOS Android Window 应用的引擎。 开源库 android-ocr optical character recognition (OCR) 文字识别]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>New Trench</tag>
        <tag>Android</tag>
        <tag>新技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design]]></title>
    <url>%2F2016%2F07%2F29%2F2016-07-29-Material-Design%2F</url>
    <content type="text"><![CDATA[前言一、设计阶段Material Design 提供了跨设备和 Web 的一致性用户体验。它的四项原则： 有型的外观(Tangible surface)：应用像现实中的实物一样。 仿印刷品的设计(Print-like design)：内容醒目、形象生动、意图明确。 有意义的运动效果(Meaningful motion)：吸引用户的兴趣，在应用状态切换时保持连续性。 自适应设计(Adaptive deisgn)：用户在手机、平板、Android TV、Android Wear、Android Auto 等不同设备上都能感到熟悉、一致，而不需要重新适应应用。 文档官方API The Transitions Framework Support Library 官方博客 [1]Android Design Support Library Android Support Library 23.2 Resource Awesome-MaterialDesign 【重点】 Material design icons by Google Animation: Jump-through【待研究】【重点】 An Introduction to Icon Animation Techniques 非常详尽的介绍并附有代码例子讲解 【重点】 Animate all the things. Transitions in Android一个关于transitions-everywhere Motion Material 兼容库的介绍的博客 Music Player: From UI Proposal to Code 一个介绍Material Transitions 的例子，但是没有兼容低版本 App Bar layout smooth-app-bar-layout StatusBarCompat Api &gt;= 19 Material Design 新特性 Codelab for Android Design Support Library used in I/O Rewind Bangkok session 介绍Material Design 新特性很详细的文章 对应的代码Github SVG SVG Path reference. Animating Vector Drawables. PathMorphing with AnimatedVectorDrawables in Android ColoredVector-Android VectorDrawable 和 AnimatedVectorDrawable 的兼容性问题 TV Docs http://developer.android.com/tv/index.html androidtv-Leanback ToolbarToolBar详解 TabLayout TabLayout：另一种Tab的实现方式 如下代码，Tab间隔转换会有更好的动画效果。Method animateToTab = clz.getDeclaredMethod("animateToTab", new Class[]{int.class}); animateToTab.setAccessible(true); animateToTab.invoke(tabLayout, new Object[]{5}); 与ViewPager结合标准代码@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.ac_tab_layout); // 获取ViewPager ViewPager viewPager = (ViewPager) findViewById(R.id.ac_tab_vp); // 构造一个TabPagerAdapter对象 TabPagerAdapter adapter = new TabPagerAdapter(); // 获取ViewPager TabLayout tabLayout = (TabLayout) findViewById(R.id.ac_tab_layout); // 设置TabLayout模式 tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE); // 设置ViewPager的适配器 viewPager.setAdapter(adapter); // 设置ViewPager tabLayout.setupWithViewPager(viewPager); } Bottom NavigationDependence compile 'com.android.support:appcompat-v7:25.0.0' compile 'com.android.support:design:25.0.0' Tutorial：Now you can use the Bottom Navigation View in the Design Support Library TextInputLayout codelabs constraint-layout [good] Creating a Login Screen Using TextInputLayout MaterialEditText 抛物线【RxJava经典入门教程的博主】ConstraintLayout Using ConstraintLayout to design your views ConstraintLayout API Build a Responsive UI with ConstraintLayout ConstraintLayout – Part 1 Script To convert an existing layout to a constraint layoutDesign -&gt; component Tree -&gt; Convert layout to ConstraintLayout 开源资源资源 Demos the new Android Design library github star 6300+ MaterialDrawer The flexible, easy to use, all in one drawer library for your Android project CircularAnim Android水波动画帮助类，一行代码实现View显示/隐藏/startActivity特效。(对 ViewAnimationUtils.createCircularReveal() 方法的封装) 字体和图片相关 Material Icon Library Github 1800+ star主要特点： 包含1500+ 的矢量图标（大小: 200kb）； 支持API&gt;=4； 可以转化为Drawable，可以menu.xml 中使用， 可以在Toolbar menu中使用 使用：1. 在https://materialdesignicons.com找矢量图； 2.集成库使用； Android-Iconics 【推荐】主要特点： 提供了三个矢量图库； 可以在原生控件上使用； 支持字体和矢量图片的自定义； Material Animation 动画 Material-Animations Android-Material-Examples New Feature 新的特性 material-tip Theme 主题 Android-Material-Themes-Demo 设置相关 material-about-library 原生控件的包装 Atelier A fast and clean way of using Palette in lists material-code-input material-dialogs 兼容开源库 ActSwitchAnimTool ActSwitchAnimTool make the Animation easy to implements, and it compat the version of Android 4.0 or above. RippleDrawable support 14+ WaveCompat fab-transformation nice-spinner support 14+ ToggleDrawable CircularReveal RevealEffect support 2.3 Transitions-Everywhere API compatible with Android 2.2+ MaterialStyledDialogs API 11+ required. vector-compat vector 兼容库 Material Design 参考资料 Android 开发设计 http://developer.android.com/design/ Material Design 示范应用 和 获奖应用 Google Design 网站 https://design.google.com/ Material Design 设计规范 http://www.google.com/design/spec/material-design/introduction.html Icons Tool https://design.google.com/icons/ Devices Tool https://design.google.com/devices/ Udacity 免费设计课程：Material Design for Android Developers]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌官网之硬件加速 【译】]]></title>
    <url>%2F2016%2F06%2F02%2F2016-06-02-Google-Api-hareware-acc%2F</url>
    <content type="text"><![CDATA[硬件加速 Android 3.0 (API level 11)开始，Android 2D渲染管道支持硬件加速。API level &gt;=14的Android系统默认开启硬件加速。由于硬件加速并不支持所有的2D绘制操作，所以开启硬件加速，可能会导致自定义view中部分元素看不到，程序抛出异常，或者错误的像素渲染等问题。 开启/关闭硬件加速 Application&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; Activity&lt;application android:hardwareAccelerated="true"> &lt;activity ... /> &lt;activity android:hardwareAccelerated="false" /> &lt;/application> Window 级别只能开启硬件加速getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View 关闭硬件加速myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null); View硬件加速的判断两个方法： View.isHardwareAccelerated()) Canvas.isHardwareAccelerated()) 你必须在你绘制代码（drawing code）内检测，使用前者而不是后者，因为有可能View虽然依附于一个硬件加速的窗口，但它依然可以在一个没有硬件加速的Canvas上绘制，列如：为了缓存的目的把view绘制到一个bitmap上。 Android 软加速/硬加速 绘制模式基于软件的绘制模式绘制步骤：无效从下到上的View，然后重新绘制。问题： 没有改变的大量上层的View需要重新绘制。 Android重绘view的过程，有可能没有绘制发生改变的view，此时你只能依赖其他view包含恰好的重绘行为。 硬件加速的绘制模式绘制步骤： 无效从下到上的View 记录和更新显示列表（display lists） 绘制显示列表 优点： 使用display lists能有针对性的更新改变的View 不支持的绘制操作Canvas Scaling View LayersOff-screen buffers a view’s drawing cache Canvas.saveLayer()) 所有的Android版本都支持对Off-screen buffers进行渲染。 你会获得更好的性能，当做复杂view的动画或者应用合成效果时。列如，当你实现淡出效果时，你可以使用Canvas.saveLayer()，暂存渲染的view到layer中，然后用透明度合成，使它返回屏幕达到淡出效果。 View.setLayerType()) LAYER_TYPE_NONE 不使用 off-screen buffer 【默认】 LAYER_TYPE_HARDWARE LAYER_TYPE_SOFTWARE 选择技巧 Performance: 使用硬件加速时，一旦一个view渲染进如layer中，只有调用invalidate())是绘制的代码才会被执行。一些动画，列如透明度动画，可以直接用于layer中，这使用GPU去执行是非常高效的。 Compatibility: Use a software layer type to force a view to be rendered in software. View layers and animations如果你在你的应用中跑的动画没有达到，你想要的流程结果，你可以考虑启动硬件加速。 以下的属性，使用合成来作用于layer，使用的是优化的invalidation及不需要重绘目标view，过程更高效。 alpha: Changes the layer’s opacity x, y, translationX, translationY: Changes the layer’s position scaleX, scaleY: Changes the layer’s size rotation, rotationX, rotationY: Changes the layer’s orientation in 3D space pivotX, pivotY: Changes the layer’s transformations origin demo： View.setLayerType(View.LAYER_TYPE_HARDWARE, null); ObjectAnimator animator = ObjectAnimator.ofFloat(view, "rotationY", 180); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { view.setLayerType(View.LAYER_TYPE_NONE, null); } }); animator.start(); 提示和技巧 减少view的数量 避免过度绘制A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!). 不创建渲染类在绘制代码中：如在onDraw中 new Paint 或者 Path。 不频繁的改变形状Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive. 不频繁的修改bitmap 谨慎使用alpha，当应用alpha属性到很大的views时，考虑使用 LAYER_TYPE_HARDWARE。.]]></content>
      <categories>
        <category>translate</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>google</tag>
      </tags>
  </entry>
</search>
