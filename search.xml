<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优化Android App]]></title>
    <url>%2F2018%2F08%2F07%2F2018-4-14-android-optimization%2F</url>
    <content type="text"><![CDATA[学习资源博文 Background Optimizations Facebook是如何收集其Android应用性能数据的 安卓性能优化收集网站 总结性 Android客户端性能优化（魅族资深工程师毫无保留奉献） Java Performance blog 性能分析的网站 NimbleDroid 一个 Android 应用性能分析服务网站 PageSpeed Insights 能够测试网页在移动设备和桌面设备上的性能工具 APM(Application performance magic) : 应用程序性能管理 2011年时国外的APM行业 NewRelic 和 APPDynamics 国内：听云， OneAPM， 博睿(bonree) 云智慧，阿里百川码力 针对性优化图片压缩Apk体积缩小 Luban 可能是最接近微信朋友圈的图片压缩算法 Shrink Your Code and Resources 【官方教程，未看】 Android微信上的SVG PNG图片压缩对比分析 通过三次优化，我将gif加载优化了16.9% EFFICIENTLY REDUCING YOUR METHOD COUNT APK瘦身实践 突破App启动时间的极限 an Intelij Plugin for image compress using TinyPNG API Android 图片压缩工具 网络优化 Offline App Archit ecture: how to build for the next billion DevBytes: Efficient Data Transfers — YouTube Google Engineer Serials tutorial ORG Optimizing Downloads for Efficient Network Access 美团点评移动网络优化实践 内存优化 Android内存优化杂谈 Android 内存优化总结&amp;实践 速度优化 Android启动速度优化 everbook has backup, Application.registerActivityLifecycleCallbacks的运用 给 App 提速：Android 性能优化总结 优化实践 内存泄漏 Memory Analyzer（MAT） Tool Leak Suspects：内存泄露报告 Top Components：吃货报告 Histogram：每个Class占用内存 Dominator Tree：列出哪些对象占用内存最多以及谁hold住这些对象 OQL (Ctrl + F5 run) select * from instanceof android.app.Activity Mat tutorial: 1） 使用Memory Analyzer tool(MAT)分析内存泄漏2） Video youtube Google I/O 2011: Memory management for Android Apps3） MAT - Memory Analyzer Tool 使用进阶4） 从MAT数据中还原Bitmap原图Docuemnt1) eclipse.org document MemoryAnalyzer2) developer.android investigating your RAM usageBlog adb 使用 检查应用退出后Activities/Views 是否为零;adb shell dumpsys meminfo [应用包名] 多次进入退出后的占用内存TOTAL不应变化太大； onTrimMemory回调 响应此回调释放非必须内存； 验证adb shell dumpsys gfxinfo 【应用包名】-cmd trim 5adb shell dumpsys meminfo 【应用包名】查看内存大小 UI卡顿和稳定性 工作线程优先级设置为Process.THREAD_PRIORITY_BACKGROUND 卡顿常见原因1）人为在UI线程中做轻微耗时操作，导致UI线程卡顿；2） 布局Layout过于复杂，无法在16ms内完成渲染；3）同一时间动画执行的次数过多，导致CPU或GPU负载过重；4） View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；5） View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；6）内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；7） 冗余资源及逻辑等导致加载和执行缓慢；8）工作线程优先级未设置为Process.THREAD_PRIORITY_BACKGROUND导致后台线程抢占UI线程cpu时间片，阻塞渲染操作；9） ANR；卡顿分析解决的一般步骤 解决过度绘制问题1) 调试GPU过度绘制中打开调试，看对应界面是否有过度绘制，如果有先解决掉：2) 定位过渡绘制区域3) 利用Android提供的工具进行位置确认以及修改(HierarchyView , Tracer for OpenGL ES)4) 定位到具体的视图(xml文件或者View)5) 通过代码和xml文件分析过渡绘制的原因6) 结合具体情况进行优化7) 使用Lint工具进一步优化 检查是否有主线程做了耗时操作：1) Application 开启 StrictMode; 123456789public void onCreate() &#123; if (DEVELOPER_MODE) &#123; StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectAll() .penaltyLog() .build()); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectAll() .penaltyLog() .build()); &#125; super.onCreate();&#125; 如果主线程无耗时操作，还存在卡顿，有很大可能是必须在UI线程操作的一些逻辑有问题，比如控件measure、layout耗时过多等，此时可通过Traceview以及systrace来进行分析。 Traceview：Traceview主要用做热点分析，找出最需要优化的点。 systrace：抓取trace： 使用hugo打印方法调用的时长及参数 Method Tracing 优化启动时间官网：Generate trace logs by instrumenting your appJava 代码android.os.Debug.startMethodTracing() 和 stopMethodTracing()123456# 启动HomePageActivity并每1s跟踪方法调用adb shell am start -n com.runan.countprisoner/.view.activity.HomePageActivity --start-profiler /data/local/tmp/startup.trace --sampling 1000 终止跟踪adb shell am profile stop# 拉取 .trace 文件到本机当前目录adb pull /data/local/tmp/startup.trace . Android Studio -&gt; File -&gt; open 直接打开*.trace 官方工具 Android Monitor Allocation Tracker Device Monitor Viewing Overall Memory Allocations 参考 Investigating Your RAM Usage adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d] 【难点】 对meminfo 的解读 Dalvik/ART Log Messages 【难点】解读 Testing Display Performance 十分详细的关于显示优化的介绍。 第三方工具 由腾讯出品的GT（随身调），直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug Environment)，支持iOS和Android两个手机平台,主要功能可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。还提高基础API进行开发。 LeakCanary yourkit Java Profiler, and square/leakcanary recommend to use memory leak analyzer like mat FlatBuffers：性能最高的序列化库，由 Google 游戏开发小组专为性能而设计 Parcelable API：Android 进程间传递数据，性能远优于 Java 默认序列化机制 BlockCanaryEx 加速你的Android应用 保险套项目 Note : 『保险套』是一个超轻超薄的Android工具库，将它套在Android应用工程里裸露的Context上，再传入第三方SDK（通常是其初始化方法），即可防止三方SDK损害用户体验 常用小Tips SparseArray ——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。 查看Activity启动时间adb shell am start -W com.niuwa/.activity.HomePageActivity 参考： http://blog.tingyun.com/web/article/detail/155 Android P 电量管理 Android vitals]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程控制笔记整理]]></title>
    <url>%2F2018%2F08%2F07%2F2018-8-7-remote-control%2F</url>
    <content type="text"><![CDATA[视频流播放相关相关开源库 FFmpeg Libstreaming A solution for streaming H.264, H.263, AMR, AAC using RTP on Android RemoteDroid 能运行但是链接失败 android-eye Gstreamer-Android-example EasyDarwin 高性能开源流媒体服务器，支持RTSP、HLS、HTTP直播 ————– 官网 spydroid-ipcamera A powerful and funny android app. that streams the camera and microphone of your phone to your browser or to VLC libstreaming libstreaming-examples Google开源播放器 ExoPlayer 教程 最简单的基于FFmpeg的移动端例子：Android 视频转码器 Android本地视频播放器开发–ffmpeg解码视频文件中的音频(1) java 调用 ffmpeg 进行视频转换以及截图 FFmpeg 抽取视频中的一段(视频转换) [总结]FFMPEG视音频编解码零基础学习方法 重点 GStreamer SDK Tutorials 手机Android音视频采集与直播推送，实现单兵、移动监控类应用 实践笔记积累 Wowza Streaming Engine1234sudo service WowzaStreamingEngine startsudo service WowzaStreamingEngineManager start访问 http://[wowza-ip-address]:8088/enginemanagerhttp://localhost:8088/enginemanager/#home/_defaultVHost_ 视频发布账号和密码：/usr/local/WowzaStreamingEngine/conf/publish.password 网络相关学习 Socket.io资源列举 Get Started: Chat application （基于Node.js html）炒鸡简单的例子，无需编程经验 github github.com/socket.io socket.io-android-chat engine.io-client-java Engine.IO Client Library for Java JavaApidocs socket.io-redis libjitsi Advanced Java media library for secure real-time audio/video communication. 基础知识 网络大爬虫 SSL/TLS协议运行机制的概述 SOCKET通信中TCP、UDP数据包大小的确定 关于网络编程中MTU、TCP、UDP优化配置的一些总结 Blog Introducing Socket.IO 1.0 socket-io-p2p 试验UDP打洞穿透NAT Interactive Connectivity Establishment (ICE) ice4j code .google ice4j 资源交老 https://github.com/jitsi/ice4j 比较新的资源 ice4j Javadoc rfc5245.pdf jain-sip jain-sdp 获取Sdp源码 restcomm-android-sdk Tutorial https://telestax.com/jain-sip-stack-for-android/ libnice libnice-4-android Api documentation Englis PDF Material rfc4566 SDP: Session Description Protocol rfc5928 Traversal Using Relays around NAT (TURN) Resolution Mechanism rfc5766.pdf Traversal Using Relays around NAT (TURN):Relay Extensions to Session Traversal Utilities for NAT (STUN) rfc5245 Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols UDP打洞 QQ通信原理及QQ是怎么穿透内网进行通信的 P2P技术揭秘-P2P网络技术原理与典型系统开发 教程下载 webrtc turnserverdownloadsImportant directory:/usr/local/share/examples/turnserverhttp://66.228.45.110/ 免费申请 账号的网站比较详细的turnserver.conf配置说明 Node.jsLearning resource http://nodeschool.io/#workshoppers openSource node-express-mongoose-demo Module http://samhuri.net/projects/strftime Tutorial Node.js Tutorial – Step-by-Step Guide For Getting Started Tool123npm install -g node-inspector# basically `node-debug` instead of `node`$ node-debug example.js https://developers.google.com/web/tools/setup/ 数据传输数据转码 Convert bitmap array to YUV (YCbCr NV21) Appending a byte[] to the end of another byte[] Android 用MediaCodec实现视频硬解码 MediaCodec Api) 数据校验 传输数据校验算法研究 WebRTC Introduction to WebRTC on Android Android IOS WebRTC 音视频开发总结列表 https://webrtc.org/ Getting Started with WebRTC WebRTC samples 有各种Sample代码Html/js演示，并有对应Github源 码地址， 整个工程的samples Native APIs Diagram AndroidRTC 相关博文 WebRTC VideoEngine综合应用示例（一）——视频通话的基本流程 参考文章 控制相关 Android模拟产生事件 概括分析了模拟事件的三种方式，而且文章格式很喜欢 Input Technical Information Android Source 关于android devices input 的说明，偏底层 ； getevent/sendevent及 input 命令的详解 截屏相关 Android中使用代码截图的各种方法总结 视频相关 FFmpeg深入分析之零-基础 FFmpeg的Android平台移植—编译篇 Android中实时视频传输(摄像头实时视频传输)解决方案&lt;二&gt; android视频录制、另一部手机实时观看方案 重点 android视频处理相关资料 重点 资料http://www.ffmpeg.org/ffmpeg.htmlEzStreamSvr 一个流媒体传输服务器端GStreamer open source multimedia framework daf12345graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程中好用工具]]></title>
    <url>%2F2018%2F08%2F03%2F2018-8-3-coder-software%2F</url>
    <content type="text"><![CDATA[记录 terminalizer 录制终端命令行并转化成gif]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio用Cmake方式编译NDK代码]]></title>
    <url>%2F2018%2F08%2F01%2F2018-8-1-cmake-note%2F</url>
    <content type="text"><![CDATA[基础知识1.cmake是什么？ CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。 谷歌从AndroidStudio2.2以上就添加了Cmake方式来编译NDK代码，并从NDK例子看出，默认编译的方式就是cmake方式。 创建Android studio ndk工程傻瓜式操作 新建一个工程点击如下：然后把C/Cpp代码复制到src/main/cpp下，配置 CMakeLists.txt 手动配置 在src/main下新建jni或者cpp目录， 新建CMakeLists.txt,推荐目录/src/main/jni/CMakeLists.txt,如下为默认生成的格式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 并在build.gradle下关联CMakeLists.txt 123456externalNativeBuild &#123; cmake &#123; //默认和build.gradle同一目录： path &quot;CMakeLists.txt&quot; path &quot;/src/main/jni/CMakeLists.txt&quot; &#125;&#125; 配置gradle脚本 1234567891011121314151617181920212223242526272829303132333435363738android &#123; compileSdkVersion 28 defaultConfig &#123; ... externalNativeBuild &#123; cmake &#123; // Passes optional arguments to CMake. arguments &quot;-DCMAKE_VERBOSE_MAKEFILE=TRUE&quot; // Sets optional flags for the C compiler. cFlags &quot;-D_EXAMPLE_C_FLAG1&quot;, &quot;-D_EXAMPLE_C_FLAG2&quot; // Sets a flag to enable format macro constants for the C++ compiler. // -frtti: Runtime Type Information Support // -fexceptions : Exception Support //-std=c++14 : C++ Library Support cppFlags &quot;-D__STDC_FORMAT_MACROS&quot; //更多 arguments https://developer.android.com/ndk/guides/cmake &#125; &#125; ndk &#123; // &apos;x86&apos;, &apos;x86_64&apos;, &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, //指定生成的CPU架构 Specifies the ABI configurations of your native abiFilters &apos;armeabi-v7a&apos; &#125; &#125; externalNativeBuild &#123; cmake &#123; //默认和build.gradle同一目录： path &quot;CMakeLists.txt&quot; path &quot;/src/main/jni/CMakeLists.txt&quot; &#125; &#125; buildTypes &#123; ... &#125;&#125; 配置 CMake 构建脚本如果您的原生源文件还没有 CMake 构建脚本，则您需要自行创建一个并包含适当的 CMake 命令。CMake 构建脚本是一个纯文本文件，您必须将其命名为 CMakeLists.txt。本部分介绍了您应包含到构建脚本中的一些基本命令，用于在创建原生库时指示 CMake 应使用哪些源文件。 注：如果您的项目使用 ndk-build，则不需要创建 CMake 构建脚本。提供一个指向您的 Android.mk 文件的路径，将 Gradle 关联到您的原生库。 要创建一个可以用作 CMake 构建脚本的纯文本文件，请按以下步骤操作： 从 IDE 的左侧打开 Project 窗格并从下拉菜单中选择 Project 视图。 右键点击您的模块的根目录并选择 New &gt; File。 注：您可以在所需的任意位置创建构建脚本。不过，在配置构建脚本时，原生源文件和库的路径将与构建脚本的位置相关。 输入“CMakeLists.txt”作为文件名并点击 OK。 add_library现在，您可以添加 CMake 命令，对您的构建脚本进行配置。要指示 CMake 从原生源代码创建一个原生库，请将 cmake_minimum_required() 和 add_library() 命令添加到您的构建脚本中： 1234567891011121314151617181920# Sets the minimum version of CMake required to build your native library.# This ensures that a certain set of CMake features is available to# your build.cmake_minimum_required(VERSION 3.4.1)# Specifies a library name, specifies whether the library is STATIC or# SHARED, and provides relative paths to the source code. You can# define multiple libraries by adding multiple add.library() commands,# and CMake builds them for you. When you build your app, Gradle# automatically packages shared libraries with your APK.add_library( # Specifies the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp ) 使用 add_library() 向您的 CMake 构建脚本添加源文件或库时，Android Studio 还会在您同步项目后在 Project 视图下显示关联的标头文件。不过，为了确保 CMake 可以在编译时定位您的标头文件，您需要将 include_directories() 命令添加到 CMake 构建脚本中并指定标头的路径：1234add_library(...)\# Specifies a path to native header files.include_directories(src/main/cpp/include/) CMake 使用以下规范来为库文件命名： lib库名称.so 例如，如果您在构建脚本中指定“native-lib”作为共享库的名称，CMake 将创建一个名称为 libnative-lib.so 的文件。不过，在 Java 代码中加载此库时，请使用您在 CMake 构建脚本中指定的名称： static { System.loadLibrary(“native-lib”); } 注：如果您在 CMake 构建脚本中重命名或移除某个库，您需要先清理项目，Gradle 随后才会应用更改或者从 APK 中移除旧版本的库。要清理项目，请从菜单栏中选择 Build &gt; Clean Project。 Android Studio 会自动将源文件和标头添加到 Project 窗格的 cpp 组中。使用多个 add_library() 命令，您可以为 CMake 定义要从其他源文件构建的更多库。 添加 NDK APIAndroid NDK 提供了一套实用的原生 API 和库。通过将 NDK 库包含到项目的 CMakeLists.txt 脚本文件中，您可以使用这些 API 中的任意一种。 预构建的 NDK 库已经存在于 Android 平台上，因此，您无需再构建或将其封装到 APK 中。由于 NDK 库已经是 CMake 搜索路径的一部分，您甚至不需要在您的本地 NDK 安装中指定库的位置 - 只需要向 CMake 提供您希望使用的库的名称，并将其关联到您自己的原生库。 将 find_library() 命令添加到您的 CMake 构建脚本中以定位 NDK 库，并将其路径存储为一个变量。您可以使用此变量在构建脚本的其他部分引用 NDK 库。以下示例可以定位 Android 特定的日志支持库并将其路径存储在 log-lib 中： 12345678find_library( # Defines the name of the path variable that stores the # location of the NDK library. log-lib # Specifies the name of the NDK library that # CMake needs to locate. log ) 为了确保您的原生库可以在 log 库中调用函数，您需要使用 CMake 构建脚本中的 target_link_libraries() 命令关联库： 123456789find_library(...)\# Links your native library against one or more other native libraries.target_link_libraries( # Specifies the target library. native-lib # Links the log library to the target library. $&#123;log-lib&#125; ) NDK 还以源代码的形式包含一些库，您在构建和关联到您的原生库时需要使用这些代码。您可以使用 CMake 构建脚本中的 add_library() 命令，将源代码编译到原生库中。要提供本地 NDK 库的路径，您可以使用 ANDROID_NDK 路径变量，Android Studio 会自动为您定义此变量。 以下命令可以指示 CMake 构建 android_native_app_glue.c，后者会将 NativeActivity 生命周期事件和触摸输入置于静态库中并将静态库关联到 native-lib： 1234567add_library( app-glue STATIC $&#123;ANDROID\_NDK&#125;/sources/android/native\_app\_glue/android\_native\_app\_glue.c )\# You need to link static libraries against your shared native library.target_link_libraries( native-lib app-glue $&#123;log-lib&#125; ) 添加其他预构建库导入so库添加预构建库与为 CMake 指定要构建的另一个原生库类似。不过，由于库已经预先构建，您需要使用 IMPORTED 标志告知 CMake 您只希望将库导入到项目中：123add_library( imported-lib SHARED IMPORTED ) 然后，您需要使用 set_target_properties() 命令指定库的路径，如下所示。 某些库为特定的 CPU 架构（或应用二进制接口 (ABI)）提供了单独的软件包，并将其组织到单独的目录中。此方法既有助于库充分利用特定的 CPU 架构，又能让您仅使用所需的库版本。要向 CMake 构建脚本中添加库的多个 ABI 版本，而不必为库的每个版本编写多个命令，您可以使用 ANDROID_ABI 路径变量。此变量使用 NDK 支持的一组默认 ABI，或者您手动配置 Gradle 而让其使用的一组经过筛选的 ABI。例如： 12345678910add_library(...)set_target_properties( # Specifies the target library. imported-lib # Specifies the parameter you want to define. PROPERTIES IMPORTED_LOCATION # Provides the path to the library you want to import. imported-lib/src/$&#123;ANDROID_ABI&#125;/libimported-lib.so ) 为了确保 CMake 可以在编译时定位您的标头文件，您需要使用 include_directories() 命令，并包含标头文件的路径：1include_directories( imported-lib/include/ ) 注：如果您希望封装一个并不是构建时依赖项的预构建库（例如在添加属于 imported-lib 依赖项的预构建库时），则不需要执行以下说明来关联库。 要将预构建库关联到您自己的原生库，请将其添加到 CMake 构建脚本的 target_link_libraries() 命令中： target_link_libraries( native-lib imported-lib app-glue ${log-lib} ) 在您构建应用时，Gradle 会自动将导入的库封装到 APK 中。您可以使用 APK 分析器验证 Gradle 将哪些库封装到您的 APK 中。如需了解有关 CMake 命令的详细信息，请参阅 CMake 文档。 导入.a静态库android studio cmake 配置.a连接库 实战小案例指定 C++标准123456externalNativeBuild &#123; cmake &#123; cppFlags &quot;-frtti -fexceptions -std=c++14&quot; arguments &apos;-DANDROID_STL=c++_shared&apos; &#125;&#125; 编译一个目录中所有源文件123456# aux_source_directory 方法将路径列表全部放到一个变量中aux_source_directory($&#123;CMAKE_HOME_DIRECTORY&#125;/src/api SRC_LIST)aux_source_directory($&#123;CMAKE_HOME_DIRECTORY&#125;/src/core CORE_SRC_LIST)# 拼接到路径列表list(APPEND SRC_LIST $&#123;CORE_SRC_LIST&#125;)add_library(native-lib SHARED $&#123;SRC_LIST&#125;) 调试 message 方法打印123cmake_minimum_required(VERSION 3.4.1)message(STATUS &quot;execute CMakeLists&quot;)# 日志输出==&gt; .externalNativeBuild/cmake/debug/&#123;abi&#125;/cmake_build_output.txt CMakeLists.txt 改动什么时候执行sync 其他的时候只是出来缓存 测试了下，好像在 sync 的时候会执行。执行一次后会生成 makefile 的文件缓存之类的东西放在 externalNativeBuild 中。所以如果 CMakeLists.txt 中没有修改的话再次同步好像是不会重新执行的。（或者删除 .externalNativeBuild 目录）真正编译的时候好像只是读取.externalNativeBuild 目录中已经解析好的 makefile 去编译。不会再去执行 CMakeLists.txt 教程 官方7step入门教程： cmake-tutorial 【英文】 翻译： CMAKE官网教程 并有相关方法的详解 进阶Book: Mastering CMake 资料文献 CMake 手册详解（一） android ndk guides Introduction Building Architectures and CPUs Debugging and Profiling Libraries 安卓各版本提供可调用ndk库 High-Performance Audio 一些流行的底层的第三方库Simpleperf/ OpenSL ES/Vulkan/Machine Learning googlesamples/android-ndk CMake 官方文档 JNI 框架官方文档 参考 gcc程序的编译过程和链接原理 AndroidStudio用Cmake方式编译NDK代码 Android增量更新与CMake构建工具 跟我一起写 Makefile Android NDK开发扫盲及最新CMake的编译使用]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>cmake</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本UI空控件的用方法和属性]]></title>
    <url>%2F2018%2F07%2F03%2F2018-7-3-ui-open-source%2F</url>
    <content type="text"><![CDATA[提示类型Tosat GlideToast 工具类型 MaterialDateTimePicker 质感设计日期时间选择器]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 图片和文字开源库]]></title>
    <url>%2F2018%2F06%2F01%2F2018-6-1-font-img-tools%2F</url>
    <content type="text"><![CDATA[图片图片样式处理PloyFun 加载样式 加载样式]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>图片</tag>
        <tag>文字</tag>
        <tag>font</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网页工具]]></title>
    <url>%2F2018%2F05%2F05%2F2018-5-5-android-web-tools%2F</url>
    <content type="text"><![CDATA[看代码 codota 查询代码案例 查看不同版本Android，JDK源码 Android Framwork 源码查看 sourcegraph 基于网页端和Git的智能源码查看工具，可以本地安装 依赖 maven 仓库中搜索依赖 统计依赖大小，方法数量的变化 开源项目查找 GitHub 搜索 工具 json转化 Free Online IDE and Terminal 支持几乎所有主流编程语言的在线IDE terminalizer 录制终端命令行并转化成gif]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇葩说娱乐笔记]]></title>
    <url>%2F2018%2F04%2F20%2F2018-4-20-entertainment-fancy-talk%2F</url>
    <content type="text"><![CDATA[奇葩说第4季分手要不要当面说 20170414刘白范甜甜 他提出不公平，最爱的人否定伤得最深； 永开 分手的理由都是不对 把爱看太重 把爱情当成婚姻一样沉重，轻松的开始轻松的结束，把感情看得太重而不会享受感情—– 反驳受众是把分手看特很重的人群（这样这个辩题才有意义） 赵大情 热恋痛离 爱情观，热烈真诚而且深刻–恋爱的代价–更加珍贵分手的痛相对于见面的心动，微信的分手不配我的爱情 邱晨 分手好好说话；不要增加分手成本搞分手纪念日烧纸，对方要分手增加成本这样你就不敢分手了分手发生的情景 真实的分手的情况，切断信号，你们想象的是盛大闭幕式的烟花表演，分手是所有的烟花散去之过后，无尽的空洞和冷漠我们要分手就是我们没有办法从爱情这所学校毕业了，现在你要求我们要进行一场退学考试，甚至是退学面试，为什么，但凡我们有一丝一毫的勇气我们能不能用来在一起，而不是用来分开上 马微微 逃过生离，逃不过死离，需直面生活渣字被你一写变狂草了，书法艺术家呀，忽悠人忽悠得这么深情款款，让我觉得没有被你甩一次是我人生的大不幸呀成年人的决定 人生必修的一堂课，叫做当面分手，教会了我们什么，教会我们学会面对，坦然面对，面对我们的失败，面对我们的不堪逃避 每次逃走留下的烂摊子，最后都会成为你人生中无法收拾的烂尾楼吗？ 成年人的决定，想象超人想象特工是一种逃避逃不过 但是人生总有逃不过的时候，体体面面的分手从此在没有相见,这是成年人的分手，面对自己，面对对方。逃得过生离，逃得过死别吗 面对不完美的结局，并体面的收拾自己的烂摊子，人生必须处处 锥心，才有真心成熟而全面的决定 感性和理想票两票 其他 爱没有公不公平，只有愿不愿意，无法回到从前 单身狗，直男脱单，难于脱贫 两票，正常人只有感谢票，还他妈看脸，撕逼后我当时怎么就蒙住了呢，不当面能更好的撕 导师总结 不再驾驭感情，而是懂得感激；什么是驾驭感情，你在设计一种模式，比如说感激应该漂漂亮亮，感激应该是轻松的。感激这个事情是两个人的事情，是两个人最后化反的最终结果，你只能懂得我想我们不需要再继续走下去了，至少我觉得有困难，你是希望当面聊一聊，你还是希望这样就好了，那我随时在这里 辩题前提是一个人想见，一个人不见，不如不见 结辩 【重点】 该做不到，交代 两个底线1.我们在一起绝不互相绑架，一定要尊重对方的意志 我们不在一起我们绝不互相伤害，我们要文明。幼稚的定义，目标既定的情况下采取的策略是错的。– 你想分就分见个面就分幼稚— 我的目标是什么， 成人的世界没有态度的该不该，我的价值观稳定情况下，我设定的目标怎样拆解成方法和行动— 我的目标是分手而且对对方的伤害降得最低— 具体比抽象更伤害越抽象越尊重越不伤害– 长大 遇到危险伴侣手刀（快速逃跑）逃跑 该不该原谅他 20170421 赵又廷撒狗粮三生三世只爱高圆圆 马贱越爱情可以战胜一切，只要你爱他，就原谅他，否则，只做单身狗，只做自己 首尔 本能和本能之间差出和谐的火花 类比吵架维持内心和谐的次序，问路大叔，半身水池 烂事和惩罚的平衡 不原谅是对自己的一种救赎，原谅伴随着你对人性弱点的接纳和妥协，这样你会只相信人性，不相信人#### 灾难来了谁都得跑； 男的站着，女的跑 中国感动是教育（灾难面前人人都平等），我们以为人类仿佛应该是这样的，如果ta没做到这样子，ta就是不对的，其实他做到这样子，你更应该感谢的。因为，我们希望我们的爱情是获得式的爱情，不是索取式的爱情，他给你了你很高兴，他没给你这也很正常。感动时刻–&gt; 这个是加分项，不是底线，ta做到了你要感谢他 不原谅，放不下。灾难来了，没有太大的价值去怀念去铭记，你既是慷他之慨，也是慷自己之慨。浙大美女学霸 双重标准，爱情观中清单不可原谅的事情上，下面该不该原谅。张爱玲和胡兰成的事情，没有守住底线。爱情双方是增值的过程。 爱情能战胜一些本能的欲望与诉求； 因为我还是对爱情有一点点底线，一点点要求的人，我不希望我别成一个爱情只对我有要求的人，我不希望我变成爱情的努力。 永开 见死不救和灾难不同 可逃不可逃，为什么这个情景我们希望对方能活下来，为什么我们心中不原谅的情绪，我们不原谅的是那一个没有办法全心全意为对方担心的自己 自己的故事，如果恨我能让你感觉舒服一点点的话那你就恨我吧，没关系的。恨他没有让我得到救赎，甚至盖过了我幸福的瞬间 这对双方都是灾难 段子医生 有判断的，心里创伤 原谅和不原谅都轻描淡写了，所有说不原谅就是不要轻易的原谅； 呼唤爱 五秒性格，决定一生太鲁莽导师结辩-]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计相关]]></title>
    <url>%2F2018%2F04%2F15%2F2018-4-15-designer%2F</url>
    <content type="text"><![CDATA[相关开源库AE动画设计 + lottie-android 【简易的惊艳动画.必看】 fack-rebound 弹性动画 有网页Demo 能大大的提高用户体验 代码开源库控件 Genius-Android]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio 使用总结]]></title>
    <url>%2F2018%2F04%2F15%2F2018-4-15-android-studio-usage%2F</url>
    <content type="text"><![CDATA[常用插件 ADB Comand 3星 GsonFormatString 解析成实体 Default Option + s(Mac), Alt + s (win) Key Promoter X 快捷键提示 AS plugin 搜索安装 codota 代码案例查找【重点】 快捷键 Shift + Alt + Space CodeGlance 代码概况 Parcelable Plugin 优化 dexcount-gradle-plugin 每次编译都统计Field and Method number UI android-drawable-importer android-selector Material Design Icon Generator Android-drawable-preview-plugin Android Styler 相对于AS提供的功能，这个优势在能指定style存放的文件及相对的位置； 其他 idea-multimarkdown【收费】 gradle-maven-publish-plugin 上传你的代码到所有的版本仓库中 DepSwitchPlugin aar和源码切换，开发阶段源码，稳定阶段用aar 高级Android studio 插件的开发 How to Develop Android Studio Plugin]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android studio</tag>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 常用开源库]]></title>
    <url>%2F2018%2F04%2F14%2F2018-4-14-android-open-source-tools%2F</url>
    <content type="text"><![CDATA[正在研究 SUtils 封装有许多实用的开发工具类 APKParser parceler通过注解的方式序列化对象more: Transfuse Transfuse is a Java Dependency Injection (DI) and integration library geared specifically for the Google Android API. 数据库工具 android-sqlite-asset-helper 构建工具 MultiChannelPackageTool 快速多渠道打包工具。 开发中实用的工具 RoboGif A small utility to record Android device screen to a GIF AppUninstall Android App监听自身卸载，反馈统计 UI AndroidDesignPreview AndroidAssetStudio Android常用图标生成Web 切图标记外挂神器 Assistor PS 介绍 动态修改App字符开源库 Philology检测优化工具 LeakCanary Android 和 Java 内存泄露检测Tutorial ChineseEnglishphrof file path: /storage/sdcard0/Download/leakcanary/hprof-conv leakCanary apk-method-count 上传Apk，可以根据包名统计方法数量的网站，UI很友好。 battery-historian Google 官网方 针对 Api21 5.0以上系统开发的电量使用情况分析工具 功能性开发工具 card.io-Android-source 信用卡扫描ＳＤＫ reprint A simple, unified fingerprint authentication library for Android with ReactiveX extensions. DimensCodeTools 一个可以支持生成二维码，条形码和扫描的库 Permission Dexter Dexter is an Android library that simplifies the process of requesting permissions at runtime. PermissionHelper easypermissions 图片加载PicassoUniversal-ImageLoaderVolleyGlide Tutorial Chinese综合： 开源组件加载网络图片的优缺点比较 FileDownload Android-Download-Manager-Pro MultiThreadDownloader 下载 FileDownloader Multitask、Breakpoint-resume、High-concurrency、Simple to use、Single-process Once some info may show once in a new app in a update or first time install this via share sharedPreferences sore the timestamp 基础的开发工具 JavaVerbalExpressions Java regular expressions made easy. 帮助简单的实现正则表达 joda-time-android／ThreeTenABP Java8 的Date包移植到Android中来的库 MathView A library for displaying math formula in Android apps.崩溃错误处理LoadSir 优雅地处理加载中，重试，无数据等配置: compile ‘com.kingja.loadsir:loadsir:1.3.6’ProGuard:12-dontwarn com.kingja.loadsir.**-keep class com.kingja.loadsir.** &#123;*;&#125; BufferKnifeVIEW LISTS@OnClick({ R.id.door1, R.id.door2, R.id.door3 })123456789101112131415161718@BindViews(&#123; R.id.first_name, R.id.middle_name, R.id.last_name &#125;)List&lt;EditText&gt; nameViews;// The apply method allows you to act on all the views in a list at once.ButterKnife.apply(nameViews, DISABLE);ButterKnife.apply(nameViews, ENABLED, false);//Action and Setter interfaces allow specifying simple behavior.static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() &#123; @Override public void apply(View view, int index) &#123; view.setEnabled(false); &#125;&#125;;static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() &#123; @Override public void set(View view, Boolean value, int index) &#123; view.setEnabled(value); &#125;&#125;; An Android Property can also be used with the apply method.ButterKnife.apply(nameViews, View.ALPHA, 0.0f); RESOURCE BINDING1234567class ExampleActivity extends Activity &#123; @BindString(R.string.title) String title; @BindDrawable(R.drawable.graphic) Drawable graphic; @BindColor(R.color.red) int red; // int or ColorStateList field @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field // ...&#125; automatically be cast.1234@OnClick(R.id.submit)public void sayHi(Button button) &#123; button.setText(&quot;Hello!&quot;);&#125; OPTIONAL BINDINGS123@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() &#123; // TODO ...&#125; BINDING RESET on Fragments1234567891011 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); unbinder = ButterKnife.bind(this, view); // TODO Use fields... return view; &#125;@Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind(); &#125;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 代码规范化笔记]]></title>
    <url>%2F2018%2F04%2F14%2F2018-4-14-android-standards%2F</url>
    <content type="text"><![CDATA[代码规范化工具Square Android Code Style 下载-&gt; install.xx -&gt; restart-&gt;Code Style -&gt; Java 代码格式快捷键： Mac Cmd + Option + L Win Ctrl + Alt + LAS Plugin checkstyle-idea 安装plugin-&gt; reatart-&gt; Setting Other Setting -&gt; 可以导入自定义检查 运行 提交代码时自动格式化]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密钥和证书管理工具Keytool及jarsigner的使用]]></title>
    <url>%2F2017%2F04%2F19%2F2017-04-19-keytool_signerJar%2F</url>
    <content type="text"><![CDATA[Keytool简介keytool 是JDK 1.4 后集成的密钥和证书管理工具 官网文档·英文 Window：&lt;JAVA_HOME&gt;\bin\keytool.exeMac: &lt;JAVA_HOME&gt;/Contents/Home/bin 生成keystore1234567keytool -genkey -alias myAlias -keyalg RSA -validity 40000 -keystore demo.keystore#说明：# -genkey 产生密钥# -alias myAlias 别名 myAlias# -keyalg RSA 使用RSA算法对签名加密# -validity 40000 有效期限4000天# -keystore demo.keystore 查看 keystore签名信息12345678keytool -list -keystore demo.keystore 输出结果：--------------密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目myAlias, 2017-4-19, PrivateKeyEntry, 证书指纹 (SHA1): C1:4E:A3:BC:4D:C3:35:6C:F6:8A:9D:0E:EA:F3:79:4B:D9:1D:B4:C1 对apk进行签名1jarsigner -verbose -keystore [demo.keystore] -signedjar demo_signed.apk demo.apk [alias] Shell脚本获取指纹 【成果】Apk签名证书MD5指纹echo.sh12345678#/bin/shcert_XSA=`jar tf $1 | grep SA` #获取签名文件在Apk中路径, $1为输入的apk#echo $cert_XSAjar xf $1 $cert_XSA #提取签名文件echo --------------------------------------------------------------------------echo 证书MD5指纹:`keytool -printcert -file $cert_XSA | grep MD5`echo --------------------------------------------------------------------------rm -rf `dirname $cert_XSA` #删除提取的文件夹 Usage： source echo.sh demo.apk 证书文件操作 导出到证书文件keytool -export -alias myAlias -file test.crt -keystore test.keystore 将名为test.keystore的证书库中别名为test1的证书条目导出到证书文件test.crt 导入证书的信息keytool -import -keystore test_cacerts -file test.crt 将证书文件test.crt导入到名为test_cacerts的证书库中 查看证书信息 1234567891011121314151617181920212223keytool -printcert -file "test.crt"输出结果：---------所有者: CN=test, OU=android, O=android, L=shenzhen, ST=guangdong, C=china发布者: CN=test, OU=android, O=android, L=shenzhen, ST=guangdong, C=china序列号: 6f75ebb1有效期开始日期: Wed Apr 19 12:17:14 CST 2017, 截止日期: Fri Oct 25 12:17:14 CST 2126证书指纹: MD5: E0:93:87:28:43:D9:85:12:B2:41:36:D6:E2:BC:7C:83 SHA1: C1:4E:A3:BC:4D:C3:35:6C:F6:8A:9D:0E:EA:F3:79:4B:D9:1D:B4:C1 SHA256: 51:E8:9D:ED:64:62:4C:80:D4:42:69:41:9C:0C:E4:3B:89:FE:34:E6:A4:42:47:83:FB:CF:99:BD:DA:39:DA:90 签名算法名称: SHA256withRSA 版本: 3扩展: #1: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 2E 49 AD 2B 2D 4E D3 0D 02 FC 5B 5F EF 00 77 0F .I.+-N....[_..w.0010: 5D 91 1D 1C ]...]]]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 高效图片加载]]></title>
    <url>%2F2017%2F04%2F17%2F2017-04-17-Optimization-Bitmap%2F</url>
    <content type="text"><![CDATA[图片加载一直是程序稳定性的重要因素，但是随着Glide，Picasso，Universal-ImageLoader等图片加载库的逐渐成熟，反而会使我们对图片加载掉以轻心，疏忽对图片加载的操作，导致内存占用过高，频繁出现OOM(OutOfMemory)异常，严重影响用户体验。 Bitmap秘籍inJustDecodeBounds取关键信息，不加载到内存加载图片之前就获取到图片的长宽值和MIME类型，不加载进内存，从而根据情况对图片进行压缩123456BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeResource(getResources(), R.id.myimage, options);int imageHeight = options.outHeight;int imageWidth = options.outWidth;String imageType = options.outMimeType; Note： 最理性的加载情况是，不穿小鞋也不穿大鞋 inSampleSize等比例压缩很多情况下我们是在大脚穿小鞋的情况，例如：用相机拍照返回的原图1024x768像素，直接用来显示头像ImageView只有128x96像素，设置inSampleSize=4，从原画中每4像素提取1给像素到目标图片，这样就减少内存使用；计算出合适的inSampleSize值12345678910111213141516public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // 源图片的高度和宽度 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; // 计算出实际宽高和目标宽高的比率 final int heightRatio = Math.round((float) height / (float) reqHeight); final int widthRatio = Math.round((float) width / (float) reqWidth); // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高 // 一定都会大于等于目标的宽和高。 inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio; &#125; return inSampleSize;&#125; 合并使用先开启inJustDecodeBounds只读取获取高宽关键信息，获得合适的inSimpleSize的值，合理加载图片；123456789101112public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) &#123; // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小 final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // 调用上面定义的方法计算inSampleSize值 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 使用获取到的inSampleSize值再次解析图片 options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options);&#125; InputStream 中使用1234567891011121314151617181920212223242526 public static Bitmap getFitSampleBitmap(InputStream inputStream, int width, int height) throws Exception &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; byte[] bytes = readStream(inputStream); //BitmapFactory.decodeStream(inputStream, null, options); BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options); options.inSampleSize = getFitInSampleSize(width, height, options); options.inJustDecodeBounds = false;// return BitmapFactory.decodeStream(inputStream, null, options); return BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options); &#125; /* * 从inputStream中获取字节流 数组大小 * */ public static byte[] readStream(InputStream inStream) throws Exception &#123; ByteArrayOutputStream outStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while ((len = inStream.read(buffer)) != -1) &#123; outStream.write(buffer, 0, len); &#125; outStream.close(); inStream.close(); return outStream.toByteArray(); &#125; 使用内存缓存技术LruCacheLruCache 在android-support-v4的包中提供, 它的主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。 LruCache.java123456789101112131415161718192021222324252627private LruCache&lt;String, Bitmap&gt; mMemoryCache;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。 // LruCache通过构造函数传入缓存值，以KB为单位。 int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 使用最大可用内存值的1/8作为缓存的大小。 int cacheSize = maxMemory / 8; mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap bitmap) &#123; // 重写此方法来衡量每张图片的大小，默认返回图片数量。 return bitmap.getByteCount() / 1024; &#125; &#125;;&#125;public void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123; if (getBitmapFromMemCache(key) == null) &#123; mMemoryCache.put(key, bitmap); &#125;&#125;public Bitmap getBitmapFromMemCache(String key) &#123; return mMemoryCache.get(key);&#125; 如上，最核心的问题是如何合理的分配LruCache的大小，关键因素：设备 应用可分配内存； 设备屏幕和分辨率 图片 尺寸和大小及对应的消耗内存； 访问的频率； 动态保持的图片数量及内存总量； Glide 图片优化根据ImageView的大小，指定请求图片大小用 resize(x,y) 调整图片大小用CenterCrop, FitCenter调整显示效果1234567Glide .with(context) .load(UsageExampleListViewAdapter.eatFoodyImages[0]) .override(600, 200) // resizes the image to these dimensions (in pixel) //.fitCenter() .centerCrop() // this cropping technique scales the image so that it fills the requested bounds and then crops the extra. .into(imageView); 常用方法 获得应用程序最高可用内存12int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);Log.d("TAG", "Max memory is " + maxMemory + "KB"); 官方资源 Handling Bitmaps 【需翻墙】 DisplayingBitmaps.zip DisplayingBitmaps部分讲解： Android中高效的显示图片 - Bitmap的内存模型 参考 [1] ANDROID高效加载图片，有效避免程序OOM [2] Glide 系列预览]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Data Binding 详解及使用案例]]></title>
    <url>%2F2017%2F04%2F02%2F2017-04-02-Data-Binding%2F</url>
    <content type="text"><![CDATA[构建环境使用条件 支持 Android 2.1 (API level 7+). Android Plugin for Gradle 1.5.0-alpha1 或更高123456buildscript &#123; ... dependencies &#123; classpath 'com.android.tools.build:gradle:1.5.0-alpha1' &#125;&#125; 开启123456android &#123; .... dataBinding &#123; enabled = true &#125;&#125; 基本用法 （Data Binding Layout Files）绑定实体数据到指定布局（Layout）1234567891011121314public class User &#123; private final String firstName; private final String lastName; public User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; public String getFirstName() &#123; return this.firstName; &#125; public String getLastName() &#123; return this.lastName; &#125;&#125; 如果我需要用Layout展示用户信息 User，通常我们的做法就是 新建Layout.xml； 找到对应控件，findIdByView或 Butterknife ； 设置数据； 感觉用Butterknife已经很高大上，很高效了，看一下Data Binding的效率：main_activity.xml123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:id="@+id/mFirstName" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; MainActivity.java1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); User user = new User("Test", "User"); binding.setUser(user);&#125; 高效没看出来呀！为了让接手的下一个兄弟不骂娘，我还是选择普通写法o(╯□╰)o，那如果是这种布局呢 你用几百行的代码，DataBinding一行搞定，Boss此刻应该蹲在厕所喜极而泣，我XX我早该找一个这样的程序员。 小知识点 Fragment ,ListView,RecyclerView 中的使用 12345// ListView RecyclerViewListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);//FragmentMainFragmentBinding binding = DataBindingUtil.inflate(inflater, R.layout.main_fragment, container, false); 如果想操作对应的控件需要设置id号，如main_activity.xml, 设置android:id=&quot;@+id/mFirstName&quot; ，可以直接用binding.mFirstName 找到控件 ； 【待处理】测试中得到binding12MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false); 事件绑定（Event Handling）最简单的应用main_activity.xml12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handlers" type="com.example.MyHandlers"/&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;" android:onClick="@&#123;handlers::onClickFriend&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 事件处理类123public class/*也可以是接口*/ MyHandlers &#123; public void onClickFriend(View view) &#123; ... &#125;&#125; 控制代码同上，设置变量就可以binding.setHandlers(...) 带参数的事件绑定（Android Plugin for Gradle 2.0 或更高）main_activity.xml 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handlers" type="com.example.MyHandlers"/&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;" android:onClick="@&#123;() -&gt; handlers.onSaveClick(user)&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 事件处理类123public class MyHandlers &#123; public void onSaveClick(User user)&#123;&#125;&#125; 传入View方式1android:onClick=&quot;@&#123;(theView) -&gt; handlers.onSaveClick(theView, user)&#125;&quot; 或12&lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:onCheckedChanged="@&#123;(cb, isChecked) -&gt; handlers.completeChanged(user, isChecked)&#125;" /&gt; 注意：避免一些比较复杂的listeners，这样会使得Layout更易读更容易维护 Data Layout 小细节及简单语法Imports123456789101112&lt;data&gt; &lt;import type="android.text.TextUtils"/&gt; &lt;!--静态类的使用--&gt; &lt;import type="android.view.View"/&gt; &lt;!--导入--&gt; &lt;variable name="note" type="String"/&gt;&lt;!--自动导入java.lang.*--&gt; &lt;import type="com.example.real.estate.View" alias="Vista"/&gt; &lt;!--别名解决同名类--&gt;&lt;/data&gt;&lt;TextView android:text="@&#123;TextUtils.isEmpty(user.lastName)? "default":user.lastName &#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"/&gt; &lt;!-【使用】--&gt; Note: 默认自动导入java.lang.*，常用的有Integer，String，StringBuffer，Math类 Binding Class Names 如上：MainActivityBinding 类 默认命名规则 包名+布局名去‘_’首字母大写+Binding 如： main_activity.xml ==&gt; MainActivityBinding.class 自定义的三种解释123&lt;data class="ContactItem"&gt;&lt;/data&gt; &lt;!--自定义名称--&gt;&lt;data class=".ContactItem"&gt;&lt;/data&gt; &lt;!--使用module包名--&gt;&lt;data class="com.example.ContactItem"&gt;&lt;/data&gt; &lt;!--指定包名--&gt; IncludesData layout 复用12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include layout="@layout/name" bind:user="@&#123;user&#125;"/&gt; &lt;include layout="@layout/contact" bind:user="@&#123;user&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 简单语法Java共同特征 Mathematical + - / * % String concatenation + Logical &amp;&amp; || Binary &amp; | ^ Unary + - ! ~ Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt; Comparison == &gt; &lt; &gt;= &lt;= instanceof Grouping () Literals - character, String, numeric, null Cast Method calls Field access Array access [] Ternary operator ?: Examples:123456android:text=&quot;@&#123;String.valueOf(index + 1)&#125;&quot;android:visibility=&quot;@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;&quot;android:transitionName=&apos;@&#123;&quot;image_&quot; + id&#125;&apos; android:text=&quot;@&#123;user.displayName ?? user.lastName&#125;&quot; 【重点】&lt;==&gt; 等价于android:text=&quot;@&#123;user.displayName != null ? user.displayName : user.lastName&#125;&quot; Resources引用 Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList Sample123android:text=&quot;@&#123;@string/nameFormat(firstName, lastName)&#125;&quot;android:text=&quot;@&#123;@plurals/banana(bananaCount)&#125;&quot;android:padding=&quot;@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;&quot; String formatting123456&lt;resources&gt; &lt;string name=&quot;greeting&quot;&gt;Hello, %s&lt;/string&gt;&lt;/resources&gt;&lt;TextView android:text=&quot;@&#123;@string/greeting(user.firstName)&#125;&quot;/&gt; Math in expressions1234567&lt;TextView android:padding="@dimen/padding" android:padding="@&#123;@dimen/padding&#125;" android:padding="@&#123;@dimen/padding * 2&#125;" android:padding="@&#123;@dimen/padding + @dimen/padding&#125;" android:padding="@&#123;largeScreen ? @dimen/padding * 2 : @dimen/padding&#125;"/&gt; 更改数据自动更新UI界面 （Data Objects）经过上的学习，有木有发现， 布局Layout中的数据variables是固定的，只有初始化的时候赋值 数据变动时（设置数据，得到数据），还需要找控件，设置参数，更改UI状态, 基本还是老套路，官方的解决方案是Observable，使用观察者模式，当数据变化时通知layout自动变化，官方提供的类： Observable Objects ； ObservableFields ； Observable Collections； Observable Objects1234567891011121314151617181920public static class User extends BaseObservable &#123; private String firstName; private String lastName; @Bindable public String getFirstName() &#123; return this.firstName; &#125; @Bindable public String getLastName() &#123; return this.lastName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; notifyPropertyChanged(BR.firstName); &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; notifyPropertyChanged(BR.lastName); &#125;&#125; 经过改造后的User,同上的初始化12345678910111213141516171819202122232425private User user ;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); user = new User("Test", "User"); binding.setUser(user); //点击LastName触发 binding.setHandlers(new MyHandlers() &#123; @Override public void onClickFriend(View view) &#123; user.setFirstName("FirstName"); //布局自动更新为`FirstName` //此后常用的操作 //布局中Progress android:visibility="@&#123;TextUtil.isEmpty(user.firstName) ? View.GONE : View.VISIBLE&#125;" // 自动控制对应的Progress是否显示，或进行一些简单的逻辑处理 &#125; &#125;); &#125; ObservableFields1234567891011private static class User &#123; public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125;// 对应的set/getuser.firstName.set("Google");int age = user.age.get(); Observable Collections1234ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();user.put("firstName", "Google");user.put("lastName", "Inc.");user.put("age", 17); 高阶用法在RecyclerView中的使用 （Dynamic Variables）BindingHolder.java123456789101112131415public static class BindingHolder extends RecyclerView.ViewHolder&#123; //加入 ViewDataBinding setter/getter 方法 private ViewDataBinding binding ; public ViewDataBinding getBinding() &#123; return binding; &#125; public void setBinding(ViewDataBinding binding) &#123; this.binding = binding; &#125; public BindingHolder(View itemView) &#123; super(itemView); &#125;&#125; MyAdapter.java123456789101112131415161718192021222324252627282930private class MyAdapter extends RecyclerView.Adapter&lt;BindingHolder&gt;&#123; private List&lt;User&gt; users; public MyAdapter(List&lt;User&gt; users) &#123; this.users = users; &#125; @Override public BindingHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) &#123; //核心代码 ViewDataBinding binding = DataBindingUtil.inflate( LayoutInflater.from(viewGroup.getContext()), R.layout.list_item, viewGroup, false); BindingHolder holder = new BindingHolder(binding.getRoot()); holder.setBinding(binding); return holder; &#125; @Override public void onBindViewHolder(BindingHolder holder, int position) &#123; User user = users.get(position); holder.getBinding().setVariable(BR.user, user); //不等待下一帧（Frame），直接更新，这个方法必须运行在UI线程 holder.getBinding().executePendingBindings(); &#125; @Override public int getItemCount() &#123; return users.size(); &#125; &#125; 更简洁的用法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class UserAdapter extends RecyclerView.Adapter&lt;UserAdapter.UserHolder&gt; &#123; private static final int USER_COUNT = 10; @NonNull private List&lt;User&gt; mUsers; public UserAdapter() &#123; mUsers = new ArrayList&lt;&gt;(10); for (int i = 0; i &lt; USER_COUNT; i ++) &#123; User user = new User(RandomNames.nextFirstName(), RandomNames.nextLastName()); mUsers.add(user); &#125; &#125; public static class UserHolder extends RecyclerView.ViewHolder &#123; private UserItemBinding mBinding; public UserHolder(View itemView) &#123; super(itemView); mBinding = DataBindingUtil.bind(itemView); &#125; public void bind(@NonNull User user) &#123; mBinding.setUser(user); &#125; &#125; @Override public UserHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; View itemView = LayoutInflater.from(viewGroup.getContext()) .inflate(R.layout.user_item, viewGroup, false); return new UserHolder(itemView); &#125; @Override public void onBindViewHolder(UserHolder holder, int position) &#123; holder.bind(mUsers.get(position)); &#125; @Override public int getItemCount() &#123; return mUsers.size(); &#125;&#125; ViewStubs使用ViewStub 是不可见的,0大小常用于惰性加载，说白了就是占给位置，在父容器的inflate时候不用处理，当在ViewStub setVisibility(int) or inflate()才会加载到布局中，应用场景：错误提示，帮助提示，用户引导等；用法：12345&lt;ViewStub android:id="@+id/stub" android:inflatedId="@+id/subTree" android:layout="@layout/mySubTree" android:layout_width="120dip" android:layout_height="40dip" /&gt; 12ViewStub stub = (ViewStub) findViewById(R.id.stub); View inflated = stub.inflate(); Data layout12345678910&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;LinearLayout ...&gt; &lt;!--需要增加ID--&gt; &lt;ViewStub android:id="@+id/view_stub" android:layout="@layout/view_stub" ... /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 监听ViewStub inflate 事件12345678binding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() &#123; @Override public void onInflate(ViewStub stub, View inflated) &#123; ViewStubBinding binding = DataBindingUtil.bind(inflated); User user = new User("fee", "lang"); binding.setUser(user); &#125;&#125;); 自定义Setter实用小例子：设置url，控件直接加载url地址的图片attrs.xml1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;attr name="url" format="string"/&gt;&lt;/resources&gt; 在任意代码中加入如下：123456@BindingAdapter("url")public static void loadImage(final ImageView imageView, final String url)&#123; Glide.with(imageView.getContext().getApplicationContext()) .load(url) .into(imageView);&#125; 能得到变化的url及对应的ImageView控件 特殊说明: MasteringAndroidDataBinding中是用declare-styleable加自定义控件的方法来处理数据变化，上面的例子最能达到实践效果，在原生控件中加入自定义是属性,简洁易用； BindingAdapter进价用法观察多个属性 如： @BindingAdapter(value = {&quot;url&quot;,&quot;drawable&quot;},requireAll = false) requireAll指 布局控件中是否需要&quot;url&quot;`“drawable”` 属性都存在，默认为true；监听原生控件的属性变化，做响应的处理（重写），如：1234567@BindingAdapter("android:paddingLeft")public static void setPaddingLeft(View view, int padding) &#123; view.setPadding(padding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom());&#125; 获取变化的旧数据和新数据，自义定属性也能使用123456789@BindingAdapter("android:paddingLeft") //注意：android:paddingLeft 可以改为自定义的Setter属性，如上‘url’public static void setPaddingLeft(View view, int oldPadding, int newPadding) &#123; if (oldPadding != newPadding) &#123; view.setPadding(newPadding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); &#125;&#125; 总结: Data Binding 核心思想是把控件的属性用静态变量代表，并监听属性的变化，通过BindingAdapter来处理数据变化；如果不是很有感觉, 有兴趣进一步研究，建议看一下MVVMLight源码, 一个Data Binding 和RxJava 结合使用的库 单元测试【待实践】安卓 Data Binding 使用方法总结（姐姐篇） 学习资料实在的博客工作原理 Android Data Binding从抵触到爱不释手 比较详细，特别是有源码分析 开源库学习资料 MVVMLight源码, 一个Data Binding 和RxJava 结合使用的库 TODO-DataBinding 和MVP结合使用，Google 官方例子 附录Resource 引用对照表 Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList 常用转义表123456789显示结果 描述 转义字符 十进制 空格 &amp;nbsp; &amp;#160;&lt; 小于号 &amp;lt; &amp;#60;&gt; 大于号 &amp;gt; &amp;#62;&amp; 与号 &amp;amp; &amp;#38;" 引号 &amp;quot; &amp;#34;‘ 撇号 &amp;apos; &amp;#39;× 乘号 &amp;times; &amp;#215;÷ 除号 &amp;divide; &amp;#247; 引用： Data Binding Library MasteringAndroidDataBinding Data Binding in the Real World 安卓 Data Binding 使用方法总结（姐姐篇）]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2017%2F02%2F21%2F2017-02-21-linux-study%2F</url>
    <content type="text"><![CDATA[常用的命令日常常用1234567891011121314151617181920212223242526cp /etc/apt/sources.list /etc/apt/sources.list.2015.06.05vim /etc/apt/sources.listsudo chmod ugo+rwx //user + read write execution permisstion ps -ef | grep "key_word"edward 7751 7723 0 23:01 ? 00:00:00 /usr/share/android-studio/bin/fskill 7723sudo lsb_release -a // look ubuntu versionuname -r //kernal versionnetstat –tln //查看服务监听端口netstat //查看进程号ps –aux //查看进程号ps –aux | more //全部查看ps –ef | grep mysql //查看mysql的进程kill -9 3306 //强制杀掉进程号3306sudo gdebi sogou_pinyin_linux_1.0.0.0014_amd64.debvim ~/.bashrcalias pbcopy="xclip -selection c"alias pbpaste="xclip -selection clipboard -o"source ~/.bashrcdiff -ruNa dir1 dir2 &gt; s12.diffpcmanfm . 当前路径当前文件管理 加压和解压1234567891011121314151617181920212223242526272829303132333435363738394041424344.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName---------------------------------------------.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知---------------------------------------------.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName---------------------------------------------.tgz解压：tar zxvf FileName.tgz压缩：未知.tar.tgz解压：tar zxvf FileName.tar.tgz压缩：tar zcvf FileName.tar.tgz FileName---------------------------------------------.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName---------------------------------------------.rar解压：rar a FileName.rar压缩：r ar e FileName.rargz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName 几种快速清空文件内容的方法1234echo "" &gt; fileNameecho /dev/null &gt; fileNameecho &gt; fileNamecat /dev/null &gt; fileName 软件安装问题upgrade 部分链接报错 GPG error: http://deb.playonlinux.com trusty InRelease: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY E0F72778C4676186 签名过期==&gt; 解决： sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys E0F72778C4676186 学习资料博客 Linux shell 常用技巧系列教程 Ubuntu下配置支持Windows访问的Samba共享 bash shell命令行选项与修传入参数处理 常用软件使用vim ～/.vimrc hi Comment ctermfg =blue #蓝色注释 git config –global core.editor vim 中文乱码 set fencs=utf-8,GB18030,ucs-bom,default,latin1 设置TABset ts=4 (注：ts是tabstop的缩写，设TAB宽4个空格)set expandtab对于已保存的文件，可以使用下面的方法进行空格和TAB的替换：TAB替换为空格：:set ts=4:set expandtab:%retab!空格替换为TAB：:set ts=4:set noexpandtab:%retab!加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。 常用命令 vim FileName +LineNumber == vim + LineNumber Filename VPN Shadowsocks免费翻墙账号网站大集合https://www.lightss.xyz/user/node/index.phpkebi2014@gmail.comhttps://www.ss-link.com/my/freehttps://www.shadowsocksx.me/SwitchyOptions.bak下载1234sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5ss-qt5 自己搭建 搬瓦工的vps Lubuntu 精简Linux系统的使用好玩的工具lolcat gem install lolcat]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Basic</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本UI空控件的用方法和属性]]></title>
    <url>%2F2017%2F02%2F17%2F2017-02-17-basic-ui-study%2F</url>
    <content type="text"><![CDATA[控件使用ViewFlipper setInAnimation/setOutAnimation showNext/showPrevious getDisplayedChild() ==&gt; index ==&gt; getChildAt addView(view)/addView(view,position) AbsListView setSelector(new ColorDrawable(Color.TRANSPARENT)); GridView setNumColumns; setVerticalSpacing/setHorizontalSpacing AnimationSet = AnimationUtils.loadAnimation() Tip: 在GridView 的Adapter 内的View 设置setOnClickListener 会导致 设置的 GestureDetector.SimpleOnGestureListener.onFling返回的MotionEvent == null; EditText 显示/隐藏密码 1setInputType(hasShowPassword ? 129 : InputType.TYPE_TEXT_VARIATION_PASSWORD); 光标位置(定位到最后) 1edittext.setSelection(int) 获取焦点 123456editText.requestFocus();//获取焦点如果对edittext组件设置了editText.setFocusable(false);需要重新获取焦点则必须执行：editText.setFocusable(ture);editText.setFocusableInTouchMode(true);editText.requestFocus();注意：这种情况下，当重新点击文本框，是无法打开软键盘，必须点击第二次才能打开。 ViewPager setPageTransformer(); //设置页面切换效果 JazzyViewPager 提供11种切换效果 经常直播的效果123456789101112131415161718192021222324252627282930313233343536public class DepthPageTransformer implements PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) ///看不到的一页 * // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; ListView List内容平滑的移动到指定的位置 smoothScrollToPosition(position); PopupWindow 一定要设置的：View contentView，int width, int height; 1234567891011//构造方法：public PopupWindow (Context context)public PopupWindow(View contentView)public PopupWindow(View contentView, int width, int height)public PopupWindow(View contentView, int width, int height, boolean focusable)//常用的初始化View contentView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popuplayout, null);PopupWindow popWnd = PopupWindow (context);popWnd.setContentView(contentView);popWnd.setWidth(ViewGroup.LayoutParams.WRAP_CONTENT);popWnd.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT); 显示 123456//相对某个控件的位置（正左下方），无偏移showAsDropDown(View anchor)：//相对某个控件的位置，有偏移;xoff表示x轴的偏移，正值表示向左，负值表示向右；yoff表示相对y轴的偏移，正值是向下，负值是向上；showAsDropDown(View anchor, int xoff, int yoff)：//相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移showAtLocation(View parent, int gravity, int x, int y)： 添加动画mPopWindow.setAnimationStyle(R.style.contextMenuAnim);contextMenuAnim.xml 1234&lt;style name="contextMenuAnim" parent="@android:style/Animation.Activity"&gt; &lt;item name="android:windowEnterAnimation"&gt;@anim/context_menu_enter&lt;/item&gt; &lt;item name="android:windowExitAnimation"&gt;@anim/context_menu_exit&lt;/item&gt; &lt;/style&gt; context_menu_exit.xml1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="100%p" /&gt; &lt;/set&gt; setFocusable EditText 是否点击后可编辑 mPopWindow.setBackgroundDrawable(new BitmapDrawable()) 的作用 setOutsideTouchable（）才会生效 PopupWindow才会对手机的返回按钮有响应 API &gt;= 23 setEnterTransition(Transition) or setExitTransition(Transition) 参考： PopupWindow才会对手机的返回按钮有响应 常用的UI方法获取xml属性1234567// Calculate ActionBar heightTypedValue tv = new TypedValue(); if (context.getTheme().resolveAttribute( android.R.attr.actionBarSize, tv, true)) &#123; mActionBarHeight = TypedValue.complexToDimensionPixelSize( tv.data, context.getResources().getDisplayMetrics()); &#125;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Basic</tag>
        <tag>support</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout入门体验]]></title>
    <url>%2F2017%2F02%2F07%2F2017-02-07-ConstraintLayout-study%2F</url>
    <content type="text"><![CDATA[ConstraintLayout 核心思想：平面内确定一点]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>support</tag>
        <tag>UI</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaDoc学习笔记]]></title>
    <url>%2F2017%2F02%2F05%2F2017-02-05-java-doc%2F</url>
    <content type="text"><![CDATA[官方学习文档 How to Write Doc Comments for the Javadoc Tool 常用的HTML标签 标签 含义 &lt;strong&gt;&lt;/strong&gt; 字体加粗 &lt;p&gt; 换行 &lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt; 图片引用 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 超链接内容 加粗 strong&lt;strong&gt;Strong&lt;/strong&gt; 超链接 href&lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;Rx Design Guidelines (PDF)&lt;/a&gt; 换行123/** &lt;p&gt;***/ 图片引用&lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/create.png&quot; alt=&quot;&quot;&gt; 常用的格式 标题加粗换行12345678910/*** &lt;dl&gt;* &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;* &lt;dd&gt;The &#123;@code OnSubscribe&#125; instance provided is responsible to be backpressure-aware or* document the fact that the consumer of the returned &#123;@code Observable&#125; has to apply one of* the &#123;@code onBackpressureXXX&#125; operators.&lt;/dd&gt;* &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;* &lt;dd&gt;&#123;@code create&#125; does not operate by default on a particular &#123;@link Scheduler&#125;.&lt;/dd&gt;* &lt;/dl&gt;**/]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>JavaDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 学习笔记]]></title>
    <url>%2F2017%2F02%2F01%2F2017-02-01-rx-learning-note%2F</url>
    <content type="text"><![CDATA[为什么要学RxJava 最大的好处在于,很优雅处理各种线程切换,能使整个代码块的逻辑连贯,易于阅读和维护; 提供丰富的操作符, 能使很多复杂的操作简单几步搞定; 运用响应式编程,使整个编程更流畅简洁; 开源库 RxJava&nbsp;&nbsp;&nbsp;&nbsp; RxAndroid Rx Sample RxUi Implementation of pure functional concept of talking to Android View layer in a Reactive way ReactiveCache Android-RxJava-samples Rex-weather Android animations powered by RxJava Rx 相关的开源工具库 RxAnimations RxBinding rx-preferences Reactive SharedPreferences for Android requery 支持RxJava Kotlin / Android ORM库 RxLifecycle 处理由Activity 或 Fragment生命周期，导致没有完成的订阅（subscriptions）触发的内存泄露 Frodo 模仿Jake Wharton’s Hugo，使用Java切面编程的Android 日志工具库 RxIAPv3 一个用Rx封装后的 Android App内购支付库，提供几个购买、消费和商品清单列表的Rx方法。 RxFile RxCamera RxJava style API for android camera RxPermissions Android runtime permissions powered by RxJava Resource Homepage http://reactivex.io/ RxJava 操作符动画效果演示 http://rxmarbles.com/ Testing asynchronous RxJava code using Mockito RxRecipes: Wrap your way to Rx 主要讲 fromCallable() fromAction() 替换Rx中的接口； Rxify : The Anti Cache-then-Network OR Network-then-Cache Problem 使用RX concat onErrorResumeNext onErrorReturn 处理访问网络失败后返回本地缓存的机制。 Book: RxJavaEssentials.pdf 【英文】 RxJava Essentials 中文翻译版 官方文档 Doc for operators (操作符相关文档) Scheduler官方文档 【待研究】 RxJava Wiki 文档 Implementing Your Own Operators 【实现自己的操作符】【重点】 翻译文档 ReactiveX/RxJava文档中文版 一些高质量学习资源 Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#0 【重点】 Android开发技术周报特刊之RxJava&amp;RxAndroid Issue#1【重点】 给 Android 开发者的 RxJava 详解 使用RxJava构造Android清晰框架 Awesome-RxJava 一些RxJava的资料集合 【最爱】 Grokking RxJava, Part 1: The Basics 【英文】 操作符 操作符相关文章 木水川的博客 【强力推荐】 throttleFirst():RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) FlatMap无序，concatMap有序排列FlatMap应用场景： 1. 抽取对象的集合并逐个输出； 2. 嵌套回调解决回调地狱的问题；12345678910111213141516Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; Log.d(tag, course.getName()); &#125; ...&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); first() vs. takeFirst() The difference between the two calls is that first() will throw a NoSuchElementException if none of the sources emits valid data, whereas takeFirst() will simply complete without exception. .groupBy()一旦产生的Observable被订阅，分组产生的GroupedObservable就开始缓存，没有被订阅（处理）的GroupedObservable可能会引起内存泄露，故，对不想处理的GroupedObservable，使用take(0)释放缓存； combineLatest 笔记1234567891011121314151617181920212223242526272829303132333435363738394041操作符分类合并型combineLatestjoinmergemergeDelayErrorswitchOnNext操作符是把一组Observable转换成一个Observablezip操作符是把两个observable提交的结果，严格按照顺序进行合并截取添加分类型startWithbufferdebouncewindowgroupBydistinctelementAtfilterofTypefirstlastsinglesampleskipskipLasttake错误处理onErrorReturnonErrorResumeNext return ObserverableonExceptionResumeNext改变流程走向retryretryWhen其他concatMapcastscanignoreElements操作符忽略所有源Observable产生的结果，只把Observable的onCompleted和onError事件通知给订阅者 进价问题研究 线程控制 Scheduler在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn() vs observeOn() 对事情线程的影响； subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。1234567891011Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); Backpressure 【待研究】 生产速度比消费快,抛出MissingBackpressureException的异常官方对Backpressure的介绍及对应的解决方案 使用案例 省略subscribeOn()和observeOn()在切换线程时在Android开发的时候频繁使用subscribeOn()和observeOn()，后台线程和UI线程切换这可以可以抽离出来（文章：避免打断链式结构：使用.compose( )操作符）123456789 &lt;T&gt; Transformer&lt;T, T&gt; applySchedulers() &#123; return new Transformer&lt;T, T&gt;() &#123; @Override public Observable&lt;T&gt; call(Observable&lt;T&gt; observable) &#123; return observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); &#125; &#125;;&#125; 使用debounce做textSearch用简单的话讲就是当N个结点发生的时间太靠近（即发生的时间差小于设定的值T），debounce就会自动过滤掉前N-1个结点。解决频繁改变，导致的多余的网络访问（场景举例：删除多余信息）12345678910111213141516171819RxTextView.textChangeEvents(inputEditText) .debounce(400, TimeUnit.MILLISECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;TextViewTextChangeEvent&gt;() &#123; @Override public void onCompleted() &#123; log.d("onComplete"); &#125; @Override public void onError(Throwable e) &#123; log.d("Error"); &#125; @Override public void onNext(TextViewTextChangeEvent onTextChangeEvent) &#123; log.d(format("Searching for %s", onTextChangeEvent.text().toString())); &#125;&#125;); RxJava代替EventBus，Otto：RxBus 用RxJava实现事件总线(Event Bus) Implementing an Event Bus With RxJava - RxBus 延迟1234567891011121314151617Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; log.d ("completed"); &#125; @Override public void onError(Throwable e) &#123; log.e("error"); &#125; @Override public void onNext(Long number) &#123; log.d ("hello world"); &#125; &#125;); schedulePeriodically轮询123456789101112131415161718Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(final Subscriber&lt;? super String&gt; observer) &#123; Schedulers.newThread().createWorker() .schedulePeriodically(new Action0() &#123; @Override public void call() &#123; observer.onNext(doNetworkCallAndGetStringResult()); &#125; &#125;, INITIAL_DELAY, POLLING_INTERVAL, TimeUnit.MILLISECONDS); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; log.d("polling….”)); &#125; &#125;) 使用RxJava处理复杂的Url操作1234567query("Hello, world!") .flatMap(urls -&gt; Observable.from(urls)) //拆分List .flatMap(url -&gt; getTitle(url)) // 获取网站头名称 .filter(title -&gt; title != null) // 过滤掉title == null .take(5) // 取前5个 .doOnNext(title -&gt; saveTitle(title)) // 在得到结果前保存标题到Disk里 .subscribe(title -&gt; System.out.println(title)); 按顺序从内存–&gt;文件–&gt;网络获取资源,成功程序停止12345678910111213141516171819final Observable&lt;String&gt; memory = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; if (memoryCache != null) &#123; subscriber.onNext(memoryCache); &#125; else &#123; subscriber.onCompleted(); &#125; &#125;&#125;);Observable.concat(memory, disk, network).first().subscribeOn(Schedulers.newThread()).subscribe(s -&gt; &#123; memoryCache = "memory"; System.out.println("--------------subscribe: " + s);&#125;); 多个异步并发处理完，再更新123Observable.merge(observable1, observable2) .subscribeOn(Schedulers.newThread()) .subscribe(System.out::println); flatMap处理异步嵌套异步（Callback Hell）12345NetworkService.getToken("username", "password") .flatMap(s -&gt; NetworkService.getMessage(s)) .subscribe(s -&gt; &#123; System.out.println("message: " + s); &#125;); 按钮防抖12345RxView.clicks(findViewById(R.id.btn_throttle)) .throttleFirst(1, TimeUnit.SECONDS) .subscribe(aVoid -&gt; &#123; System.out.println("click"); &#125;); 响应式的界面勾选了某个checkbox，自动更新对应的preference123456SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);RxSharedPreferences rxPreferences = RxSharedPreferences.create(preferences);Preference&lt;Boolean&gt; checked = rxPreferences.getBoolean("checked", true);CheckBox checkBox = (CheckBox) findViewById(R.id.cb_test);RxCompoundButton.checkedChanges(checkBox) .subscribe(checked.asAction()); Fragment 旋转缓存【待研究】1234567891011121314@Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); /*.cache()操作符： 当第一个subscribe订阅的时候，才会连接原始Observable，缓存事件, 重发给后续订阅的subscribe 值得注意的事， 它和使用了.replay().publish()操作符的ConnectableObservable的不同。 另外，为了避免内存开销，不建议缓存大量事件*/ setRetainInstance(true); cacheObservable = weatherManager.getWeather().cache();&#125;@Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); cacheObservable.subscribe(/*your subscribe*/);&#125; 测试调试 【待研究】 Unit Testing RxJava Observables and Subscriptions Debugging RxJava on Android 实战笔记 RxJava-Android-SamplesRetrofitFragment.javaObservable.zip / Observable.just gist code DebounceSearchEmitterFragment.javaRxTextView.textChangeEvents gitst code BufferDemoFragment.java RxView.clickEvents/ .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 1234567891011121314private Subscription _getBufferedSubscription() &#123; return RxView.clickEvents(_tapBtn) .map(new Func1&lt;ViewClickEvent, Integer&gt;() &#123; @Override public Integer call(ViewClickEvent onClickEvent) &#123; Timber.d("--------- GOT A TAP"); _log("GOT A TAP"); return 1; &#125; &#125;) .buffer(2, TimeUnit.SECONDS) //收集2s内的点击事件到List中 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123;&#125; ）； PublishSubject 123456789PublishSubject&lt;Float&gt; _resultEmitterSubject = PublishSubject.create(); _subscription = _resultEmitterSubject.asObservable().subscribe(new Action1&lt;Float&gt;() &#123; @Override public void call(Float aFloat) &#123; _result.setText(String.valueOf(aFloat)); &#125; &#125;); _resultEmitterSubject.onNext(num1 + num2); @OnTextChanged PollingFragment.javaCompositeSubscription / interval /doOnSubscribe /repeatWhen /Observable.timer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 _subscriptions.add(// Observable.just(1) .repeatWhen(new RepeatWithDelay(pollCount, pollingInterval)) .subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object o) &#123; _log(String.format(Locale.US, "Executing polled task now time : [xx:%02d]", _getSecondHand())); &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable e) &#123; Timber.d(e, "arrrr. Error"); &#125; &#125;) ); _subscriptions.add(// Observable.interval(INITIAL_DELAY, POLLING_INTERVAL, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long heartBeat) &#123; return _doNetworkCallAndGetStringResult(heartBeat); &#125; &#125;).take(pollCount) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; _log(String.format("Start simple polling - %s", _counter)); &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String taskName) &#123; _log(String.format(Locale.US, "Executing polled task [%s] now time : [xx:%02d]", taskName, _getSecondHand())); &#125; &#125;) );public class RepeatWithDelay implements Func1&lt;Observable&lt;? extends Void&gt;, Observable&lt;?&gt;&gt; &#123; private final int _repeatLimit; private final int _pollingInterval; private int _repeatCount = 1; RepeatWithDelay(int repeatLimit, int pollingInterval) &#123; _pollingInterval = pollingInterval; _repeatLimit = repeatLimit; &#125; // this is a notificationhandler, all we care about is // the emission "type" not emission "content" // only onNext triggers a re-subscription @Override public Observable&lt;?&gt; call(Observable&lt;? extends Void&gt; inputObservable) &#123; // it is critical to use inputObservable in the chain for the result // ignoring it and doing your own thing will break the sequence return inputObservable.flatMap(new Func1&lt;Void, Observable&lt;?&gt;&gt;() &#123; @Override public Observable&lt;?&gt; call(Void blah) &#123; if (_repeatCount &gt;= _repeatLimit) &#123; // terminate the sequence cause we reached the limit _log("Completing sequence"); return Observable.empty(); &#125; // since we don't get an input // we store state in this handler to tell us the point of time we're firing _repeatCount++; return Observable.timer(_repeatCount * _pollingInterval, TimeUnit.MILLISECONDS); &#125; &#125;); &#125;&#125; RxBusDemoFragment.javaConnectableObservable / SerializedSubjectgist代码 123456789101112131415private final Subject&lt;Object, Object&gt; _bus = new SerializedSubject&lt;&gt;(PublishSubject.create());_bus.onNext(object);_bus.hasObservers();ConnectableObservable&lt;Object&gt; tapEventEmitter = _rxBus.toObserverable().publish(); _subscriptions// .add(tapEventEmitter.subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object event) &#123; if (event instanceof RxBusDemoFragment.TapEvent) &#123; _showTapText(); &#125; &#125; &#125;)); stream.buffer(stream.debounce(1, TimeUnit.SECONDS)); _subscriptions.add(tapEventEmitter.connect()); FormValidationCombineLatestFragment.java 1234private Observable&lt;CharSequence&gt; _numberChangeObservable = RxTextView.textChanges(_email_editText).skip(1); _subscription = Observable.combineLatest(_emailChangeObservable, _passwordChangeObservable, _numberChangeObservable, new Fun3...) PseudoCacheMergeFragment.javaObservable.merge();TimingDemoFragment.java 12345Observable.timer(2, TimeUnit.SECONDS)// //.just(1).delay(2, TimeUnit.SECONDS)// //.interval(1, TimeUnit.SECONDS)// //.interval(0, 1, TimeUnit.SECONDS)// //.interval(3, TimeUnit.SECONDS).take(5)// ExponentialBackoffFragment.java 1234567891011121314151617181920 Observable// .error(new RuntimeException("testing")) // always fails .retryWhen(new RetryWithDelay(5, 1000)) //当错误时调用，适用于错误处理 //1-4 指数的递增延迟Observable.range(1, 4)// .delay(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(final Integer integer) &#123; // Rx-y way of doing the Fibonnaci :P return MathObservable// .sumInteger(Observable.range(1, integer)) .flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(Integer targetSecondDelay) &#123; return Observable.just(integer) .delay(targetSecondDelay, TimeUnit.SECONDS); &#125; &#125;); &#125; &#125;)// 123RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 其他 RxJS RxJS The Reactive Extensions for JavaScript http://reactivex.io Big list of functions 常用函数的例子 Creating Observables 产生Observable的方法 The introduction to Reactive Programming you’ve been missing 对应的 Demo 参考 RxJava使用场景小结 使用RxJava构造Android清晰框架]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 学习积累]]></title>
    <url>%2F2017%2F01%2F08%2F2017-01-08-gradle-note%2F</url>
    <content type="text"><![CDATA[基础教程 实践博客 Google’s guide on Gradle for Android 美团Android自动化之旅—适配渠道包 Android Gradle实战中遇到的问题与经验 Maven 建立企业内部maven服务器并使用Android Studio发布公共项目。 Gradle Tutorial Gradle 用法总结 构建神器Gradle 翻译gradle for android ==&gt;gradle for android pdf Writing Custom Plugins gradle官方文档，自定义插件拿到Project类，就可以拿到几乎所有工程配置的属性和方法，然后发挥想象控制你的工程。 官网资料 Chapter 23. Dependency Management 【待研究】 Chapter 45. The Java Plugin DependencyHandler Gradle Plugin User Guide Android Studio 官网提供的Gradle实用教程 Android Plugin DSL Reference build.gradle android{….} API 进阶博文 Android Gradle编译过程 比较详细的讲述了Gradle 编译 Apk的过程。 Weapons for Boilerplate Destruction 之Gradle 篇以上project.extensions.create….,可以使用${project.myextension.aNumber}访问到对应的属性 进阶源码阅读 hugo JakeWharton 不必介绍了。项目中使用Gradle plugin 和自定义Task 顺便学习一些Process Annotation. 开源插件 gradle-android-junit-jacoco-plugin可以生成代码单元测试覆盖率报告的 Gradle 插件。 gradle-android-javadoc-plugin可以生成 java doc 的 Gradle 插件。 gradle-android-apk-size-plugin可以将 Apk 大小记录到 CSV 文件的 Gradle 插件。 android-fat-aar Gradle script that allows you to merge and embed dependencies in generted aar file. ProperDroid simplifies the way that config different variant on your project. dexcount-gradle-plugin A Gradle plugin to report the number of method references in your APK on every build. 使用案例 本地引入.aar文件 12345678dependencies &#123; compile(name:'nameOfYourAARFileWithoutExtension', ext:'aar') &#125;repositories&#123; flatDir&#123; dirs 'libs' &#125; &#125; gradleBuildTime.gradle 获取build脚本每个任务（Task）执行的时间。 gradle.properties 自定义 buildConfigField 外部变量 修改output/apk/[自定义].apk 每次构建工程把git版本控制的信息加入VersionName中 123def gitSha = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim()def gitTag = 'git tag'.execute([], project.rootDir).text.trim().split("\n").last()def gitCommits = Integer.parseInt('git rev-list --count HEAD'.execute([], project.rootDir).text.trim()) 动态修改Manifest中的参数 1234567891011121314android &#123; compileSdkVersion 23 buildToolsVersion '23.0.2' defaultConfig &#123; applicationId "com.liulishuo.engzo" minSdkVersion 15 targetSdkVersion 23 manifestPlaceholders = [ // 这里需要换成:tencent+你的AppId "tencentAuthId": "tencent123456", ] &#125;｝ 使用全局变量进行依赖版本及一些常用配置的统一管理 配置 Apk split 使Android Studio每个对应的Cpu 架构都生成单独的apk，减小整个应用的大小。 rootdirOfProject/gradle.properties 配置变量如： VERSION_NAME=1.2.2-SNAPSHOT 然后可以在配置文件所在项目中的所有*.gradle 文件直接引用。 有点类似Java public static的感觉。 Java 指定JDK版本 12345678android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7// targetCompatibility JavaVersion.VERSION_1_8// sourceCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 签名信息(release.keystore)的存放方式 stackoverflow Android — How to add Gradle dependencies using ‘foreach’ 很多开源项目都把依赖统一管理, 这个博文是做得做系统和简洁 问题解决 依赖更新项目依赖的远程包如果有更新，会有提醒或者自动更新吗？ 不会的，需要你手动设置changing标记为true，这样gradle会每24小时检查更新，通过更改resolutionStrategy可以修改检查周期。1234567configurations.all &#123;// check for updates every buildresolutionStrategy.cacheChangingModulesFor 0, 'seconds'&#125;dependencies &#123;compile group: "group", name: "projectA", version: "1.1-SNAPSHOT", changing: true&#125; 之前上传aar同一版本到maven仓库，但依赖却没有更新，该怎么办呢?可以直接删除本地缓存，缓存在~/.gradle/caches目录下，删除缓存后，下次运行就会自动重新下载远程依赖了。 Gradle 一直在后台下载 （更新Gradle 版本） 原因: 由于 services.gradle.org 国内下载速度很慢(一般为45kb/s), 而每个gradle-xx.xx.-all.zip 版本至少60MB, 也就正常是需要40分钟左右,花都谢了 修改{$your_project}/gradle/wrapper/gradle-wrapper.properties 方案一： 修改distributionUrl指定的版本为本地存在的版本(正常能跑的项目中找) 12345678//例如： 新的工程, gradle-wrapper.properties 文件,如下distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip// 只修改 distributionUrl 属性// 如: distributionUrl=.../gradle-3.3-all.zip 修改为: distributionUrl=.../gradle-2.14.1-all.zip 方案二： 直接从distributionUrl指定的链接下载如: https\://services.gradle.org/distributions/gradle-3.3-all.zip 一般浏览器下载比Android Studio快 或者搜索对应版本(gradle-3.3-all.zip),下载别人已经下载好的,国内节点2~3分钟搞定 ; 修改distributionUrl,指向本地文件 Window ==&gt; distributionUrl=file:///C:/downloads/gradle-2.1-all.zip Unix ==&gt; distributionUrl=file\:/tmp/gradle-2.2.1-all.zip 方案三: 直接把下载好的文件(gradle-xx.xx.-all.zip),放在{$your_project}/gradle/wrapper/下,也就是和gradle-wrapper.properties同一目录; 方案四: 把下载好的gradle-xx.xx.-xx.zip,放到gradle对应的缓存目录下,{文件md校验生成的文件名}/gradle-xx.xx.-xx.zip; 方案五： 直接更改 distributionUrl的下载路径为国内服务器，例如：http://mirrors.flysnow.org/1234567distributionUrl=http\://mirrors.flysnow.org/gradle/gradle-4.1-bin.zip如果你在 gradle.properties 配置了代理，请添加一个不走代理的配置，否则 gralde 无法安装systemProp.http.proxyHost=mirrors.neusoft.edu.cnsystemProp.http.proxyPort=80# 添加不走代理的 host，会影响 package 的安装systemProp.http.nonProxyHosts=172.1.1.227|localhost|mirrors.flysnow.org 使用阿里云国内镜像单个项目生效123456789101112131415buildscript &#123; repositories &#123; maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125; maven&#123; url &apos;http://maven.aliyun.com/nexus/content/repositories/jcenter&apos;&#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.2.3&apos; &#125;&#125;allprojects &#123; repositories &#123; maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125; maven&#123; url &apos;http://maven.aliyun.com/nexus/content/repositories/jcenter&apos;&#125; &#125;&#125; 对所有项目生效，在USER_HOME/.gradle/下创建init.gradle文件1234567891011121314151617181920212223allprojects&#123; repositories &#123; def ALIYUN_REPOSITORY_URL = &apos;http://maven.aliyun.com/nexus/content/groups/public&apos; def ALIYUN_JCENTER_URL = &apos;http://maven.aliyun.com/nexus/content/repositories/jcenter&apos; all &#123; ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository)&#123; def url = repo.url.toString() if (url.startsWith(&apos;https://repo1.maven.org/maven2&apos;)) &#123; project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot; remove repo &#125; if (url.startsWith(&apos;https://jcenter.bintray.com/&apos;)) &#123; project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot; remove repo &#125; &#125; &#125; maven &#123; url ALIYUN_REPOSITORY_URL url ALIYUN_JCENTER_URL &#125; &#125;&#125; 实用小技巧distributionUrl 尽量使用** bin.zip 如：gradle-xxx-bin.zip]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 架构相关笔记]]></title>
    <url>%2F2016%2F12%2F27%2F2016-12-27-Archtecture-for-Android%2F</url>
    <content type="text"><![CDATA[学习资源 Google 官方 android-architecture-components Google I/O Android App The Google I/O Android App Data Binding Guide Android Architecture Blueprints 【重点】 其他 Android Boilerplate 一些常用开源框架的集合 【重点】 Android Guidelines Architecture and code guidelines 2000+【重点】 常用的架构及教程 Google官方MVP+Dagger2架构详解 Android-CleanArchitectureRelative blog Architecting-android-the-clean-way EffectiveAndroidUI Retrofit2 Retrofit2 使用注意点总结 Tutorial Getting Started and Creating an Android Client 深入浅出 Retrofit，这么牛逼的框架你们还不来看看？ Dagger2 Providing test doubles with Dagger 1 and Dagger 2 Dagger2 Example 简明清晰的Dagger2教程 Dagger2 Android 告别Dagger2模板代码：Dagger Android使用详解 官方网址 图片加载 Glide 谷歌官方推荐使用 Glide 使用的详解教程 英文版 Glide 系列预览中文版 Picasso square 开源 12000+ star Picasso学习笔记 Fresco-Source-Analysis FluxFacebook 华人工程师提出的一种软件架构 Tutorial：Flux Architecture on Android Flux Architecture on Android 使用Otto在Android上简单是实现Demo Facebook官网对flux的介绍 【需要翻墙】 MVP MVP 简单的介绍, 及下面介绍推荐相关MVP教程 MVP Wiki 【英文】 Android中的MVP模式，带实例 MVP Android Example github 3700+ star Google Sample: Android Architecture Blueprints 之 MVP MVVM MVVM wiki 官方学习资料Data Binding Guide MVVMLight 对DataBind库进行优化，使MVVM用起来更加的简洁。 【推荐】 Approaching Android with MVVM 【英文】 开源工具库 truetime-android 一个可以在不同App,不同设备得到唯一的时间掺照物的库，IOS也有相同的库； Mortar 【待研究】 Scoop 【待研究】 任务处理 Android-Job Android library to handle jobs in the background. 页面关系的处理 alibaba/ARouter 典型应用场景 :从外部URL映射到内部页面，以及参数传递与解析跨模块页面跳转，模块间解耦拦截跳转过程，处理登陆、埋点等逻辑跨模块API调用，模块间解耦(注册ARouter服务的形式，通过接口互相调用) Cicerone 一个Activity/fragment/ViewGroup的路由库 系列文章问答 Android 开发有什么好的架构么? 【经典】 博客架构工具使用 不容错过，最全的安卓架构合集【从零开始搭建android框架系列（2）】 对应的Github地址 AndroidArchitectureCollection RxJava+Retrofit+OkHttp 懒人方式使用一 Google官方MVP+Dagger2架构详解 实战项目架构经验 The Making of Falcon Pro 3 三周开发，发布20天没有推广，安装量6000的经验介绍 【英文】 从360手机卫士的开发历程看如何实施大型移动应用开发 从整体上讲述软件开发流程及管理，清晰而且基本每个例子都很经典。看了第二次还是有很多收货。【重点】 英语流利说 Android 架构演进 逻辑条理清晰。 Android Application Architecture 译文 Architecting Android…The evolution 很经典的安卓架构文章，惊叹其架构层级之清晰，解耦之精妙，但是很难吃透不适合入门，会是整个软件架构很复杂 【英文】 从零开始的Android新项目1 - 架构搭建篇 简洁的概括了Android依赖库分层 开源项目线上商用项目 【重点研读】 Kickstarter for Android 一个用视频推销产品的电商APP，同时开源IOS，github 3300+ star官网：https://www.kickstarter.com/mobile Telegram 开源的Android聊天应用,有IOS,WP开源代码多平台Star 7000+ 加星项目 Timber Material Design Music Player github star 2200+【整体框架过了一遍，很多细节需要深入看】 Notes Material Design Notes App WordPress-Android Google 开源 Topeka for Android Material Design 的演示 APP 源代码 Google Santa Tracker for Android Features: A beautiful materially designed village 6 exciting games 2 interactive Android Wear watchfaces (with sound!) Videos, animations and more. 有用的功能性项目 Rox-Android一个基于Foursquare，根据位置信息及个人和朋友的喜好，推荐可能感兴趣的地方并提供导航 tickerCamera 这是一款集成了相机,图片裁剪,给图片贴贴图打标签的APP。 Tabby 手机App跳转到Chrome，设置样式及对应的菜单选项 用户引导帮助开源库 Highlight Ahoy-onboarding 其他Douya开源的 Material Design 豆瓣客户端（A Material Design app for douban.com） MusicStreamer mr-mantou-android 简单的架构及集合了国内一些第三方服务 扩展学习 Google首席软件工程师Joshua Bloch谈如何设计一款优秀的API【附PPT】]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推送实践]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-jpush-note%2F</url>
    <content type="text"><![CDATA[极光推送介绍极光推送自动集成官方 Android SDK 集成指南集成实践详细步骤注册极光账号 并配置Android 程序包名配置了jcenter支持1234567891011buildscript &#123; repositories &#123; jcenter() &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 集成依赖12345678910111213141516171819android &#123; defaultConfig &#123; applicationId &quot;com.xxx.xxx&quot; //JPush上注册的包名. ndk &#123; //选择要添加的对应cpu类型的.so库。 abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;armeabi-v8a&apos; // 还可以添加 &apos;x86&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos; &#125; manifestPlaceholders = [ JPUSH_PKGNAME : applicationId, JPUSH_APPKEY : &quot;你的appkey&quot;, //JPush上注册的包名对应的appkey. JPUSH_CHANNEL : &quot;developer-default&quot;, //暂时填写默认值即可. ] &#125;&#125;dependencies &#123; compile &apos;cn.jiguang.sdk:jpush:3.0.0&apos; // 此处以JPush 3.0.0 版本为例。 compile &apos;cn.jiguang.sdk:jcore:1.0.0&apos; // 此处以JCore 1.0.0 版本为例。&#125; Manifest自定义广播设置123456789101112131415161718192021222324&lt;!-- ************************************* --&gt;&lt;!-- The begin setting of JPush --&gt;&lt;!-- ************************************* --&gt;&lt;!-- User defined. 用户自定义的广播接收器--&gt;&lt;receiver android:name=".broadcast.JPushReceive" android:enabled="true"&gt; &lt;intent-filter&gt; &lt;!--Required 用户注册SDK的intent--&gt; &lt;action android:name="cn.jpush.android.intent.REGISTRATION" /&gt; &lt;!--Required 用户接收SDK消息的intent--&gt; &lt;action android:name="cn.jpush.android.intent.MESSAGE_RECEIVED" /&gt; &lt;!--Required 用户接收SDK通知栏信息的intent--&gt; &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_RECEIVED" /&gt; &lt;!--Required 用户打开自定义通知栏的intent--&gt; &lt;action android:name="cn.jpush.android.intent.NOTIFICATION_OPENED" /&gt; &lt;!-- 接收网络变化 连接/断开 since 1.6.3 --&gt; &lt;action android:name="cn.jpush.android.intent.CONNECTION" /&gt; &lt;category android:name="$&#123;JPUSH_PKGNAME&#125;" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;!-- ************************************* --&gt;&lt;!-- The end setting of JPush --&gt;&lt;!-- ************************************* --&gt; 自定义广播接收器官方Demo代码 JPushReceive.java 初始化12345678public class ExampleApplication extends Application &#123;@Override public void onCreate() &#123; super.onCreate(); JPushInterface.setDebugMode(true); JPushInterface.init(this); &#125;&#125; 测试API集成是否成功 启动应用程序，出现如下日志，说明SDK运行正常 12 [JPushInterface] action:init - sdkVersion:3.0.0, buildId:319pushcore I/JIGUANG-JCore: [ConnectingHelper] Login succeed 运行App，到控制台发送测试推送 【重点-填坑】如果没有收到推送重启手机， 日志会打印某些jni调用的代码未找到； 经验集成SDK，配置完成后需等待一段时间，功能才会见效； 进价别名与标签把绑定关系保存到 JPush 服务器端 使用案例： 动态标签 根据角色和地域等相关的信息动态设置标签和别名，从而区分收到推送的客户；相关方法123JPushInterface.setAlias(Context context,String alias, TagAliasCallback CallBack);JPushInterface.setTags(Context ctx,Set&lt;String&gt; tags, TagAliasCallback CallBack);JPushInterface.setAliasAndTags(getApplicationContext(), null, (Set&lt;String&gt;) msg.obj, mTagsCallback); 温馨提示 设置标签别名请注意处理call back结果。只有call back 返回值为 0 才设置成功， 才可以向目标推送。否则服务器 API 会返回1011错误。 RegistrationID把绑定关系保存到开发者应用服务器中 客户端设置通知栏样式 铃声、震动显示图标替换默认的通知栏样式。 自定义通知栏样式12345678910111213141516171819202122232425262728293031323334/** * 设置通知提示方式 - 基础属性 */private void setStyleBasic() &#123; BasicPushNotificationBuilder builder = new BasicPushNotificationBuilder(PushSetActivity.this); builder.statusBarDrawable = R.drawable.ic_launcher; builder.notificationFlags = Notification.FLAG_AUTO_CANCEL; //设置为点击后自动消失 builder.notificationDefaults = Notification.DEFAULT_SOUND; //设置为铃声（ Notification.DEFAULT_SOUND）或者震动（ Notification.DEFAULT_VIBRATE） JPushInterface.setPushNotificationBuilder(1, builder); Toast.makeText(PushSetActivity.this, &quot;Basic Builder - 1&quot;, Toast.LENGTH_SHORT).show();&#125;/** * 设置通知栏样式 - 定义通知栏Layout */private void setStyleCustom() &#123; CustomPushNotificationBuilder builder = new CustomPushNotificationBuilder(PushSetActivity.this, R.layout.customer_notitfication_layout, R.id.icon, R.id.title, R.id.text); builder.layoutIconDrawable = R.drawable.ic_launcher; builder.developerArg0 = &quot;developerArg2&quot;; JPushInterface.setPushNotificationBuilder(2, builder); Toast.makeText(PushSetActivity.this, &quot;Custom Builder - 2&quot;, Toast.LENGTH_SHORT).show();&#125;private void setAddActionsStyle() &#123; MultiActionsNotificationBuilder builder = new MultiActionsNotificationBuilder(PushSetActivity.this); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;first&quot;, &quot;my_extra1&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;second&quot;, &quot;my_extra2&quot;); builder.addJPushAction(R.drawable.jpush_ic_richpush_actionbar_back, &quot;third&quot;, &quot;my_extra3&quot;); JPushInterface.setPushNotificationBuilder(10, builder); Toast.makeText(PushSetActivity.this, &quot;AddActions Builder - 10&quot;, Toast.LENGTH_SHORT).show();&#125; 错误处理gradle.properties 增加 android.useDeprecatedNdk=true 使用旧版本的ndk集成方式,不添加会报错: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin.]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>第三方SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android测试资源集合,测试工具,测试开源项目]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-android-test%2F</url>
    <content type="text"><![CDATA[测试第三方服务 国内 https://bugly.qq.com/v2/ 腾讯的bugly 免费, 而且相当好用 腾讯优测云 提供真机测试和漏洞分析 Testin MTC 易测云 国外 TestCloud Testdroid Nimbledroid Automated performance analysis website Test bird APP和手游测试 kobiton 免费的在线真机测试 第三方性能采集SDK OneAPM 听云 自动化测试 CircleCI 一个基于Github的自动化测试，单元测试工具，提供一个免费的私有仓库。 Google官方学习资料 Best Practices for Testing 【最新/重点】 Android Testing Support library (ATSL) 【重点】相关视频： Android Testing (Android Dev Summit 2015) youtube 2015年视频 Developer API Testing Concepts 优秀博客 Java 测试 Leveraging product flavors in Android Studio for hermetic testing 与之对应的 codelab学习地址笔记： Just Say No to More End-to-End Tests two JUnit Rules @rule will be launched before @Before. The ActivityTestRule is a rule that provides functional testing of a single Activity. Test coverage report for Android application 使用jacoco-android plugin in a build.gradle进行测试覆盖率报告 Android单元测试在蘑菇街支付金融部门的实践 很详细介绍了单元测试在实践操作中的使用 RxJava Test Unit Testing RxJava Observables and Subscriptions Unit Testing RxJava Observables Unit Testing with RxJava UI测试 小心！做UI自动化一定要跨过这些坑 【待看】 测试框架 Unit Testing Junit4 Github A programmer-oriented testing framework for Java.http://junit.org/junit4/ Mockito Tasty mocking framework for unit tests in Java JMockit An automated testing toolkit for Java对比： mockito不能mock static method和final class、final method，JMockit可以；对比Mockito和JMockit的文章 PowerMock 一个可以Mock静态类的开源库 Tools for UI Testing: Robotium, Appium, Calabash, Robolectric. UI Testing Espresso Android 官方推荐使用的UI测试库 UIAutomator 可以夸应用进行测试 Robolectric is a unit test framework that de-fangs the Android SDK jar so you can test-drive the development of your Android app. Tests run inside the JVM on your workstation in seconds More RoboSpock Github A testing framework which brings powers of Spock and Groovy to Android app testing http://robospock.org Hamcrest matchersWhat is Hamcrest?Hamcrest is a library of matchers, which can be combined in to create flexible expressions of intent in tests. They’ve also been used for other purposes. Calabash 特点: 支持多种平台，代码复用性强:代码同时支持Android 和iOS, Web也有一定的支持; 语法更接近自然语音,易懂也易维护; 纯黑盒测试。 开源库 Collection awesome-android-testing collection of android test info 【重点】 Sample android-gradle-java-template Gradle + Android Studio + Robolectric + Espresso + Mockito + EasyMock/PowerMock + JaCoCo Demo Android-Clean-Testing Android Testing Sample Project robotium-showcase This example shows how to use Robotium with ActvitityTestRule and @Test annotation, it means in Google’s Espresso way. Google Sample android-testing-templates android-testing A collection of samples demonstrating different frameworks and techniques for automated testing Tools 测试工具square/spoon在adb devices 检测到的设备跑测试程序，并提供截屏，文件，数据库操作：最最重要的是生成简单明了的测试报告： Android Studio 2.2 Preview new feature: Espresso Test Recorder 菜单/run/Recorder Expresso Test 选项可以记录你的操作并转化为Espresso 的测试代码 APK Analyzer 菜单/build/Analyzer APK 提供APK大小分析工具，清楚的知道代码体积变换的趋势。 screengrab 当UI Tests 时自动化截屏STF 远程控制，一台电脑控制测试多个测试设openstf.github.io Control and manage Android devices from your browser Vysor 用Chrome浏览器控制你的Android手机 Vysor让你在电脑上完全控制android手机屏幕镜像 Vysor 情怀玩法 （番外篇） 开发时的调试工具stethoFacebook开源，很强大的Android网络和数据库调试工具,能像调试WebApp一样调试Android原生应用。借助Stetho在Chrome上调试Android网络&amp;数据库常用配置: 初始化 123456public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); Stetho.initializeWithDefaults(this); &#125;&#125; Chrome浏览器打开chrome://inspect/#devices 进阶增加网络拦截 Dependency 增加依赖环境 12345compile 'com.facebook.stetho:stetho:1.3.1'compile 'com.facebook.stetho:stetho-okhttp3:1.3.1'compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'compile 'com.squareup.okhttp3:okhttp:3.2.0'compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4' 向OkHttpClient增加网络拦截 123OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); augmented-traffic-controlFackbook开源项目模拟移动网络，对App的调试及网络优化有很大的帮助，主要参数有：12345网络带宽（bandwidth）延迟（latency）丢包率（packet loss）错包率（corrupted packets）乱序率（packets ordering） GT（随身调） 腾讯开源的测试套件能Android设备上安装,进行移动调试,确保测试数据的真实有效性开源地址: https://github.com/TencentOpen/GT官网地址 使用GT APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。 12345678910111213141516一. 基本功能测试1. CPU占有率;2 jiffes（CPU时间片）;3. 内存PSS值稳定在36M;4. 网络上行流量和下行流量;5. "数据存档"二. 电量测试再启动电流监控观察，1分钟后平均电流是220mA三. crash- 保存了抓包文件后;- Logcat查看界面，立即把手机缓存的Logcat日志保存下来;四. Net- 系统提供的流量查看也包括局域网socket的流量,而且不能分时段统计;- tcpdump抓包(需要手机root) + Wiresharek 抓包分析;疑问点:1. 激活FPS（帧率）的监测; 应用开发助手 Google Play、应用宝搜索“开发助手”下载， 或Download1234屏幕分辨率、CPU 核数、IP 及 Mac 地址、so 类型、系统版本。频繁切换“严格模式”；多次启停“显示布局边界”；测试被系统回收来回切换“不保留活动”； Android Debug Drawer 查看设备信息 安卓日志工具 XLog github微信mars 的高性能日志模块 xlog Pidcat Timber jakewharton 出品 123456789101112131415161718192021compile 'com.jakewharton.timber:timber:4.5.1' // 初始化 if (BuildConfig.DEBUG) &#123; Timber.plant(new Timber.DebugTree()); &#125; else &#123; Timber.plant(new CrashReportingTree()); &#125; //发布后程序（Release.apk），崩溃日志上报 /** A tree which logs important information for crash reporting. */ private static class CrashReportingTree extends Timber.Tree &#123; @Override protected void log(int priority, String tag, String message, Throwable t) &#123; if (priority == Log.ERROR) &#123; String msg = message + (t == null ? "" : t.getMessage()); MobclickAgent.reportError(mContext, String.format("TAG=%s, msg=%s, Throwable=%s", tag, message, t == null ? "" : t.getMessage())); //友盟错误上传// Crashlytics.log(priority, tag, msg);// Fabric 错误上传 &#125; &#125; &#125; Hugo 用注解的方式日志打印方法传入的参数 Annotation-triggered method call logging for your debug builds. Pury like Hugo But Android library for measuring time between multiple independentevents. KLog 这是一个Android专用的LogCat工具，主要功能为打印行号、函数调用、Json解析、XML解析、点击跳转、Log信息保存等功能 ViewInspector 查看View绘制层级，参数等View Inspection Toolbar for Android Development Purchase UI Tool (付费工具) Robotium Recorder 优化和分析工具Quality-Tools-for-Androidvb-android-app-qualityAndroidCodeQuality每次打包时都进行一次 checkstyle,pmd,findbugs验证 AndroidDevMetricsPerformance metrics library for Android development AndroidPerformanceMonitor一个对ANR（UI线程block）的监控工具 A transparent ui-block detection library for Android. (known as BlockCanary)]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Tutorial]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-hexo-tutorial%2F</url>
    <content type="text"><![CDATA[Hexo 相关教程 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hexo安装环境准备 Git / Node.js hexo官方教程两个初始化命令hexo init 类似git init 需要新建目录保存博文信息； 执行命令会在当前目录下生产如下文件：123456├── _config.yml #全局配置文件├── node_modules #Hexo插件（Node.js 插件默认安装目录）├── package.json #Node 工程的依赖和基本信息├── scaffolds #模板├── source #博客正文源文件└── themes 【重点】如果你有配置，会覆盖你原来的配置； npm install #安装package.json 下面的依赖包hexo http://localhost:4000/ 检查是否安装成功测试hexo是否正确安装123456 hexo init &lt;folder&gt; cd folder npm install npm install hexo-server --save hexo server# 访问是否正常显示 http://localhost:4000/ hexo 配置hexo-theme-next主题的配置 最强主题基本上所有的配置信息都能满足,优雅,文档齐全 安装 Next主题 基本和教程走一边,就可以得到一个很牛的网站了 三种主题样式的选择： hexo/themes/next/_config.xml 搜索 scheme 网站logo设置 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。next主题：将图片放在next主题source/images目录下在next主题配置文件中添加：favicon: images/favicon.ico 设置首页是否为摘录（不显示所有内容）{your-hexo-dir}/themes/next/_config.yml auto_excerpt true 注册云存储存储图片防止图片链接失效,和在博客迁移过程中导致的图片获取异常,丢失. 统一管理文章中的图片 七牛 域名绑定 设置域名的指向的地址 在源文件中增加github page 的设置文件 source/CNAME 并增加你的域名,不带www的,例如:’taobao.com’Hexo 显示访问次数Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sitesMore info: Deployment1$ hexo deploy 常用的方法命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 一般的发布步骤123hexo clean #删除产生的文件和缓存hexo (g)generate # 生成静太文件hexo (d)deploy # 发布网页 日常维护命令123npm update -g hexo #hexo 更新cd /&#123;you-blog-dir&#125;/theme/next git pull #更新主题代码npm update # 更新插件 高级玩法添加网易云音乐由于markdown支持HTML, 打开网页版网易云音乐–&gt; 点击生成外链播放器 –&gt; 直接粘贴网易云音乐的外链接iframe代码 添加high一下效果整个页面渐进式摇摆,摇摆 复制header.swig的代码到{your-hexo-dir}/themes/next/layout/_custom/header.swig 本地刷新在菜单栏附近出现High一下 点击查看效果 问题解决 ERROR Plugin load failed: hexo-server 解决: npm install hexo-server ERROR Deployer not found: Git 解决： npm install hexo-deployer-git –save Cannot GET 解决 npm install 参考 GitHub Pages 绑定来自阿里云的域名 手把手教你建github技术博客 hexo下新建页面下如何放多个文章？ 博客推广——提交搜索引擎 动动手指，不限于NexT主题的Hexo优化（SEO篇）]]></content>
      <categories>
        <category>coder</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native for Android]]></title>
    <url>%2F2016%2F11%2F20%2F2016-11-20-React-Native-for-Android%2F</url>
    <content type="text"><![CDATA[入门 React Native for Android 入门老虎problem solution: when “brew install watchman” ==&gt;&gt; configure: error: You need a C++ compiler for C++ support ==&gt; sudo apt-get install build-essential2. brew install flow ==&gt;&gt; bnpm install flow-bin –global Android开发技术周报特刊之React Native 【经典教程】 Facebook.org react react-native React-Native 的优化进阶之旅 进阶 构建 F8 App / React Native 开发指南 【ReactNative For Android】框架启动核心路径剖析 印象笔记有备份 携程 React Native 实践与性能优化 相关开源项目 DoubanMovie-React-Native create-react-app Create React apps with no build configuration. Learning material react-native-guide React-Native指南汇集了react-native学习资源与各类开源app CodePush 大微软推出的一套可以为用 React Native 和 Cordova 开发的 App 提供代码热更新的方案。 React Native Training (中文) 视频 介绍 InfoQ: 探索 React 生态圈 Atom官网安装1234sudo add-apt-repository ppa:webupd8team/atomsudo apt-get updatesudo apt-get install atom/opt/atom/atom Proxy setting from apm github1234567Using a proxy?If you are using a HTTP(S) proxy you can configure apm to use it by running:apm config set https-proxy https://127.0.0.1:1080You can run apm config get https-proxy to verify it has been set correctly. plugincp the plugin.zip to ~/.atom/packages or $ apm install color-picker emmet-atom browser-plus highlight-selected atom-api-blueprint-preview Read.md previewjshint：检查 JavaScript 的语法，支持 JSX （需要在插件设置中开启 Support Linting JSX）；emmet：用 emmet （Zen Coding）方式快速编写页面；save-session：让 Atom 记住上一次打开的会话；browser-plus：在 Atom 中内嵌一个浏览器窗口，方便页面调试（其实 Atom 本身就是一个浏览器）；minimap：如果你对 Sublime Text 的 minimap 念念不忘；atomic-emacs：Emacs 键盘布局，适合 Emacs 用户使用；vim-mode：Vim 键盘布局，适合 Vim 用户使用。 待处理 atom-space-pen-views atom-html-preview 教程Atom 使用教程]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>facebook</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据处理资源总汇]]></title>
    <url>%2F2016%2F09%2F08%2F2016-09-08-Android-database-note%2F</url>
    <content type="text"><![CDATA[数据格式 gson Gson Json Annotations Example stag-java Speedy Type Adapter Generation fastjson 序列化 Parcelable Parcelable AutoValue使用 Google AutoValue 自动生成代码 Dependencies12345dependencies &#123; provided &apos;com.google.auto.value:auto-value:1.2&apos; apt &apos;com.google.auto.value:auto-value:1.2&apos; apt &apos;com.ryanharter.auto.value:auto-value-parcel:0.2.1&apos;&#125; Sample12345678@AutoValuepublic abstract class Story implements Parcelable&#123; public abstract int id(); public abstract String title(); public static Story create(int id, String title)&#123; new AutoValue_Story(id,title); &#125;&#125; 日常笔记 Sqlite 批量处理 SQLite批量插入和其他一些使用心得 android SQLite 批量插入数据慢的解决方案 Tutorial sqlite-tutorial Android 保存图片到SQLite,读出SQLite中的图片 sqlite 官方教程 CREATE TRIGGER Sqlite learnning Course SQL语句 Inner join/ union 的学习1select f.name ,count(1) as sum, d.value as url from Favorite f inner join data d on d.key==f.name group by f.name 笔记好滴博文 5个Android ORM框架 Android 主流ORM（对象关系数据映射）简介 常用的SQL语句1234567891011121314DROP TABLE IF EXISTS t_studentCREATE TALBE IF NOT EXISTS t_student (id iteger primary key autoincrement, name text, age integer, score real );INSERT INTO t_student (name,age) values ('jack',22)update t_student set name='jack' ,id =1 select * from t_student where score &gt;= 60 order by score asc, age asc;limit 分页查询limit 0,5limit 5,5约束not null, unique, default外键—— create table t_student (id integer primary key autoincrement,name text, class_id integer,constraint fk_t_student_class_id_t_class_id foreign key (class_id) references t_class(id)) No Sql RxPaper Like below Paper Rx-preferences Reactive SharedPreferences for Android http://f2prateek.com/2015/10/05/rx-preferences/ Leveldb is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values. Paper save/restore Java objects by using efficient Kryo serialization and handling data structure changes automatically. Iron Fast and easy to use NoSQL data storage 轻量对原生方法的封装（Origin API Extension） Favor A easy way to use android sharepreference SQLite ORM LitePal Android数据库高手秘籍 greendao Home page, documentation, and support links: http://greenrobot.org/greendao/ Chinese tutorial requery 又一轻量ORM库 What is a good tutorial for using ORMLite with SQLite and Android Improve SQLiteOpenHelper and ContentResolverSquare 出品 Sqlbrite A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.http://square.github.io/sqlbrite/ sqldelight Generates Java models from CREATE TABLE statements.（从sql语句生成Java模式 ）能把sql统一管理 Delightful-SQLBrite sqldelight 和 SQLBrite 例子 Qit Storio Beautiful API for SQLiteDatabase and ContentResolver Android InstanceIcepick Android Instance State made easy It works for Activities, Fragments or any object that needs to serialize its state on a Bundle Tools(工具) android_dbinspector Sqlite3 sqlite3 not foundblog: sqlite3 not found的解决办法 cant-remount-system-in-rw Nexus5使用有效果的命令：mount -o remount,rw /system chmod 4755 /system/xbin/sqlite3 sqlite3 robot.db ==&gt; error: only position independent executables (PIE) are supported. 优化 WeChat Sqliste 微信ANDROID客户端-会话速度提升70%的背后 protocol buffer (protobuf)]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>数据库</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 相关的新技术]]></title>
    <url>%2F2016%2F08%2F04%2F2016-08-04-New-trend-for-Android%2F</url>
    <content type="text"><![CDATA[Dynamic Loading 360 出品 DroidPlugin A plugin framework on android,Run any third-party apk without installation, modification or repackage Like web app release version ==&gt;open source Nuwa 女娲（Nuwa），可以热修复Android应用，可以加快编译 Dynamic-loading Alibabadexposed AOP (Aspect-oriented Programming) framework for Android app developmentAndFix C++ Android App 线上热修复方案 Android平台免Root无侵入AOP框架Dexposed使用详解 【翻译】Android中的AOP编程 Alibaba-Dexposed框架在线热补丁修复的使用 weex 阿里开源,类似React Native基于JS开源夸平台开源库 携程插件框架DynamicAPK Solution to implement multi apk dynamic loading and hot fixing for Android App. (实现Android App多apk插件化和动态加载，支持资源分包和热修复) 如何实现携程动态加载插件中对aapt的改造 Samll 做最轻巧的跨平台插件化框架。支持平台：Android API 15(4.0.3)+ iOS 7.0+ 敬请期待。 Xposed 用黑客思维做测试——神器 Xposed 框架介绍 官网教程: Development-tutorial tinker github 微信热更新方案 Tinker_imitator 微信热更新方案实践 博文介绍 微信Tinker的一切都在这里，包括源码(一) tinker-manager 微信tinker补丁管理，后端代码+客户端sdk 博文讲解Android插件化原理解析——Hook机制之Binder Hook Weex阿里开源基于JS开源夸平台开源库,类似React Native但是更轻量，学习成本低。 Weex 官网 阿里无线11.11 ： Weex——关于移动端动态性的思考、实现和未来 Kotlin Weekly Kotlin 资源合集 org.website Tutorial Online Compile Tutorial command-line reference Examples Kotlin语言1.0Beta发布，JetBrain介绍其设计理念 Kotlin 1.0都出了还没看过肿么办？不怕！来看我整理的Kotlin学习资源 相关开源库： AdvancedRecyclerView RxAndroidReading Grokking RxJava, Part 4: Reactive Android Rxlint compile &#39;nl.littlerobots.rxlint:rxlint:1.0 优化 redex 通过对字节码进行优化，以减小 Android Apk 大小，同时提高 App 启动速度。Facebook App 优化工具 ReDex 优化的 6 点及未优化的一大方面 统一开发 Multi-OS Engine Create Android and iOS apps using Java Coding 一个能用Android Studio统一开发 IOS Android Window 应用的引擎。 开源库 android-ocr optical character recognition (OCR) 文字识别]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>New Trench</tag>
        <tag>Android</tag>
        <tag>新技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design]]></title>
    <url>%2F2016%2F07%2F29%2F2016-07-29-Material-Design%2F</url>
    <content type="text"><![CDATA[前言一、设计阶段Material Design 提供了跨设备和 Web 的一致性用户体验。它的四项原则： 有型的外观(Tangible surface)：应用像现实中的实物一样。 仿印刷品的设计(Print-like design)：内容醒目、形象生动、意图明确。 有意义的运动效果(Meaningful motion)：吸引用户的兴趣，在应用状态切换时保持连续性。 自适应设计(Adaptive deisgn)：用户在手机、平板、Android TV、Android Wear、Android Auto 等不同设备上都能感到熟悉、一致，而不需要重新适应应用。 文档官方API The Transitions Framework Support Library 官方博客 [1]Android Design Support Library Android Support Library 23.2 Resource Awesome-MaterialDesign 【重点】 Material design icons by Google Animation: Jump-through【待研究】【重点】 An Introduction to Icon Animation Techniques 非常详尽的介绍并附有代码例子讲解 【重点】 Animate all the things. Transitions in Android一个关于transitions-everywhere Motion Material 兼容库的介绍的博客 Music Player: From UI Proposal to Code 一个介绍Material Transitions 的例子，但是没有兼容低版本 App Bar layout smooth-app-bar-layout StatusBarCompat Api &gt;= 19 Material Design 新特性 Codelab for Android Design Support Library used in I/O Rewind Bangkok session 介绍Material Design 新特性很详细的文章 对应的代码Github SVG SVG Path reference. Animating Vector Drawables. PathMorphing with AnimatedVectorDrawables in Android ColoredVector-Android VectorDrawable 和 AnimatedVectorDrawable 的兼容性问题 TV Docs http://developer.android.com/tv/index.html androidtv-Leanback ToolbarToolBar详解 TabLayout TabLayout：另一种Tab的实现方式 如下代码，Tab间隔转换会有更好的动画效果。 123Method animateToTab = clz.getDeclaredMethod("animateToTab", new Class[]&#123;int.class&#125;);animateToTab.setAccessible(true);animateToTab.invoke(tabLayout, new Object[]&#123;5&#125;); 与ViewPager结合标准代码 1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.ac_tab_layout); // 获取ViewPager ViewPager viewPager = (ViewPager) findViewById(R.id.ac_tab_vp); // 构造一个TabPagerAdapter对象 TabPagerAdapter adapter = new TabPagerAdapter(); // 获取ViewPager TabLayout tabLayout = (TabLayout) findViewById(R.id.ac_tab_layout); // 设置TabLayout模式 tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE); // 设置ViewPager的适配器 viewPager.setAdapter(adapter); // 设置ViewPager tabLayout.setupWithViewPager(viewPager);&#125; Bottom NavigationDependence12compile 'com.android.support:appcompat-v7:25.0.0'compile 'com.android.support:design:25.0.0' Tutorial：Now you can use the Bottom Navigation View in the Design Support Library TextInputLayout codelabs constraint-layout [good] Creating a Login Screen Using TextInputLayout MaterialEditText 抛物线【RxJava经典入门教程的博主】ConstraintLayout Using ConstraintLayout to design your views ConstraintLayout API Build a Responsive UI with ConstraintLayout ConstraintLayout – Part 1 Script To convert an existing layout to a constraint layoutDesign -&gt; component Tree -&gt; Convert layout to ConstraintLayout 开源资源资源 Demos the new Android Design library github star 6300+ MaterialDrawer The flexible, easy to use, all in one drawer library for your Android project CircularAnim Android水波动画帮助类，一行代码实现View显示/隐藏/startActivity特效。(对 ViewAnimationUtils.createCircularReveal() 方法的封装) 字体和图片相关 Material Icon Library Github 1800+ star主要特点： 包含1500+ 的矢量图标（大小: 200kb）； 支持API&gt;=4； 可以转化为Drawable，可以menu.xml 中使用， 可以在Toolbar menu中使用 使用：1. 在https://materialdesignicons.com找矢量图； 2.集成库使用； Android-Iconics 【推荐】主要特点： 提供了三个矢量图库； 可以在原生控件上使用； 支持字体和矢量图片的自定义； Material Animation 动画 Material-Animations Android-Material-Examples New Feature 新的特性 material-tip Theme 主题 Android-Material-Themes-Demo 设置相关 material-about-library 原生控件的包装 Atelier A fast and clean way of using Palette in lists material-code-input material-dialogs 兼容开源库 ActSwitchAnimTool ActSwitchAnimTool make the Animation easy to implements, and it compat the version of Android 4.0 or above. RippleDrawable support 14+ WaveCompat fab-transformation nice-spinner support 14+ ToggleDrawable CircularReveal RevealEffect support 2.3 Transitions-Everywhere API compatible with Android 2.2+ MaterialStyledDialogs API 11+ required. vector-compat vector 兼容库 Material Design 参考资料 Android 开发设计 http://developer.android.com/design/ Material Design 示范应用 和 获奖应用 Google Design 网站 https://design.google.com/ Material Design 设计规范 http://www.google.com/design/spec/material-design/introduction.html Icons Tool https://design.google.com/icons/ Devices Tool https://design.google.com/devices/ Udacity 免费设计课程：Material Design for Android Developers]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌官网之硬件加速 【译】]]></title>
    <url>%2F2016%2F06%2F02%2F2016-06-02-Google-Api-hareware-acc%2F</url>
    <content type="text"><![CDATA[硬件加速 Android 3.0 (API level 11)开始，Android 2D渲染管道支持硬件加速。API level &gt;=14的Android系统默认开启硬件加速。由于硬件加速并不支持所有的2D绘制操作，所以开启硬件加速，可能会导致自定义view中部分元素看不到，程序抛出异常，或者错误的像素渲染等问题。 开启/关闭硬件加速 Application&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; Activity 1234&lt;application android:hardwareAccelerated="true"&gt;&lt;activity ... /&gt;&lt;activity android:hardwareAccelerated="false" /&gt;&lt;/application&gt; Window 级别只能开启硬件加速 123getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View 关闭硬件加速myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null); View硬件加速的判断两个方法： View.isHardwareAccelerated()) Canvas.isHardwareAccelerated()) 你必须在你绘制代码（drawing code）内检测，使用前者而不是后者，因为有可能View虽然依附于一个硬件加速的窗口，但它依然可以在一个没有硬件加速的Canvas上绘制，列如：为了缓存的目的把view绘制到一个bitmap上。 Android 软加速/硬加速 绘制模式基于软件的绘制模式绘制步骤：无效从下到上的View，然后重新绘制。问题： 没有改变的大量上层的View需要重新绘制。 Android重绘view的过程，有可能没有绘制发生改变的view，此时你只能依赖其他view包含恰好的重绘行为。 硬件加速的绘制模式绘制步骤： 无效从下到上的View 记录和更新显示列表（display lists） 绘制显示列表 优点： 使用display lists能有针对性的更新改变的View 不支持的绘制操作Canvas Scaling View LayersOff-screen buffers a view’s drawing cache Canvas.saveLayer()) 所有的Android版本都支持对Off-screen buffers进行渲染。 你会获得更好的性能，当做复杂view的动画或者应用合成效果时。列如，当你实现淡出效果时，你可以使用Canvas.saveLayer()，暂存渲染的view到layer中，然后用透明度合成，使它返回屏幕达到淡出效果。 View.setLayerType()) LAYER_TYPE_NONE 不使用 off-screen buffer 【默认】 LAYER_TYPE_HARDWARE LAYER_TYPE_SOFTWARE 选择技巧 Performance: 使用硬件加速时，一旦一个view渲染进如layer中，只有调用invalidate())是绘制的代码才会被执行。一些动画，列如透明度动画，可以直接用于layer中，这使用GPU去执行是非常高效的。 Compatibility: Use a software layer type to force a view to be rendered in software. View layers and animations如果你在你的应用中跑的动画没有达到，你想要的流程结果，你可以考虑启动硬件加速。 以下的属性，使用合成来作用于layer，使用的是优化的invalidation及不需要重绘目标view，过程更高效。 alpha: Changes the layer’s opacity x, y, translationX, translationY: Changes the layer’s position scaleX, scaleY: Changes the layer’s size rotation, rotationX, rotationY: Changes the layer’s orientation in 3D space pivotX, pivotY: Changes the layer’s transformations origin demo：123456789View.setLayerType(View.LAYER_TYPE_HARDWARE, null);ObjectAnimator animator = ObjectAnimator.ofFloat(view, "rotationY", 180);animator.addListener(new AnimatorListenerAdapter() &#123;@Overridepublic void onAnimationEnd(Animator animation) &#123;view.setLayerType(View.LAYER_TYPE_NONE, null);&#125;&#125;);animator.start(); 提示和技巧 减少view的数量 避免过度绘制A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!). 不创建渲染类在绘制代码中：如在onDraw中 new Paint 或者 Path。 不频繁的改变形状Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive. 不频繁的修改bitmap 谨慎使用alpha，当应用alpha属性到很大的views时，考虑使用 LAYER_TYPE_HARDWARE。.]]></content>
      <categories>
        <category>translate</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>google</tag>
      </tags>
  </entry>
</search>
